
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Linux内核分析作业1：</title>
    
    <meta name="author" content="siplexy">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Bootstrap styles -->
    <link href="/assets/themes/bootstrap-3/bootstrap/css/bootstrap.min.css" rel="stylesheet">
   <!--  <link href="/assets/themes/bootstrap-3/css/prettify.css" rel="stylesheet"> -->
   <link rel="stylesheet" href="/assets/themes/bootstrap-3/css/zenburn.css">
    <!-- Optional theme -->
    <link href="/assets/themes/bootstrap-3/bootstrap/css/bootstrap-theme.min.css" rel="stylesheet">
    <!-- Sticky Footer -->
    <link href="/assets/themes/bootstrap-3/bootstrap/css/bs-sticky-footer.css" rel="stylesheet">
    
    <!-- Custom styles -->
    <link href="/assets/themes/bootstrap-3/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!-- Update these with your own images
      <link rel="shortcut icon" href="images/favicon.ico">
      <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
      <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
      <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
    -->

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div id="wrap">
      <nav class="navbar navbar-default" role="navigation">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#jb-navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">Sip 桑 的 Blog~ ^。^</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="jb-navbar-collapse">
          <ul class="nav navbar-nav">
            
            
            


  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories.html">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages.html">Pages</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  



          </ul>
          <form class="navbar-form navbar-right" role="search">
            <div class="form-group">
              <input type="text" class="form-control" placeholder="Search">
            </div>
            <button type="submit" class="btn btn-default">Submit</button>
          </form>
        </div><!-- /.navbar-collapse -->
      </nav>

      <div class="container">
        
<div class="page-header">
  <h1>Linux内核分析作业1：  <small>X86体系下计算机是如何运行程序</small></h1>
</div>

<div class="row">
  <div class="col-xs-12">
    <h4>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000</h4>

<h3>一、 现代计算机模型---冯诺依曼体系结构</h3>

<p>冯诺依曼体系结构就是指存储程序计算机</p>

<p>经典的存储程序计算机由以下五部分组成：</p>

<p><img src="http://baike.soso.com/p/20090709/20090709080850-1101162591.jpg" alt="jiego"></p>

<p>(其中 实线代表 数据线 虚线代表 控制线)</p>

<ol>
<li>采用存储程序方式，指令和数据不加区别混合存储在同一个存储器中，（数据和程序在内存中是没有区别的,它们都是内存中的数据,当EIP指针指向哪 CPU就加载那段内存中的数据,如果是不正确的指令格式,CPU就会发生错误中断. 在现在CPU的保护模式中,每个内存段都其描述符,这个描述符记录着这个内存段的访问权限(可读,可写,可执行).这最就变相的指定了哪个些内存中存储的是指令哪些是数据）
指令和数据都可以送到运算器进行运算，即由指令组成的程序是可以修改的。</li>
<li>存储器是按地址访问的线性编址的一维结构，每个单元的位数是固定的。</li>
<li>指令由操作码和地址组成。操作码指明本指令的操作类型,地址码指明操作数和地址。操作数本身无数据类型的标志，它的数据类型由操作码确定。</li>
<li>通过执行指令直接发出控制信号控制计算机的操作。指令在存储器中按其执行顺序存放，由指令计数器指明要执行的指令所在的单元地址。指令计数器只有一个，一般按顺序递增，但执行顺序可按运算结果或当时的外界条件而改变。</li>
<li>以运算器为中心，I/O设备与存储器间的数据传送都要经过运算器。</li>
<li>数据以二进制表示。</li>
</ol>

<p>（上的现代微处理器体系结构这么课还提到了<a href="http://www.cnblogs.com/li-hao/archive/2011/12/21/2296010.html">哈佛结构</a> 和冯诺依曼结构区别主要在于数据和指令分开存储）</p>

<h3>二、 X86计算机结构</h3>

<p><a href="http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2501972.html">80X86寄存器详解</a></p>

<p><img src="/images/r2.png" alt="结构"></p>

<h3>三、实验代码汇编分析</h3>

<p>C语言代码如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int g(int x){
    return x-3;
}
int f(int x){
    return g(x);
}
int main(){
    return f(1)+2;
}
</code></pre></div>
<p>通过gcc进行编译后生成*.s汇编代码</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ gcc -S -o main.s main.c -m32
</code></pre></div>
<p>(注：-m32 代表以32bit为链接库编译 64bit操作系统需要安装<a href="http://andycoder.me/fix-32bug-under-ubuntu1404/">libc6:i386</a> 32位库)</p>

<p>得到汇编代码main.s:
(这里删除了.long .global .section <a href="http://blog.csdn.net/jnu_simba/article/details/11747901">节或汇编程序辅助信息</a>)</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">g:
    pushl    %ebp
    movl    %esp, %ebp
    movl    8(%ebp), %eax
    subl    $3, %eax
    popl    %ebp
    ret
f:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $4, %esp
    movl    8(%ebp), %eax
    movl    %eax, (%esp)
    call    g
    leave
    ret
main:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $4, %esp
    movl    $1, (%esp)
    call    f
    addl    $2, %eax
    leave
    ret
</code></pre></div>
<hr>

<p>以下是分析：</p>

<p>main：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    pushl   %ebp
    movl    %esp, %ebp
</code></pre></div>
<p>这两条指令可以放在一起看 相当于enter</p>

<p>进入函数体都会最先执行这条enter指令</p>

<p>作用是切换到保存上一个栈的栈底，并且将当前栈顶位置设置为栈底</p>

<p>栈结构：</p>

<p><img src="/images/1.png" alt="结构"></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    subl    $4, %esp
    movl    $1, (%esp)
</code></pre></div>
<p>这两条指令也可以放在一起看</p>

<p>在main函数中我们是f(1)+2 吗？这里有个 立即数1 
我们要如何使用这个参数呢？肯定需要把他放在内存中放在堆栈中</p>

<p>所以这里 先是下移一个位置，指向一个空的区域，然后把 ‘1’ 放入这个空间中</p>

<p>相当于 push $1</p>

<p>栈结构：
subl    $4, %esp</p>

<p><img src="/images/2.png" alt="结构"></p>

<p>movl    $1, (%esp)：</p>

<p><img src="/images/3.png" alt="结构"></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    call f
</code></pre></div>
<p>call f 是两步操作构成的
- 将 eip 的值入栈。
- 将 f所指向指令的地址放入 eip中</p>

<p>执行完之后，程序就会跳转到f: 指向的命令中执行：</p>

<p>栈结构：
<img src="/images/4.png" alt="结构"></p>

<p>f:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    pushl   %ebp
    movl    %esp, %ebp
</code></pre></div>
<p>前两条和main中相同</p>

<p>这时候栈结构我们可以发现。栈在逻辑上的划分：！！！函数调用栈</p>

<p>栈结构：main栈和f栈</p>

<p><img src="/images/5.png" alt="结构"></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    subl    $4, %esp
    movl    8(%ebp), %eax
    movl    %eax, (%esp)
</code></pre></div>
<p>关键是这三条指令 通过栈结构 
首先是分配一块空的空间 然后
我们可以发现ebp指向的是我们之前调用f中传入的参数 1 
所以eax = 1变成了</p>

<p>栈结构：</p>

<p><img src="/images/6.png" alt="结构"></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    call    g
</code></pre></div>
<p>栈结构：</p>

<p><img src="/images/7.png" alt="结构"></p>

<p>保存eip，并给eip赋值为g指令的地址，进行跳转</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    pushl   %ebp
    movl    %esp, %ebp
    movl    8(%ebp), %eax
    subl    $3, %eax
</code></pre></div>
<p>前两条指令同样是enter操作</p>

<p>栈结构：</p>

<p><img src="/images/8.png" alt="结构"></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    movl    8(%ebp), %eax
</code></pre></div>
<p>栈结构：</p>

<p><img src="/images/9.png" alt="结构"></p>

<p>通过栈结构知道 将参数放入eax中
然后 </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    subl    $3, %eax
</code></pre></div>
<p>将eax的值-3并放入eax中</p>

<p>栈结构：</p>

<p><img src="/images/10.png" alt="结构"></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    popl    %ebp
</code></pre></div>
<p>栈结构：</p>

<p><img src="/images/11.png" alt="结构"></p>

<p>可以看到esp指向的上一个函数调用栈的基址
popl恢复上一个函数调用栈的地址</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    ret
</code></pre></div>
<p>ret 和call相反 popl eip 将esp弹出并赋值给eip</p>

<p>栈结构：</p>

<p><img src="/images/12.png" alt="结构"></p>

<p>使得程序从上次调用的地方开始执行
即：
f:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    leave
    ret
</code></pre></div>
<p>leave 是和 enter 相反的过程
相当于</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    movl %ebp,%esp
    popl %ebp
</code></pre></div>
<p>栈结构：movl %ebp,%esp</p>

<p><img src="/images/13.png" alt="结构"></p>

<p>栈结构：popl %ebp</p>

<p><img src="/images/14.png" alt="结构"></p>

<p>ebp的值为上一个之前保存的上一个函数调用栈的栈底地址
最后 ret 回到 main</p>

<p>栈结构:</p>

<p><img src="/images/15.png" alt="结构"></p>

<p>main:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    addl    $2, %eax
    leave
    ret
</code></pre></div>
<p>栈结构:</p>

<p><img src="/images/16.png" alt="结构"></p>

<p>之前的计算我们可以发现都是把
结果放在eax里的</p>

<p>所以 可以发现 return的值就保存在这里</p>

<p>所以 直接 通过eax进行计算
最后恢复保存的栈底并退出</p>

<p>完成整个程序的执行过程</p>

<p>实验截图：</p>

<p><img src="/images/sy1.png" alt="结构"></p>

<p><img src="/images/sy2.png" alt="结构"></p>

<h3>四、总结</h3>

<p>冯诺依曼体系结构实际上就是按照线性的内存结构 执行程序的过程。
由于 结构是线性的，所以很容易找到数据所在的位置
比如：充分利用函数调用栈的机制，可以很容易找到上个函数传递过来的参数</p>

<p>除了内存意外，计算机在运行过程中，还需要关注体系结构中的寄存器。</p>

<p>不同的寄存器存放了不同的信息，记录数据和指令的位置。</p>

<blockquote>
<h3><a href="http://www.cnblogs.com/Quincy/archive/2012/03/27/2418835.html">有一个关于函数调用栈的细节</a></h3>

<p>就是为什么向下增长。因为觉得向上增长才是很自然地事情
查了一下大概有两个理由：
1. 这样的就不用给栈和堆划分明显的分界线
2. 由于堆是向上增长的，所以可以充分利用进程的内存空间</p>
</blockquote>

<p>等价指令：</p>

<p>call $xxx</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    push eip
    movl $xxx,eip
</code></pre></div>
<p>ret</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    popl eip
</code></pre></div>
<p>pushl $xxx</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    subl $4,%esp
    movl $xxx,%esp
</code></pre></div>
<p>enter</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">   push %ebp
   movl %esp,%ebp
</code></pre></div>
<p>leave</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    movl %ebp,%esp
    popl %ebp
</code></pre></div>
<hr>

<p>附：</p>

<ul>
<li><p><a href="http://m15934133625.blog.163.com/blog/static/246003087201526102220519/#">执行sed –e ‘/^\s*./d’ test<em>main.s &gt; test</em>main1.s此命令会删除掉以空格和点开头的行，方便阅读。</a></p></li>
<li><p><a href="http://itdreamerchen.com/%E7%90%86%E8%A7%A3c%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">objdump 反汇编</a></p></li>
</ul>

  </div>
</div>




      </div>

    <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="" data-title="Sip 桑 的 Blog~ ^。^" data-url=""></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"easyforgood"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->


    </div>

    <div id="footer">
      <div class="container">
        <p>&copy; 2015 siplexy
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </div>
    </div>

    


    <!-- Latest compiled and minified JavaScript, requires jQuery 1.x (2.x not supported in IE8) -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script src="/assets/themes/bootstrap-3/bootstrap/js/bootstrap.min.js"></script>
    <script src="/assets/themes/bootstrap-3/js/prettify.js"></script>
    <script src="/assets/themes/bootstrap-3/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </body>
</html>



