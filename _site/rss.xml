<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Sip 桑 的 Blog~ ^。^</title>
        <description>Sip 桑 的 Blog~ ^。^ - siplexy</description>
        <link>http://easyforgood.github.io</link>
        <link>http://easyforgood.github.io</link>
        <lastBuildDate>2015-08-03T21:43:22+08:00</lastBuildDate>
        <pubDate>2015-08-03T21:43:22+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>Linux内核分析作业1：</title>
                <description>&lt;h4&gt;朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000&lt;/h4&gt;

&lt;h3&gt;一、 现代计算机模型---冯诺依曼体系结构&lt;/h3&gt;

&lt;p&gt;冯诺依曼体系结构就是指存储程序计算机&lt;/p&gt;

&lt;p&gt;经典的存储程序计算机由以下五部分组成：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://baike.soso.com/p/20090709/20090709080850-1101162591.jpg&quot; alt=&quot;jiego&quot;&gt;&lt;/p&gt;

&lt;p&gt;(其中 实线代表 数据线 虚线代表 控制线)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;采用存储程序方式，指令和数据不加区别混合存储在同一个存储器中，（数据和程序在内存中是没有区别的,它们都是内存中的数据,当EIP指针指向哪 CPU就加载那段内存中的数据,如果是不正确的指令格式,CPU就会发生错误中断. 在现在CPU的保护模式中,每个内存段都其描述符,这个描述符记录着这个内存段的访问权限(可读,可写,可执行).这最就变相的指定了哪个些内存中存储的是指令哪些是数据）
指令和数据都可以送到运算器进行运算，即由指令组成的程序是可以修改的。&lt;/li&gt;
&lt;li&gt;存储器是按地址访问的线性编址的一维结构，每个单元的位数是固定的。&lt;/li&gt;
&lt;li&gt;指令由操作码和地址组成。操作码指明本指令的操作类型,地址码指明操作数和地址。操作数本身无数据类型的标志，它的数据类型由操作码确定。&lt;/li&gt;
&lt;li&gt;通过执行指令直接发出控制信号控制计算机的操作。指令在存储器中按其执行顺序存放，由指令计数器指明要执行的指令所在的单元地址。指令计数器只有一个，一般按顺序递增，但执行顺序可按运算结果或当时的外界条件而改变。&lt;/li&gt;
&lt;li&gt;以运算器为中心，I/O设备与存储器间的数据传送都要经过运算器。&lt;/li&gt;
&lt;li&gt;数据以二进制表示。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（上的现代微处理器体系结构这么课还提到了&lt;a href=&quot;http://www.cnblogs.com/li-hao/archive/2011/12/21/2296010.html&quot;&gt;哈佛结构&lt;/a&gt; 和冯诺依曼结构区别主要在于数据和指令分开存储）&lt;/p&gt;

&lt;h3&gt;二、 X86计算机结构&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2501972.html&quot;&gt;80X86寄存器详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/r2.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;h3&gt;三、实验代码汇编分析&lt;/h3&gt;

&lt;p&gt;C语言代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;int g(int x){
    return x-3;
}
int f(int x){
    return g(x);
}
int main(){
    return f(1)+2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过gcc进行编译后生成*.s汇编代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ gcc -S -o main.s main.c -m32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(注：-m32 代表以32bit为链接库编译 64bit操作系统需要安装&lt;a href=&quot;http://andycoder.me/fix-32bug-under-ubuntu1404/&quot;&gt;libc6:i386&lt;/a&gt; 32位库)&lt;/p&gt;

&lt;p&gt;得到汇编代码main.s:
(这里删除了.long .global .section &lt;a href=&quot;http://blog.csdn.net/jnu_simba/article/details/11747901&quot;&gt;节或汇编程序辅助信息&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;g:
    pushl    %ebp
    movl    %esp, %ebp
    movl    8(%ebp), %eax
    subl    $3, %eax
    popl    %ebp
    ret
f:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $4, %esp
    movl    8(%ebp), %eax
    movl    %eax, (%esp)
    call    g
    leave
    ret
main:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $4, %esp
    movl    $1, (%esp)
    call    f
    addl    $2, %eax
    leave
    ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;p&gt;以下是分析：&lt;/p&gt;

&lt;p&gt;main：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    pushl   %ebp
    movl    %esp, %ebp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两条指令可以放在一起看 相当于enter&lt;/p&gt;

&lt;p&gt;进入函数体都会最先执行这条enter指令&lt;/p&gt;

&lt;p&gt;作用是切换到保存上一个栈的栈底，并且将当前栈顶位置设置为栈底&lt;/p&gt;

&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/1.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    subl    $4, %esp
    movl    $1, (%esp)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两条指令也可以放在一起看&lt;/p&gt;

&lt;p&gt;在main函数中我们是f(1)+2 吗？这里有个 立即数1 
我们要如何使用这个参数呢？肯定需要把他放在内存中放在堆栈中&lt;/p&gt;

&lt;p&gt;所以这里 先是下移一个位置，指向一个空的区域，然后把 ‘1’ 放入这个空间中&lt;/p&gt;

&lt;p&gt;相当于 push $1&lt;/p&gt;

&lt;p&gt;栈结构：
subl    $4, %esp&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;movl    $1, (%esp)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/3.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    call f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;call f 是两步操作构成的
- 将 eip 的值入栈。
- 将 f所指向指令的地址放入 eip中&lt;/p&gt;

&lt;p&gt;执行完之后，程序就会跳转到f: 指向的命令中执行：&lt;/p&gt;

&lt;p&gt;栈结构：
&lt;img src=&quot;/images/4.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;f:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    pushl   %ebp
    movl    %esp, %ebp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前两条和main中相同&lt;/p&gt;

&lt;p&gt;这时候栈结构我们可以发现。栈在逻辑上的划分：！！！函数调用栈&lt;/p&gt;

&lt;p&gt;栈结构：main栈和f栈&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/5.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    subl    $4, %esp
    movl    8(%ebp), %eax
    movl    %eax, (%esp)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键是这三条指令 通过栈结构 
首先是分配一块空的空间 然后
我们可以发现ebp指向的是我们之前调用f中传入的参数 1 
所以eax = 1变成了&lt;/p&gt;

&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/6.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    call    g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/7.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;保存eip，并给eip赋值为g指令的地址，进行跳转&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    pushl   %ebp
    movl    %esp, %ebp
    movl    8(%ebp), %eax
    subl    $3, %eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前两条指令同样是enter操作&lt;/p&gt;

&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/8.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    movl    8(%ebp), %eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/9.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;通过栈结构知道 将参数放入eax中
然后 &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    subl    $3, %eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将eax的值-3并放入eax中&lt;/p&gt;

&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/10.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    popl    %ebp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/11.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;可以看到esp指向的上一个函数调用栈的基址
popl恢复上一个函数调用栈的地址&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ret 和call相反 popl eip 将esp弹出并赋值给eip&lt;/p&gt;

&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/12.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;使得程序从上次调用的地方开始执行
即：
f:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    leave
    ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;leave 是和 enter 相反的过程
相当于&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    movl %ebp,%esp
    popl %ebp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;栈结构：movl %ebp,%esp&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/13.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;栈结构：popl %ebp&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/14.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;ebp的值为上一个之前保存的上一个函数调用栈的栈底地址
最后 ret 回到 main&lt;/p&gt;

&lt;p&gt;栈结构:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/15.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;main:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    addl    $2, %eax
    leave
    ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;栈结构:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/16.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;之前的计算我们可以发现都是把
结果放在eax里的&lt;/p&gt;

&lt;p&gt;所以 可以发现 return的值就保存在这里&lt;/p&gt;

&lt;p&gt;所以 直接 通过eax进行计算
最后恢复保存的栈底并退出&lt;/p&gt;

&lt;p&gt;完成整个程序的执行过程&lt;/p&gt;

&lt;p&gt;实验截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sy1.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sy2.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;h3&gt;四、总结&lt;/h3&gt;

&lt;p&gt;冯诺依曼体系结构实际上就是按照线性的内存结构 执行程序的过程。
由于 结构是线性的，所以很容易找到数据所在的位置
比如：充分利用函数调用栈的机制，可以很容易找到上个函数传递过来的参数&lt;/p&gt;

&lt;p&gt;除了内存意外，计算机在运行过程中，还需要关注体系结构中的寄存器。&lt;/p&gt;

&lt;p&gt;不同的寄存器存放了不同的信息，记录数据和指令的位置。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/Quincy/archive/2012/03/27/2418835.html&quot;&gt;有一个关于函数调用栈的细节&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;就是为什么向下增长。因为觉得向上增长才是很自然地事情
查了一下大概有两个理由：
1. 这样的就不用给栈和堆划分明显的分界线
2. 由于堆是向上增长的，所以可以充分利用进程的内存空间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;等价指令：&lt;/p&gt;

&lt;p&gt;call $xxx&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    push eip
    movl $xxx,eip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ret&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    popl eip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pushl $xxx&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    subl $4,%esp
    movl $xxx,%esp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;enter&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;   push %ebp
   movl %esp,%ebp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;leave&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    movl %ebp,%esp
    popl %ebp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;p&gt;附：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://m15934133625.blog.163.com/blog/static/246003087201526102220519/#&quot;&gt;执行sed –e ‘/^\s*./d’ test&lt;em&gt;main.s &amp;gt; test&lt;/em&gt;main1.s此命令会删除掉以空格和点开头的行，方便阅读。&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://itdreamerchen.com/%E7%90%86%E8%A7%A3c%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/&quot;&gt;objdump 反汇编&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://easyforgood.github.io/2015/04/20/Linux</link>
                <guid>http://easyforgood.github.io/2015/04/20/Linux</guid>
                <pubDate>2015-04-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Linux内核分析作业1：</title>
                <description>&lt;h4&gt;朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000&lt;/h4&gt;

&lt;h3&gt;一、 现代计算机模型---冯诺依曼体系结构&lt;/h3&gt;

&lt;p&gt;冯诺依曼体系结构就是指存储程序计算机&lt;/p&gt;

&lt;p&gt;经典的存储程序计算机由以下五部分组成：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://baike.soso.com/p/20090709/20090709080850-1101162591.jpg&quot; alt=&quot;jiego&quot;&gt;&lt;/p&gt;

&lt;p&gt;(其中 实线代表 数据线 虚线代表 控制线)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;采用存储程序方式，指令和数据不加区别混合存储在同一个存储器中，（数据和程序在内存中是没有区别的,它们都是内存中的数据,当EIP指针指向哪 CPU就加载那段内存中的数据,如果是不正确的指令格式,CPU就会发生错误中断. 在现在CPU的保护模式中,每个内存段都其描述符,这个描述符记录着这个内存段的访问权限(可读,可写,可执行).这最就变相的指定了哪个些内存中存储的是指令哪些是数据）
指令和数据都可以送到运算器进行运算，即由指令组成的程序是可以修改的。&lt;/li&gt;
&lt;li&gt;存储器是按地址访问的线性编址的一维结构，每个单元的位数是固定的。&lt;/li&gt;
&lt;li&gt;指令由操作码和地址组成。操作码指明本指令的操作类型,地址码指明操作数和地址。操作数本身无数据类型的标志，它的数据类型由操作码确定。&lt;/li&gt;
&lt;li&gt;通过执行指令直接发出控制信号控制计算机的操作。指令在存储器中按其执行顺序存放，由指令计数器指明要执行的指令所在的单元地址。指令计数器只有一个，一般按顺序递增，但执行顺序可按运算结果或当时的外界条件而改变。&lt;/li&gt;
&lt;li&gt;以运算器为中心，I/O设备与存储器间的数据传送都要经过运算器。&lt;/li&gt;
&lt;li&gt;数据以二进制表示。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（上的现代微处理器体系结构这么课还提到了&lt;a href=&quot;http://www.cnblogs.com/li-hao/archive/2011/12/21/2296010.html&quot;&gt;哈佛结构&lt;/a&gt; 和冯诺依曼结构区别主要在于数据和指令分开存储）&lt;/p&gt;

&lt;h3&gt;二、 X86计算机结构&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2501972.html&quot;&gt;80X86寄存器详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/r2.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;h3&gt;三、实验代码汇编分析&lt;/h3&gt;

&lt;p&gt;C语言代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;int g(int x){
    return x-3;
}
int f(int x){
    return g(x);
}
int main(){
    return f(1)+2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过gcc进行编译后生成*.s汇编代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ gcc -S -o main.s main.c -m32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(注：-m32 代表以32bit为链接库编译 64bit操作系统需要安装&lt;a href=&quot;http://andycoder.me/fix-32bug-under-ubuntu1404/&quot;&gt;libc6:i386&lt;/a&gt; 32位库)&lt;/p&gt;

&lt;p&gt;得到汇编代码main.s:
(这里删除了.long .global .section &lt;a href=&quot;http://blog.csdn.net/jnu_simba/article/details/11747901&quot;&gt;节或汇编程序辅助信息&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;g:
    pushl    %ebp
    movl    %esp, %ebp
    movl    8(%ebp), %eax
    subl    $3, %eax
    popl    %ebp
    ret
f:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $4, %esp
    movl    8(%ebp), %eax
    movl    %eax, (%esp)
    call    g
    leave
    ret
main:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $4, %esp
    movl    $1, (%esp)
    call    f
    addl    $2, %eax
    leave
    ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;p&gt;以下是分析：&lt;/p&gt;

&lt;p&gt;main：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    pushl   %ebp
    movl    %esp, %ebp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两条指令可以放在一起看 相当于enter&lt;/p&gt;

&lt;p&gt;进入函数体都会最先执行这条enter指令&lt;/p&gt;

&lt;p&gt;作用是切换到保存上一个栈的栈底，并且将当前栈顶位置设置为栈底&lt;/p&gt;

&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/1.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    subl    $4, %esp
    movl    $1, (%esp)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两条指令也可以放在一起看&lt;/p&gt;

&lt;p&gt;在main函数中我们是f(1)+2 吗？这里有个 立即数1 
我们要如何使用这个参数呢？肯定需要把他放在内存中放在堆栈中&lt;/p&gt;

&lt;p&gt;所以这里 先是下移一个位置，指向一个空的区域，然后把 ‘1’ 放入这个空间中&lt;/p&gt;

&lt;p&gt;相当于 push $1&lt;/p&gt;

&lt;p&gt;栈结构：
subl    $4, %esp&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;movl    $1, (%esp)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/3.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    call f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;call f 是两步操作构成的
- 将 eip 的值入栈。
- 将 f所指向指令的地址放入 eip中&lt;/p&gt;

&lt;p&gt;执行完之后，程序就会跳转到f: 指向的命令中执行：&lt;/p&gt;

&lt;p&gt;栈结构：
&lt;img src=&quot;/images/4.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;f:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    pushl   %ebp
    movl    %esp, %ebp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前两条和main中相同&lt;/p&gt;

&lt;p&gt;这时候栈结构我们可以发现。栈在逻辑上的划分：！！！函数调用栈&lt;/p&gt;

&lt;p&gt;栈结构：main栈和f栈&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/5.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    subl    $4, %esp
    movl    8(%ebp), %eax
    movl    %eax, (%esp)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键是这三条指令 通过栈结构 
首先是分配一块空的空间 然后
我们可以发现ebp指向的是我们之前调用f中传入的参数 1 
所以eax = 1变成了&lt;/p&gt;

&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/6.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    call    g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/7.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;保存eip，并给eip赋值为g指令的地址，进行跳转&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    pushl   %ebp
    movl    %esp, %ebp
    movl    8(%ebp), %eax
    subl    $3, %eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前两条指令同样是enter操作&lt;/p&gt;

&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/8.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    movl    8(%ebp), %eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/9.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;通过栈结构知道 将参数放入eax中
然后 &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    subl    $3, %eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将eax的值-3并放入eax中&lt;/p&gt;

&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/10.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    popl    %ebp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/11.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;可以看到esp指向的上一个函数调用栈的基址
popl恢复上一个函数调用栈的地址&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ret 和call相反 popl eip 将esp弹出并赋值给eip&lt;/p&gt;

&lt;p&gt;栈结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/12.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;使得程序从上次调用的地方开始执行
即：
f:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    leave
    ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;leave 是和 enter 相反的过程
相当于&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    movl %ebp,%esp
    popl %ebp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;栈结构：movl %ebp,%esp&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/13.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;栈结构：popl %ebp&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/14.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;ebp的值为上一个之前保存的上一个函数调用栈的栈底地址
最后 ret 回到 main&lt;/p&gt;

&lt;p&gt;栈结构:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/15.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;main:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    addl    $2, %eax
    leave
    ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;栈结构:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/16.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;之前的计算我们可以发现都是把
结果放在eax里的&lt;/p&gt;

&lt;p&gt;所以 可以发现 return的值就保存在这里&lt;/p&gt;

&lt;p&gt;所以 直接 通过eax进行计算
最后恢复保存的栈底并退出&lt;/p&gt;

&lt;p&gt;完成整个程序的执行过程&lt;/p&gt;

&lt;p&gt;实验截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sy1.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sy2.png&quot; alt=&quot;结构&quot;&gt;&lt;/p&gt;

&lt;h3&gt;四、总结&lt;/h3&gt;

&lt;p&gt;冯诺依曼体系结构实际上就是按照线性的内存结构 执行程序的过程。
由于 结构是线性的，所以很容易找到数据所在的位置
比如：充分利用函数调用栈的机制，可以很容易找到上个函数传递过来的参数&lt;/p&gt;

&lt;p&gt;除了内存意外，计算机在运行过程中，还需要关注体系结构中的寄存器。&lt;/p&gt;

&lt;p&gt;不同的寄存器存放了不同的信息，记录数据和指令的位置。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/Quincy/archive/2012/03/27/2418835.html&quot;&gt;有一个关于函数调用栈的细节&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;就是为什么向下增长。因为觉得向上增长才是很自然地事情
查了一下大概有两个理由：
1. 这样的就不用给栈和堆划分明显的分界线
2. 由于堆是向上增长的，所以可以充分利用进程的内存空间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;等价指令：&lt;/p&gt;

&lt;p&gt;call $xxx&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    push eip
    movl $xxx,eip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ret&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    popl eip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pushl $xxx&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    subl $4,%esp
    movl $xxx,%esp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;enter&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;   push %ebp
   movl %esp,%ebp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;leave&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    movl %ebp,%esp
    popl %ebp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;p&gt;附：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://m15934133625.blog.163.com/blog/static/246003087201526102220519/#&quot;&gt;执行sed –e ‘/^\s*./d’ test&lt;em&gt;main.s &amp;gt; test&lt;/em&gt;main1.s此命令会删除掉以空格和点开头的行，方便阅读。&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://itdreamerchen.com/%E7%90%86%E8%A7%A3c%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/&quot;&gt;objdump 反汇编&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://easyforgood.github.io/2015/04/20/Linux</link>
                <guid>http://easyforgood.github.io/2015/04/20/Linux</guid>
                <pubDate>2015-04-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Nodejs event</title>
                <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;javascript 面向对象的使用方法&lt;/p&gt;

&lt;p&gt;https://cnodejs.org/topic/4f16442ccae1f4aa2700113f&lt;/p&gt;

&lt;p&gt;http://www.ruanyifeng.com/blog/2010/05/object-oriented&lt;em&gt;javascript&lt;/em&gt;encapsulation.html&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// &lt;strong&gt;&lt;strong&gt;proto&lt;/strong&gt;的使用&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Nodejs 事件机制&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://biyeah.iteye.com/blog/1308954&quot;&gt;Nodejs中的EventEmitter&lt;/a&gt; //如何继承事件&lt;/p&gt;

&lt;p&gt;http://developer.51cto.com/art/201109/290268.htm *&lt;em&gt;这里提到了j的 this！ *&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;http://javascript.ruanyifeng.com/nodejs/events.html#
&lt;strong&gt;events模块介绍 once on 主要是包含了很多其他模块的使用介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;http://www.html-js.com/article/1649  关于event网站的译文&lt;/p&gt;

&lt;p&gt;//写一个小工具  辅助生成 markdown语法下链接的东东&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://developer.51cto.com/art/201109/290281.htm&quot;&gt;浅析Node.js中的流程控制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.html-js.com/article/My-Code-Wars-my-code-war-time-outside-please-lock-the-door--socketio-nested-monitor&quot;&gt;番外：关门请上锁——“socket.io”嵌套监听&lt;/a&gt;
socket.io 解决异步编程的问题 类似promises thenjs&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/10/event_loop.html&quot;&gt;什么是 Event Loop？&lt;/a&gt;nodejs 事件循环机制&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nodejs使用技巧&lt;/p&gt;

&lt;p&gt;http://dev.oupeng.com/articles/7-tips-for-a-nodejs-padawan
主要是！  promise解决回调陷阱  不要忘了return  以及调试方法介绍&lt;/p&gt;

&lt;p&gt;http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html 异步编程的方法&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://easyforgood.github.io/2015/02/04/nodejs%20event</link>
                <guid>http://easyforgood.github.io/2015/02/04/nodejs event</guid>
                <pubDate>2015-02-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Jekyll Introduction</title>
                <description>&lt;p&gt;This Jekyll introduction will outline specifically  what Jekyll is and why you would want to use it.
Directly following the intro we&amp;#39;ll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2&gt;Overview&lt;/h2&gt;

&lt;h3&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from
dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as &amp;quot;a simple, blog aware, static site generator&amp;quot;.&lt;/p&gt;

&lt;h3&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system.
Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory
is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files,
compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder.
The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags
on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements.
This is a common source of confusion when getting started.
Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient.
The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server.
Traditional dynamic blogs like Wordpress require a database and server-side code.
Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;
&lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;
&lt;li&gt;No internet connection required.&lt;/li&gt;
&lt;li&gt;Ability to publish via git.&lt;/li&gt;
&lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;
&lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;
&lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples.
This information is not intended to specifically teach you how to do anything, rather it
is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately
help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href=&quot;/index.html#start-now&quot;&gt;installing jekyll&lt;/a&gt; you&amp;#39;ll need to format your website directory in a way jekyll expects.
Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 2011-10-25-open-source-is-good.markdown
|   |-- 2011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;
Stores configuration data.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;
This folder is for partial views.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt;
This folder is for the main templates your content will be inserted into.
You can have different layouts for different pages or page sections.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;
This folder contains your dynamic content/posts.
the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;
This is where the generated site will be placed once Jekyll is done transforming it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;
This folder is not part of the standard jekyll structure.
The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory.
Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(read more: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Usage&quot;&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here:
(&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Configuration&quot;&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;)&lt;/p&gt;

&lt;h2&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page.
These content &amp;quot;objects&amp;quot; get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax.
Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt;
Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;
A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory.
If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file.
Additionally, each file must have &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt; prepended to its content.
YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;
Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy.
Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt;
Posts can have tags associated with them as part of their meta-data.
Tags may be placed on posts by providing them in the post&amp;#39;s YAML front matter.
You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt;
Posts may be categorized by providing one or more categories in the YAML front matter.
Categories offer more significance over tags in that they can be reflected in the URL path to the given post.
Note categories in Jekyll work in a specific way.
If you define more than one category you are defining a category hierarchy &amp;quot;set&amp;quot;.
Example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;---
title :  Hello World
categories : [lessons, beginner]
---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This defines the category hierarchy &amp;quot;lessons/beginner&amp;quot;. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll.
You won&amp;#39;t find &amp;quot;lessons&amp;quot; and &amp;quot;beginner&amp;quot; as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;
Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;
In order to register as a Jekyll page the file must contain &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt;.
Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;
Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;
If pages are defined in sub-directories, the path to the page will be reflected in the url.
Example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;.
|-- people
    |-- bob
        |-- essay.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;
You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;
Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;
Generating a sitemap is good practice for SEO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;
A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page&amp;#39;s or post&amp;#39;s content.
All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;.
The site variable holds all accessible content and metadata relative to the site.
The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;
Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;
Templates should be coded in HTML and contain YAML Front Matter.
All templates can contain Liquid code to work with your site&amp;#39;s data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;
There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;.
The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined.
Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code&gt;...
&amp;lt;body&amp;gt;
  &amp;lt;div id=&amp;quot;sidebar&amp;quot;&amp;gt; ... &amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
    &amp;#123;{content}&amp;#125;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they
define another &amp;quot;root&amp;quot; layout/template within their YAML Front Matter.
This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3&gt;Includes&lt;/h3&gt;

&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder.
Includes are NOT templates, rather they are just code snippets that get included into templates.
In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll.
This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href=&quot;http://shopify.com&quot;&gt;Shopify&lt;/a&gt;.
Liquid is designed for end-users to be able to execute logic within template files
without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with
your site and post/page data.&lt;/p&gt;

&lt;h3&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;.
GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code.
The point being you can&amp;#39;t do jackshit in liquid that hasn&amp;#39;t been allowed explicitly by the implementation.
What&amp;#39;s more you can only access data-structures that have been explicitly passed to the template.&lt;/p&gt;

&lt;p&gt;In Jekyll&amp;#39;s case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins.
Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to
suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;
My personal stance is to not invest time trying to hack liquid. It&amp;#39;s really unnecessary
&lt;em&gt;from a programmer&amp;#39;s&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code)
you are better off sticking with ruby. Toward that end I&amp;#39;ve built &lt;a href=&quot;http://github.com/plusjade/mustache-with-jekyll&quot;&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages.
That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files.&lt;/p&gt;

&lt;h2&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt;
This is done with textile or markdown.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt;
This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;
All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt;
These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax.
Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt;
Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through
Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We&amp;#39;ve outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;.
Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty.
This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block.
The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into.
If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt;
That is to say loading a post file into a template file that refers to another template file with work in the way you&amp;#39;d expect; as a nested sub-template.&lt;/p&gt;

&lt;h2&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll&amp;#39;s job is to generate a static representation of your website.
The following is an outline of how that&amp;#39;s done:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt;
Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt;
Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one
big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata.
At this stage your site is one big computed ruby object.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;
Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s).
Once the post is parsed and liquified inside the the proper layout structure, the layout itself is &amp;quot;liquified&amp;quot;.
&lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler
hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt;
Finally the liquid templates are &amp;quot;rendered&amp;quot;, thereby processing any liquid syntax provided in the templates
and saving the final, static representation of the file.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;
Because Jekyll computes the entire site in one fell swoop, each template is given access to
a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you&amp;#39;ll iterate through and format
using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;
&lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap.
You can also read the original documentation here: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Template-Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does.
As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at &lt;a href=&quot;&quot;&gt;&lt;/a&gt;
or jump right into &lt;a href=&quot;&quot;&gt;Usage&lt;/a&gt; if you&amp;#39;d like.&lt;/p&gt;
</description>
                <link>http://easyforgood.github.io/lessons/2011/12/29/jekyll-introduction</link>
                <guid>http://easyforgood.github.io/lessons/2011/12/29/jekyll-introduction</guid>
                <pubDate>2011-12-29T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
