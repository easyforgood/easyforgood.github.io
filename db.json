{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/pacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/author.jpg","path":"img/author.jpg","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/pacman.jpg","path":"img/pacman.jpg","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/author.png","path":"img/author.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/pic.png","path":"img/pic.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/pacman/source/js/jquery-2.1.0.min.js","path":"js/jquery-2.1.0.min.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/pacman/.git","hash":"5e941ce976b75c8dcdf6f5915ab99b44294b0e31","modified":1458575986000},{"_id":"themes/pacman/LICENSE","hash":"0138565d68df6e5536667ad445232981ea808aec","modified":1458575986000},{"_id":"themes/pacman/README.md","hash":"d7efa5614e13f8fc7db5e9030e4cc2b27c2df171","modified":1458575986000},{"_id":"themes/pacman/_config.yml","hash":"7645bd6ee93e6ad387742d7b75b7df5abf0ed9c3","modified":1458575986000},{"_id":"source/_posts/Linux.m","hash":"eb324e8576f1db5acf4744145f37af4d89c1b2ca","modified":1459443142000},{"_id":"source/_posts/Linux.md","hash":"eb324e8576f1db5acf4744145f37af4d89c1b2ca","modified":1459443142000},{"_id":"source/_posts/Linux_1.md","hash":"4629aeda23bd6a9fbd67bf493a1b6ff21eed6a30","modified":1459443174000},{"_id":"source/_posts/Linux_2.md","hash":"b8bb7625ab4ba67b4957fce4ac549a15ceaf3369","modified":1459443142000},{"_id":"source/_posts/Linux_3.md","hash":"6d3bf61086c02e583b8897ed027b75000e5949a3","modified":1459443691000},{"_id":"source/_posts/Linux_3.md~","hash":"c16e673e70655924fbc19318d596bccf212874dc","modified":1459443142000},{"_id":"source/_posts/Linux_45.md","hash":"50824fa88fe24865e8e34b9aaccc34596c7f88a9","modified":1459443831000},{"_id":"source/_posts/Linux_45.md~","hash":"c18eb8d9d9414803361a1070881003087bbdfa9e","modified":1459443142000},{"_id":"source/_posts/Linux_6.md","hash":"ad3d519b56592d976fac940c63cdfb353b607df3","modified":1459443764000},{"_id":"source/_posts/Linux_6.md~","hash":"edfaf11d6843142d97fe6358506c5ac3b74c303e","modified":1459443752000},{"_id":"source/_posts/Linux_7.md","hash":"39435f426fe78c31470853c4ecc345fc1e47458b","modified":1459443746000},{"_id":"source/_posts/Linux_8.md","hash":"1cc58b93d432909349f9e4abc7f44416fcb7e51c","modified":1459443782000},{"_id":"source/_posts/Linux_7.md~","hash":"aec2241438928144f69b19b4fb9e5ea37e4caf81","modified":1459443142000},{"_id":"source/_posts/Linux_8.md~","hash":"963f8eb5fd98ed91d428431da6ae77ed5b36ca2a","modified":1459443142000},{"_id":"source/_posts/pic-2015-03-28.md","hash":"fcb81cee4ef18d55f1f4db8da98b8b37c13c472d","modified":1459690050000},{"_id":"source/_posts/Linux_Read.md","hash":"83464352eabf4f38b691d8ee8ca74850410c7840","modified":1459443142000},{"_id":"source/_posts/junit5的相关说明.md","hash":"c870077ff710be5dbb379b353c54fb3379207971","modified":1459443142000},{"_id":"source/_posts/pic-2016-04-01.md","hash":"bd6a92b8fb81835830dfa34a2b8b0ff7483d884d","modified":1459689993000},{"_id":"source/_posts/python-处理博客的md文件.md","hash":"68f8317a3f3d345d6d2bd7d6851fe6ce2a29401e","modified":1459689625000},{"_id":"source/_posts/pic-20150325.md","hash":"87ae2a0b8c87b21fd14000df7e7a47f95c49a39e","modified":1459443142000},{"_id":"source/_posts/python-处理博客的md文件.md~","hash":"1cb1f8d581ab8d77e9735f9a7f5ea7a10ece8cb7","modified":1459444116000},{"_id":"source/_posts/pic-2016-03-22.md","hash":"5820306e0e403983312af61ba8564c038a0513f6","modified":1459443142000},{"_id":"source/_posts/通信协议的调研.md","hash":"fb01cf2818e8a036bd8ab382729422ac23999439","modified":1459443142000},{"_id":"source/_posts/test.py","hash":"7ece7d1cbf846f2c0e85d2f308dd51a18fdfd6bd","modified":1459443142000},{"_id":"source/_posts/text.txt","hash":"372ad82c465d8e151227e411df486dec84d40796","modified":1459443142000},{"_id":"source/_posts/画稿-2016-03-21.md","hash":"fdce09e10c99ad128051b37c01be4409b8743430","modified":1459443142000},{"_id":"themes/pacman/languages/default.yml","hash":"7e9594aa9551cd4841905b4b4d4fcabc2b40e447","modified":1458575986000},{"_id":"themes/pacman/languages/zh-CN.yml","hash":"991b90926686c0d10731a8f4ea61b96c3f087531","modified":1458575986000},{"_id":"themes/pacman/languages/zh-TW.yml","hash":"48b652fa2eb73f9f7cd512472d0cb20057152aea","modified":1458575986000},{"_id":"themes/pacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1458575986000},{"_id":"themes/pacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1458575986000},{"_id":"themes/pacman/layout/index.ejs","hash":"774f7e89d05e9a9b43970a873d5100ad5c9d21ba","modified":1458575986000},{"_id":"themes/pacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1458575986000},{"_id":"themes/pacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1458575986000},{"_id":"themes/pacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1458575986000},{"_id":"themes/pacman/layout/layout.ejs","hash":"87b543229bec7e77cc0ec68cfdd11f2f33df4a1b","modified":1458575986000},{"_id":"themes/pacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/after_footer.ejs","hash":"af5d700c7e22e364216535142bc0adc798fac22f","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/archive.ejs","hash":"a1ada891cbacf49b397cfa7dd921bdd0ae545a4e","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/article.ejs","hash":"38837fc6a1a799e83b8a75db642b0daf1ff81828","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/head.ejs","hash":"f21fc1b1c16498610a44a552d23059d338f34d2a","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/header.ejs","hash":"515074e0e1449259cfb668217b21224f6e0adde5","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/google_analytics.ejs","hash":"b6871f67c87c87acb5295ce4fb673b16a7296a01","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/footer.ejs","hash":"ecb03b462d938af45bfa5d4aa656cbeb5225f940","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/search.ejs","hash":"aed90406246cc43f60dda8cd6558e9eccee342a4","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/sidebar.ejs","hash":"b5aeaab660a18b7a4da568f015e61260eb478916","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1458575986000},{"_id":"themes/pacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1458575986000},{"_id":"themes/pacman/layout/_widget/category.ejs","hash":"9b4cc6be18aa6c5da4cf45913d5be83fc33081db","modified":1458575986000},{"_id":"themes/pacman/layout/_widget/links.ejs","hash":"3635a1a407fde93a3be58178b85f51ceb8b87f15","modified":1458575986000},{"_id":"themes/pacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1458575986000},{"_id":"themes/pacman/layout/_widget/tag.ejs","hash":"cc97db230f727c27519298166ad904358811fb53","modified":1458575986000},{"_id":"themes/pacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1458575986000},{"_id":"themes/pacman/source/css/style.styl","hash":"b096cc43460e68004bbef41229f67420b5816637","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1458575986000},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1458575986000},{"_id":"themes/pacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1458575986000},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1458575986000},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1458575986000},{"_id":"themes/pacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1458575986000},{"_id":"themes/pacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1458575986000},{"_id":"themes/pacman/source/img/author.jpg","hash":"40022cd45e4061a38a7aa703209feb2e7be112a4","modified":1458654384000},{"_id":"themes/pacman/source/img/favicon.ico","hash":"fa2c03e9eb35f2f423a1c85c85c278649a857532","modified":1458575986000},{"_id":"themes/pacman/source/img/logo.svg","hash":"cef3f0bb4bf3661dd3a58c81b9a7be79601a0bfb","modified":1458575986000},{"_id":"themes/pacman/source/img/pacman.jpg","hash":"7e873f2f40a52f8c679302b88bb0809a6abafe5c","modified":1458575986000},{"_id":"themes/pacman/source/img/author.png","hash":"40022cd45e4061a38a7aa703209feb2e7be112a4","modified":1458653361000},{"_id":"themes/pacman/source/img/pic.png","hash":"40022cd45e4061a38a7aa703209feb2e7be112a4","modified":1458654418000},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1458575986000},{"_id":"themes/pacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1458575986000},{"_id":"themes/pacman/source/js/jquery-2.1.0.min.js","hash":"98884258cbdb0d939fa2c5e74fc7ac9e56d8170f","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/post/article.ejs","hash":"ec5e8f66886dedf35b9a5746d11fe0dc4a7ab68f","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/post/catetags.ejs","hash":"f6b107078094333b6567d4a97700f559159675e1","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/post/comment.ejs","hash":"5c0afcd1fd1d7b4e8335f76bc181b8e72ffed38e","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/post/footer.ejs","hash":"a9aeae612eb7085bbe74bd12086198320e6c3702","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/post/gallery.ejs","hash":"7ca5b1db9439be61a8b77f6f7d857b56fdf1517f","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/post/header.ejs","hash":"73aa8a410cc80277930acaec23003c30eeac6d79","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/post/jiathis.ejs","hash":"adc047d2bbd031092df86f3be2866ea9c3b5f3c9","modified":1458575986000},{"_id":"themes/pacman/layout/_partial/post/pagination.ejs","hash":"dd9563aaa7094c7082a16e6c9cbc24b33aaef87c","modified":1458575986000},{"_id":"themes/pacman/source/css/_base/code.styl","hash":"330209ebaebe69308e131fada85b9b619c85fbd9","modified":1458575986000},{"_id":"themes/pacman/source/css/_base/font.styl","hash":"75f264bc742888dbe192e8d19eda70705d13c709","modified":1458575986000},{"_id":"themes/pacman/source/css/_base/public.styl","hash":"29deec49b60533cc4196175345eaa4b2d611a97e","modified":1458575986000},{"_id":"themes/pacman/source/css/_base/variable.styl","hash":"3640eedfb72d2bc5a5d75be5b0c9c7954f39229d","modified":1458575986000},{"_id":"themes/pacman/source/css/_partial/article.styl","hash":"82d7621920e221b7e52dfdb74cbcec718d0cc666","modified":1458575986000},{"_id":"themes/pacman/source/css/_partial/footer.styl","hash":"77c2e6251cea1f3970646f6fbe5d557ed4f98586","modified":1458575986000},{"_id":"themes/pacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1458575986000},{"_id":"themes/pacman/source/css/_partial/gallery.styl","hash":"a544a58fdb4c8dd8274159323abd1e38cb03215e","modified":1458575986000},{"_id":"themes/pacman/source/css/_partial/aside.styl","hash":"8fb8c2172883913b404f8e49e181103317486ecc","modified":1458575986000},{"_id":"themes/pacman/source/css/_partial/helper.styl","hash":"52d4ee51b7087c2c2a7e7ded6f63270165d9de89","modified":1458575986000},{"_id":"themes/pacman/source/css/_partial/header.styl","hash":"d27d0057b86dc61a1ab8a9037ee43dfcc43766b3","modified":1458575986000},{"_id":"themes/pacman/source/css/_partial/index.styl","hash":"0d219fc6fb76c0d4ffd1dc2a119969d78a157285","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1458575986000},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1458575986000},{"_id":"themes/pacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1458575986000},{"_id":"public/2016/04/03/pic-2016-04-01/index.html","hash":"973be6e766ca68f6880a8025de6fb6eb04f4465c","modified":1459690058478},{"_id":"public/2016/04/01/python-处理博客的md文件/index.html","hash":"3e29340320e15f5e542cceef7f58e7f9e8e9a7c7","modified":1459690058507},{"_id":"public/2016/03/31/Linux_45/index.html","hash":"eaa91bfb4c7a6e1c5e9ff000a85adfccfc888e9e","modified":1459690058521},{"_id":"public/2016/03/31/Linux_8/index.html","hash":"27d65fadd05a40e5b0a05f0d1e8a88c67ad1fdc9","modified":1459690058531},{"_id":"public/2016/03/31/Linux_6/index.html","hash":"8651b7c064402a52938c3425d76b6881b94557df","modified":1459690058545},{"_id":"public/2016/03/31/Linux_2/index.html","hash":"e7e729697f55daae3815112a09a7b42c5671ee36","modified":1459690058569},{"_id":"public/2016/03/31/Linux_1/index.html","hash":"efddabb0944aa93fe475a9785c17aade7415ff3c","modified":1459690058585},{"_id":"public/2016/03/31/Linux_7/index.html","hash":"a6bdfaab6bd7a4b40fd9de9ead462b4f674470f5","modified":1459690058599},{"_id":"public/2016/03/31/Linux_Read/index.html","hash":"06538a9966da7f17b762982f964882ea5886b736","modified":1459690058612},{"_id":"public/2016/03/31/junit5的相关说明/index.html","hash":"1945463c1e48a6f99a14e105f96ca0a556fc30b1","modified":1459690058625},{"_id":"public/2016/03/31/Linux/index.html","hash":"9d789a10fa6a0e39cce5021928550420efa7385f","modified":1459690058636},{"_id":"public/2016/03/31/Linux_3/index.html","hash":"321fed76d2582c9619fe64656a33464868ba8a92","modified":1459690058660},{"_id":"public/2016/03/31/通信协议的调研/index.html","hash":"eba0aa144054ae0c39518148ab6ab6992408904a","modified":1459690058672},{"_id":"public/2016/03/28/pic-2015-03-28/index.html","hash":"d1e530e3b57eadf69fb90e53a9e0bb3c1a39d6d3","modified":1459690058685},{"_id":"public/archives/index.html","hash":"6975670f943e378f82af4d4f11d513a32d6e772e","modified":1459690058712},{"_id":"public/2016/03/28/pic-20150325/index.html","hash":"61933e16eea6184625476550efa1a7845900b845","modified":1459690058724},{"_id":"public/2016/03/22/pic-2016-03-22/index.html","hash":"417718f25b117eaea49ef0bc2728f1d78b1f3280","modified":1459690058736},{"_id":"public/2016/03/22/画稿-2016-03-21/index.html","hash":"a80f917b1f2e5118cbd72d0995c63846f46c1d2d","modified":1459690058747},{"_id":"public/archives/2016/index.html","hash":"3f4fe9d5ed5bff6e07b5f88a3ed8bce0ad38c70c","modified":1459690058771},{"_id":"public/archives/page/2/index.html","hash":"72dfd6996584a19e91dda7f7ad56aa788bdad378","modified":1459690058787},{"_id":"public/archives/2016/03/index.html","hash":"97857a2c6d58835345f77b910a16d0f3f6726041","modified":1459690058807},{"_id":"public/index.html","hash":"b2d4672de965358740cdbf3eed7c68eea9d7eb53","modified":1459690058829},{"_id":"public/archives/2016/page/2/index.html","hash":"5ec90e7cf19a94ec1d64b1d35234be487c70cd80","modified":1459690058857},{"_id":"public/archives/2016/04/index.html","hash":"086f74e119d2923a7f8d6c2e52a2220108c9f2e5","modified":1459690058868},{"_id":"public/page/2/index.html","hash":"0eb2471a3f1143c3b8b482a2bc949874dbcc7d69","modified":1459690058877},{"_id":"public/categories/手绘/index.html","hash":"cacc0c5f5af7a35196497a4e67846e28111eb259","modified":1459690058882},{"_id":"public/categories/linux内核分析/index.html","hash":"6c2abe7957dd95ff2fa18072adab69d1e299aded","modified":1459690058887},{"_id":"public/archives/2016/03/page/2/index.html","hash":"14a9121c422ccf86f607f25bc1a9a34d00a026be","modified":1459690058899},{"_id":"public/tags/linux/index.html","hash":"4632c59534a65545b9baa8217595ac19b5518299","modified":1459690058904},{"_id":"public/tags/linux内核/index.html","hash":"774ccc96994fe7a43b5d2e1b564cd69ba1d684c3","modified":1459690058907},{"_id":"public/tags/手绘/index.html","hash":"756ff3aca5d7f35dd967dafacf8b2eb9d4b864dc","modified":1459690058912},{"_id":"public/tags/动漫/index.html","hash":"a20edc8d7d8e8efdae50b38bf4e1c697162e61d1","modified":1459690058916},{"_id":"public/tags/测试/index.html","hash":"5fc19910b5f036aefb5a9e92f80a9492c1c0f71f","modified":1459690058919},{"_id":"public/tags/通信协议/index.html","hash":"c079379a238fc54171232c40574d8af9617e9edd","modified":1459690058921},{"_id":"public/tags/技术调研/index.html","hash":"ac89ebcfbe65cbf17402a2fead581cb37db460fc","modified":1459690058923},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1459690058930},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1459690058930},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1459690058931},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1459690058931},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1459690058931},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1459690058932},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1459690058932},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1459690058932},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1459690058932},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1459690058932},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1459690058932},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1459690058934},{"_id":"public/img/author.jpg","hash":"40022cd45e4061a38a7aa703209feb2e7be112a4","modified":1459690058934},{"_id":"public/img/favicon.ico","hash":"fa2c03e9eb35f2f423a1c85c85c278649a857532","modified":1459690058934},{"_id":"public/img/logo.svg","hash":"cef3f0bb4bf3661dd3a58c81b9a7be79601a0bfb","modified":1459690058934},{"_id":"public/img/pacman.jpg","hash":"7e873f2f40a52f8c679302b88bb0809a6abafe5c","modified":1459690058934},{"_id":"public/img/author.png","hash":"40022cd45e4061a38a7aa703209feb2e7be112a4","modified":1459690058940},{"_id":"public/img/pic.png","hash":"40022cd45e4061a38a7aa703209feb2e7be112a4","modified":1459690058940},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1459690058941},{"_id":"public/css/style.css","hash":"75134b250c68257e5cdd1f491040db9fcef41e5a","modified":1459690059797},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1459690059797},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1459690059798},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1459690059798},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1459690059799},{"_id":"public/js/jquery-2.1.0.min.js","hash":"98884258cbdb0d939fa2c5e74fc7ac9e56d8170f","modified":1459690059800},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1459690059800},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1459690059801},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1459690059801},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1459690059801},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1459690059802},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1459690059802},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1459690059806}],"Category":[{"name":"linux内核分析","_id":"cimklrt5b0002679ygc8q4ezk"},{"name":"手绘","_id":"cimklrt65000v679yhrturvv0"}],"Data":[],"Page":[],"Post":[{"title":"Linux内核分析————总结","date":"2016-03-30T16:50:15.000Z","_content":"\n\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n---\n### 一、Linux 内核分析文章列表\n\n1、[ X86体系下计算机是如何运行程序](http://www.siplexy.me/Linux_1.html)\n \n 主要内容是**计算机是如何工作的**\n\n涉及到了**冯诺依曼存储计算机**的体系结构 、一些汇编指令的堆栈变化。\n\n\n2、 [一个简单的时间片轮转多道程序内核代码](http://www.siplexy.me/Linux_2.html)\n\n主要内容是**操作系统的运行原理**\n\n涉及到了 **函数调用栈**的结构以及操作系统是如何利用这个结构进行**进程上下文**切换的\n\n\n\n3、 [跟踪分析Linux内核的启动过程](http://www.siplexy.me/Linux_3.html)\n\n主要内容是**操作系统启动过程**\n\n宏观的分析了操作系统的启动流程，从**start_kernel()** 主要是**rest_init()** 完成了第一个用户进程的创建\n\n\n4、5、[系统调用的使用和过程详解](http://www.siplexy.me/Linux_45.html)\n\n主要内容是 **用户态和内核态的接口---系统调用的概念以及原理**\n\n涉及到了 **中断上下文切换** 以及**系统调用的三层皮**\n\n\n6、[分析Linux内核创建一个新进程的过程](http://www.siplexy.me/Linux_6.html)\n\n主要内容是 **进程简析**\n\n涉及到了 进程控制块（**task_struct**）的结构以及是如何通过**do_fork()**创建一个进程的\n\n\n7、 [Linux内核如何装载和启动一个可执行程序](http://www.siplexy.me/Linux_7.html)\n\n主要内容是**程序的装载和启动**\n\n与上次的内容紧密相连，程序在创建完进程之后如何调用自己的执行路径而完全的脱离父进程。\n\n涉及到了**程序是如何构建的**、**程序执行的执行环境**以及**execuve的具体方法**\n\n\n8、 [理解进程调度时机跟踪分析进程调度与进程切换的过程](http://www.siplexy.me/Linux_8.html)\n\n主要内容是 **进程切换**\n\n涉及到了 **进程上下文切换** 以及 **进程的一般执行过程**\n\n\n### 二、总结\n\n这门课首先学习了操作系统在运行程序过程中的一些基本原理（函数调用栈以及中断上下文的切换这些）\n\n然后主要介绍了 操作系统系统调用的实现，以及进程的创建，加载和调度。\n\n带我们从这些角度了解Linux 建立起了一个宏观概念\n\n我个人特别喜欢Linux内核在进程调度的一个感觉。\n\n就是通过 函数调用栈的结构特性。不断利用重复的代码 利用结构不变性和参数的逻辑上不变性\n\n构造出了 类似庄生梦蝶的效果   我觉得 这种循环的异常美妙的。\n\n但是 Linux 操作系统的内容远不止这些。内存寻址内存分配回收   文件系统对文件资源的管理  等等等\n\n还有很多 东西需要我们去学习 。。\n\n感谢孟宁老师。给我们 带来了一场非常棒的内核体验！\n\n","source":"_posts/Linux.md","raw":"\n---\ntitle: Linux内核分析————总结\ndate: 2016-03-31 01:50:15\ntags: linux\ncategories: linux内核分析\n---\n\n\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n---\n### 一、Linux 内核分析文章列表\n\n1、[ X86体系下计算机是如何运行程序](http://www.siplexy.me/Linux_1.html)\n \n 主要内容是**计算机是如何工作的**\n\n涉及到了**冯诺依曼存储计算机**的体系结构 、一些汇编指令的堆栈变化。\n\n\n2、 [一个简单的时间片轮转多道程序内核代码](http://www.siplexy.me/Linux_2.html)\n\n主要内容是**操作系统的运行原理**\n\n涉及到了 **函数调用栈**的结构以及操作系统是如何利用这个结构进行**进程上下文**切换的\n\n\n\n3、 [跟踪分析Linux内核的启动过程](http://www.siplexy.me/Linux_3.html)\n\n主要内容是**操作系统启动过程**\n\n宏观的分析了操作系统的启动流程，从**start_kernel()** 主要是**rest_init()** 完成了第一个用户进程的创建\n\n\n4、5、[系统调用的使用和过程详解](http://www.siplexy.me/Linux_45.html)\n\n主要内容是 **用户态和内核态的接口---系统调用的概念以及原理**\n\n涉及到了 **中断上下文切换** 以及**系统调用的三层皮**\n\n\n6、[分析Linux内核创建一个新进程的过程](http://www.siplexy.me/Linux_6.html)\n\n主要内容是 **进程简析**\n\n涉及到了 进程控制块（**task_struct**）的结构以及是如何通过**do_fork()**创建一个进程的\n\n\n7、 [Linux内核如何装载和启动一个可执行程序](http://www.siplexy.me/Linux_7.html)\n\n主要内容是**程序的装载和启动**\n\n与上次的内容紧密相连，程序在创建完进程之后如何调用自己的执行路径而完全的脱离父进程。\n\n涉及到了**程序是如何构建的**、**程序执行的执行环境**以及**execuve的具体方法**\n\n\n8、 [理解进程调度时机跟踪分析进程调度与进程切换的过程](http://www.siplexy.me/Linux_8.html)\n\n主要内容是 **进程切换**\n\n涉及到了 **进程上下文切换** 以及 **进程的一般执行过程**\n\n\n### 二、总结\n\n这门课首先学习了操作系统在运行程序过程中的一些基本原理（函数调用栈以及中断上下文的切换这些）\n\n然后主要介绍了 操作系统系统调用的实现，以及进程的创建，加载和调度。\n\n带我们从这些角度了解Linux 建立起了一个宏观概念\n\n我个人特别喜欢Linux内核在进程调度的一个感觉。\n\n就是通过 函数调用栈的结构特性。不断利用重复的代码 利用结构不变性和参数的逻辑上不变性\n\n构造出了 类似庄生梦蝶的效果   我觉得 这种循环的异常美妙的。\n\n但是 Linux 操作系统的内容远不止这些。内存寻址内存分配回收   文件系统对文件资源的管理  等等等\n\n还有很多 东西需要我们去学习 。。\n\n感谢孟宁老师。给我们 带来了一场非常棒的内核体验！\n\n","slug":"Linux","published":1,"updated":"2016-03-31T16:52:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt530000679ypevuysi2","content":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\" target=\"_blank\" rel=\"external\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><hr>\n<h3 id=\"一、Linux-内核分析文章列表\"><a href=\"#一、Linux-内核分析文章列表\" class=\"headerlink\" title=\"一、Linux 内核分析文章列表\"></a>一、Linux 内核分析文章列表</h3><p>1、<a href=\"http://www.siplexy.me/Linux_1.html\" target=\"_blank\" rel=\"external\"> X86体系下计算机是如何运行程序</a></p>\n<p> 主要内容是<strong>计算机是如何工作的</strong></p>\n<p>涉及到了<strong>冯诺依曼存储计算机</strong>的体系结构 、一些汇编指令的堆栈变化。</p>\n<p>2、 <a href=\"http://www.siplexy.me/Linux_2.html\" target=\"_blank\" rel=\"external\">一个简单的时间片轮转多道程序内核代码</a></p>\n<p>主要内容是<strong>操作系统的运行原理</strong></p>\n<p>涉及到了 <strong>函数调用栈</strong>的结构以及操作系统是如何利用这个结构进行<strong>进程上下文</strong>切换的</p>\n<p>3、 <a href=\"http://www.siplexy.me/Linux_3.html\" target=\"_blank\" rel=\"external\">跟踪分析Linux内核的启动过程</a></p>\n<p>主要内容是<strong>操作系统启动过程</strong></p>\n<p>宏观的分析了操作系统的启动流程，从<strong>start_kernel()</strong> 主要是<strong>rest_init()</strong> 完成了第一个用户进程的创建</p>\n<p>4、5、<a href=\"http://www.siplexy.me/Linux_45.html\" target=\"_blank\" rel=\"external\">系统调用的使用和过程详解</a></p>\n<p>主要内容是 <strong>用户态和内核态的接口—系统调用的概念以及原理</strong></p>\n<p>涉及到了 <strong>中断上下文切换</strong> 以及<strong>系统调用的三层皮</strong></p>\n<p>6、<a href=\"http://www.siplexy.me/Linux_6.html\" target=\"_blank\" rel=\"external\">分析Linux内核创建一个新进程的过程</a></p>\n<p>主要内容是 <strong>进程简析</strong></p>\n<p>涉及到了 进程控制块（<strong>task_struct</strong>）的结构以及是如何通过<strong>do_fork()</strong>创建一个进程的</p>\n<p>7、 <a href=\"http://www.siplexy.me/Linux_7.html\" target=\"_blank\" rel=\"external\">Linux内核如何装载和启动一个可执行程序</a></p>\n<p>主要内容是<strong>程序的装载和启动</strong></p>\n<p>与上次的内容紧密相连，程序在创建完进程之后如何调用自己的执行路径而完全的脱离父进程。</p>\n<p>涉及到了<strong>程序是如何构建的</strong>、<strong>程序执行的执行环境</strong>以及<strong>execuve的具体方法</strong></p>\n<p>8、 <a href=\"http://www.siplexy.me/Linux_8.html\" target=\"_blank\" rel=\"external\">理解进程调度时机跟踪分析进程调度与进程切换的过程</a></p>\n<p>主要内容是 <strong>进程切换</strong></p>\n<p>涉及到了 <strong>进程上下文切换</strong> 以及 <strong>进程的一般执行过程</strong></p>\n<h3 id=\"二、总结\"><a href=\"#二、总结\" class=\"headerlink\" title=\"二、总结\"></a>二、总结</h3><p>这门课首先学习了操作系统在运行程序过程中的一些基本原理（函数调用栈以及中断上下文的切换这些）</p>\n<p>然后主要介绍了 操作系统系统调用的实现，以及进程的创建，加载和调度。</p>\n<p>带我们从这些角度了解Linux 建立起了一个宏观概念</p>\n<p>我个人特别喜欢Linux内核在进程调度的一个感觉。</p>\n<p>就是通过 函数调用栈的结构特性。不断利用重复的代码 利用结构不变性和参数的逻辑上不变性</p>\n<p>构造出了 类似庄生梦蝶的效果   我觉得 这种循环的异常美妙的。</p>\n<p>但是 Linux 操作系统的内容远不止这些。内存寻址内存分配回收   文件系统对文件资源的管理  等等等</p>\n<p>还有很多 东西需要我们去学习 。。</p>\n<p>感谢孟宁老师。给我们 带来了一场非常棒的内核体验！</p>\n","excerpt":"","more":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><hr>\n<h3 id=\"一、Linux-内核分析文章列表\"><a href=\"#一、Linux-内核分析文章列表\" class=\"headerlink\" title=\"一、Linux 内核分析文章列表\"></a>一、Linux 内核分析文章列表</h3><p>1、<a href=\"http://www.siplexy.me/Linux_1.html\"> X86体系下计算机是如何运行程序</a></p>\n<p> 主要内容是<strong>计算机是如何工作的</strong></p>\n<p>涉及到了<strong>冯诺依曼存储计算机</strong>的体系结构 、一些汇编指令的堆栈变化。</p>\n<p>2、 <a href=\"http://www.siplexy.me/Linux_2.html\">一个简单的时间片轮转多道程序内核代码</a></p>\n<p>主要内容是<strong>操作系统的运行原理</strong></p>\n<p>涉及到了 <strong>函数调用栈</strong>的结构以及操作系统是如何利用这个结构进行<strong>进程上下文</strong>切换的</p>\n<p>3、 <a href=\"http://www.siplexy.me/Linux_3.html\">跟踪分析Linux内核的启动过程</a></p>\n<p>主要内容是<strong>操作系统启动过程</strong></p>\n<p>宏观的分析了操作系统的启动流程，从<strong>start_kernel()</strong> 主要是<strong>rest_init()</strong> 完成了第一个用户进程的创建</p>\n<p>4、5、<a href=\"http://www.siplexy.me/Linux_45.html\">系统调用的使用和过程详解</a></p>\n<p>主要内容是 <strong>用户态和内核态的接口—系统调用的概念以及原理</strong></p>\n<p>涉及到了 <strong>中断上下文切换</strong> 以及<strong>系统调用的三层皮</strong></p>\n<p>6、<a href=\"http://www.siplexy.me/Linux_6.html\">分析Linux内核创建一个新进程的过程</a></p>\n<p>主要内容是 <strong>进程简析</strong></p>\n<p>涉及到了 进程控制块（<strong>task_struct</strong>）的结构以及是如何通过<strong>do_fork()</strong>创建一个进程的</p>\n<p>7、 <a href=\"http://www.siplexy.me/Linux_7.html\">Linux内核如何装载和启动一个可执行程序</a></p>\n<p>主要内容是<strong>程序的装载和启动</strong></p>\n<p>与上次的内容紧密相连，程序在创建完进程之后如何调用自己的执行路径而完全的脱离父进程。</p>\n<p>涉及到了<strong>程序是如何构建的</strong>、<strong>程序执行的执行环境</strong>以及<strong>execuve的具体方法</strong></p>\n<p>8、 <a href=\"http://www.siplexy.me/Linux_8.html\">理解进程调度时机跟踪分析进程调度与进程切换的过程</a></p>\n<p>主要内容是 <strong>进程切换</strong></p>\n<p>涉及到了 <strong>进程上下文切换</strong> 以及 <strong>进程的一般执行过程</strong></p>\n<h3 id=\"二、总结\"><a href=\"#二、总结\" class=\"headerlink\" title=\"二、总结\"></a>二、总结</h3><p>这门课首先学习了操作系统在运行程序过程中的一些基本原理（函数调用栈以及中断上下文的切换这些）</p>\n<p>然后主要介绍了 操作系统系统调用的实现，以及进程的创建，加载和调度。</p>\n<p>带我们从这些角度了解Linux 建立起了一个宏观概念</p>\n<p>我个人特别喜欢Linux内核在进程调度的一个感觉。</p>\n<p>就是通过 函数调用栈的结构特性。不断利用重复的代码 利用结构不变性和参数的逻辑上不变性</p>\n<p>构造出了 类似庄生梦蝶的效果   我觉得 这种循环的异常美妙的。</p>\n<p>但是 Linux 操作系统的内容远不止这些。内存寻址内存分配回收   文件系统对文件资源的管理  等等等</p>\n<p>还有很多 东西需要我们去学习 。。</p>\n<p>感谢孟宁老师。给我们 带来了一场非常棒的内核体验！</p>\n"},{"title":"Linux内核分析1：X86体系下计算机是如何运行程序","date":"2016-03-30T16:50:15.000Z","_content":"\n\n\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n### 一、 现代计算机模型---冯诺依曼体系结构\n\n冯诺依曼体系结构就是指存储程序计算机\n\n经典的存储程序计算机由以下五部分组成：\n\n\n![jiego](http://baike.soso.com/p/20090709/20090709080850-1101162591.jpg)\n\n(其中 实线代表 数据线 虚线代表 控制线)\n\n\n1. 采用存储程序方式，指令和数据不加区别混合存储在同一个存储器中，（数据和程序在内存中是没有区别的,它们都是内存中的数据,当EIP指针指向哪 CPU就加载那段内存中的数据,如果是不正确的指令格式,CPU就会发生错误中断. 在现在CPU的保护模式中,每个内存段都其描述符,这个描述符记录着这个内存段的访问权限(可读,可写,可执行).这最就变相的指定了哪个些内存中存储的是指令哪些是数据）\n指令和数据都可以送到运算器进行运算，即由指令组成的程序是可以修改的。\n2. 存储器是按地址访问的线性编址的一维结构，每个单元的位数是固定的。\n2. 指令由操作码和地址组成。操作码指明本指令的操作类型,地址码指明操作数和地址。操作数本身无数据类型的标志，它的数据类型由操作码确定。\n2. 通过执行指令直接发出控制信号控制计算机的操作。指令在存储器中按其执行顺序存放，由指令计数器指明要执行的指令所在的单元地址。指令计数器只有一个，一般按顺序递增，但执行顺序可按运算结果或当时的外界条件而改变。\n2. 以运算器为中心，I/O设备与存储器间的数据传送都要经过运算器。\n2. 数据以二进制表示。\n\n（上的现代微处理器体系结构这么课还提到了[哈佛结构](http://www.cnblogs.com/li-hao/archive/2011/12/21/2296010.html) 和冯诺依曼结构区别主要在于数据和指令分开存储）\n\n\n### 二、 X86计算机结构\n\n\n[80X86寄存器详解](http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2501972.html)\n\n\n![结构](/images/r2.png)\n\n\n### 三、实验代码汇编分析\nC语言代码如下：\n\n\n    int g(int x){\n    \treturn x-3;\n\t}\n\tint f(int x){\n    \treturn g(x);\n\t}\n\tint main(){\n    \treturn f(1)+2;\n\t}\n\n通过gcc进行编译后生成*.s汇编代码\n\n\t$ gcc -S -o main.s main.c -m32\n\n(注：-m32 代表以32bit为链接库编译 64bit操作系统需要安装[libc6:i386](http://andycoder.me/fix-32bug-under-ubuntu1404/) 32位库)\n\n得到汇编代码main.s:\n(这里删除了.long .global .section [节或汇编程序辅助信息](http://blog.csdn.net/jnu_simba/article/details/11747901))\n\n    g:\n        pushl    %ebp\n    \tmovl\t%esp, %ebp\n    \tmovl\t8(%ebp), %eax\n    \tsubl\t$3, %eax\n    \tpopl\t%ebp\n    \tret\n    f:\n    \tpushl\t%ebp\n    \tmovl\t%esp, %ebp\n    \tsubl\t$4, %esp\n    \tmovl\t8(%ebp), %eax\n    \tmovl\t%eax, (%esp)\n    \tcall\tg\n    \tleave\n    \tret\n    main:\n    \tpushl\t%ebp\n    \tmovl\t%esp, %ebp\n    \tsubl\t$4, %esp\n    \tmovl\t$1, (%esp)\n    \tcall\tf\n    \taddl\t$2, %eax\n    \tleave\n    \tret\n        \n\n\n----\n\n以下是分析：\n\nmain：\n\n    \tpushl\t%ebp\n    \tmovl\t%esp, %ebp\n\n\n这两条指令可以放在一起看 相当于enter\n\n进入函数体都会最先执行这条enter指令\n\n作用是切换到保存上一个栈的栈底，并且将当前栈顶位置设置为栈底\n\n栈结构：\n\n![结构](/images/1.png)\n\n\n    \n    \tsubl\t$4, %esp\n    \tmovl\t$1, (%esp)\n\n这两条指令也可以放在一起看\n\n在main函数中我们是f(1)+2 吗？这里有个 立即数1 \n我们要如何使用这个参数呢？肯定需要把他放在内存中放在堆栈中\n\n所以这里 先是下移一个位置，指向一个空的区域，然后把 ‘1’ 放入这个空间中\n\n相当于 push $1\n\n栈结构：\nsubl    $4, %esp\n\n![结构](/images/2.png)\n\nmovl    $1, (%esp)：\n\n![结构](/images/3.png)\n\n\n\n\n        call f\n\ncall f 是两步操作构成的\n- 将 eip 的值入栈。\n- 将 f所指向指令的地址放入 eip中\n\n执行完之后，程序就会跳转到f: 指向的命令中执行：\n\n栈结构：\n![结构](/images/4.png)\n\n\nf:\n\n    \tpushl\t%ebp\n    \tmovl\t%esp, %ebp\n\n\n前两条和main中相同\n\n这时候栈结构我们可以发现。栈在逻辑上的划分：！！！函数调用栈\n\n栈结构：main栈和f栈\n\n![结构](/images/5.png)\n\n\n    \tsubl\t$4, %esp\n    \tmovl\t8(%ebp), %eax\n    \tmovl\t%eax, (%esp)\n\n关键是这三条指令 通过栈结构 \n首先是分配一块空的空间 然后\n我们可以发现ebp指向的是我们之前调用f中传入的参数 1 \n所以eax = 1变成了\n\n栈结构：\n\n\n![结构](/images/6.png)\n\n\n\t    call\tg\n\n栈结构：\n\n![结构](/images/7.png)\n\n保存eip，并给eip赋值为g指令的地址，进行跳转\n\n    \tpushl\t%ebp\n    \tmovl\t%esp, %ebp\n    \tmovl\t8(%ebp), %eax\n    \tsubl\t$3, %eax\n\n前两条指令同样是enter操作\n\n栈结构：\n\n![结构](/images/8.png)\n\n\n        movl\t8(%ebp), %eax\n\n\n栈结构：\n\n![结构](/images/9.png)\n\n通过栈结构知道 将参数放入eax中\n然后 \n\n        subl\t$3, %eax\n\n将eax的值-3并放入eax中\n\n栈结构：\n\n![结构](/images/10.png)\n\n\n    \tpopl\t%ebp\n\n栈结构：\n\n![结构](/images/11.png)\n\n可以看到esp指向的上一个函数调用栈的基址\npopl恢复上一个函数调用栈的地址\n\n\n        ret\n    \nret 和call相反 popl eip 将esp弹出并赋值给eip\n\n栈结构：\n\n![结构](/images/12.png)\n\n使得程序从上次调用的地方开始执行\n即：\nf:\n\n    \tleave\n    \tret\n\nleave 是和 enter 相反的过程\n相当于\n\n        movl %ebp,%esp\n        popl %ebp\n\n栈结构：movl %ebp,%esp\n\n![结构](/images/13.png)\n\n栈结构：popl %ebp\n\n![结构](/images/14.png)\n\nebp的值为上一个之前保存的上一个函数调用栈的栈底地址\n最后 ret 回到 main\n\n栈结构:\n\n![结构](/images/15.png)\n\nmain:\n\n    \taddl\t$2, %eax\n    \tleave\n    \tret\n\n\n栈结构:\n\n![结构](/images/16.png)\n\n之前的计算我们可以发现都是把\n结果放在eax里的\n\n所以 可以发现 return的值就保存在这里\n\n所以 直接 通过eax进行计算\n最后恢复保存的栈底并退出\n\n完成整个程序的执行过程\n\n实验截图：\n\n![结构](/images/sy1.png)\n\n\n\n![结构](/images/sy2.png)\n\n\n### 四、总结\n\n冯诺依曼体系结构实际上就是按照线性的内存结构 执行程序的过程。\n由于 结构是线性的，所以很容易找到数据所在的位置\n比如：充分利用函数调用栈的机制，可以很容易找到上个函数传递过来的参数\n\n\n除了内存意外，计算机在运行过程中，还需要关注体系结构中的寄存器。\n\n不同的寄存器存放了不同的信息，记录数据和指令的位置。\n\n\n> ###[有一个关于函数调用栈的细节](http://www.cnblogs.com/Quincy/archive/2012/03/27/2418835.html)\n>就是为什么向下增长。因为觉得向上增长才是很自然地事情\n查了一下大概有两个理由：\n> 1. 这样的就不用给栈和堆划分明显的分界线\n> 2. 由于堆是向上增长的，所以可以充分利用进程的内存空间\n\n等价指令：\n\ncall $xxx\n\n        push eip\n        movl $xxx,eip\n\n\nret\n\n        popl eip\n\n\npushl $xxx\n\n        subl $4,%esp\n        movl $xxx,%esp\n\n\nenter\n\n       push %ebp\n       movl %esp,%ebp\n\n\nleave\n\n        movl %ebp,%esp\n        popl %ebp\n\n\n\n\n\n\n-------\n附：\n\n- [执行sed –e ‘/^\\s*\\./d’ test_main.s > test_main1.s此命令会删除掉以空格和点开头的行，方便阅读。]( \nhttp://m15934133625.blog.163.com/blog/static/246003087201526102220519/#)\n\n- [objdump 反汇编](\nhttp://itdreamerchen.com/%E7%90%86%E8%A7%A3c%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/\n)\n\n\n\n\n","source":"_posts/Linux_1.md","raw":"---\ntitle: Linux内核分析1：X86体系下计算机是如何运行程序\ndate: 2016-03-31 01:50:15\ntags: linux\ncategories: linux内核分析\n---\n\n\n\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n### 一、 现代计算机模型---冯诺依曼体系结构\n\n冯诺依曼体系结构就是指存储程序计算机\n\n经典的存储程序计算机由以下五部分组成：\n\n\n![jiego](http://baike.soso.com/p/20090709/20090709080850-1101162591.jpg)\n\n(其中 实线代表 数据线 虚线代表 控制线)\n\n\n1. 采用存储程序方式，指令和数据不加区别混合存储在同一个存储器中，（数据和程序在内存中是没有区别的,它们都是内存中的数据,当EIP指针指向哪 CPU就加载那段内存中的数据,如果是不正确的指令格式,CPU就会发生错误中断. 在现在CPU的保护模式中,每个内存段都其描述符,这个描述符记录着这个内存段的访问权限(可读,可写,可执行).这最就变相的指定了哪个些内存中存储的是指令哪些是数据）\n指令和数据都可以送到运算器进行运算，即由指令组成的程序是可以修改的。\n2. 存储器是按地址访问的线性编址的一维结构，每个单元的位数是固定的。\n2. 指令由操作码和地址组成。操作码指明本指令的操作类型,地址码指明操作数和地址。操作数本身无数据类型的标志，它的数据类型由操作码确定。\n2. 通过执行指令直接发出控制信号控制计算机的操作。指令在存储器中按其执行顺序存放，由指令计数器指明要执行的指令所在的单元地址。指令计数器只有一个，一般按顺序递增，但执行顺序可按运算结果或当时的外界条件而改变。\n2. 以运算器为中心，I/O设备与存储器间的数据传送都要经过运算器。\n2. 数据以二进制表示。\n\n（上的现代微处理器体系结构这么课还提到了[哈佛结构](http://www.cnblogs.com/li-hao/archive/2011/12/21/2296010.html) 和冯诺依曼结构区别主要在于数据和指令分开存储）\n\n\n### 二、 X86计算机结构\n\n\n[80X86寄存器详解](http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2501972.html)\n\n\n![结构](/images/r2.png)\n\n\n### 三、实验代码汇编分析\nC语言代码如下：\n\n\n    int g(int x){\n    \treturn x-3;\n\t}\n\tint f(int x){\n    \treturn g(x);\n\t}\n\tint main(){\n    \treturn f(1)+2;\n\t}\n\n通过gcc进行编译后生成*.s汇编代码\n\n\t$ gcc -S -o main.s main.c -m32\n\n(注：-m32 代表以32bit为链接库编译 64bit操作系统需要安装[libc6:i386](http://andycoder.me/fix-32bug-under-ubuntu1404/) 32位库)\n\n得到汇编代码main.s:\n(这里删除了.long .global .section [节或汇编程序辅助信息](http://blog.csdn.net/jnu_simba/article/details/11747901))\n\n    g:\n        pushl    %ebp\n    \tmovl\t%esp, %ebp\n    \tmovl\t8(%ebp), %eax\n    \tsubl\t$3, %eax\n    \tpopl\t%ebp\n    \tret\n    f:\n    \tpushl\t%ebp\n    \tmovl\t%esp, %ebp\n    \tsubl\t$4, %esp\n    \tmovl\t8(%ebp), %eax\n    \tmovl\t%eax, (%esp)\n    \tcall\tg\n    \tleave\n    \tret\n    main:\n    \tpushl\t%ebp\n    \tmovl\t%esp, %ebp\n    \tsubl\t$4, %esp\n    \tmovl\t$1, (%esp)\n    \tcall\tf\n    \taddl\t$2, %eax\n    \tleave\n    \tret\n        \n\n\n----\n\n以下是分析：\n\nmain：\n\n    \tpushl\t%ebp\n    \tmovl\t%esp, %ebp\n\n\n这两条指令可以放在一起看 相当于enter\n\n进入函数体都会最先执行这条enter指令\n\n作用是切换到保存上一个栈的栈底，并且将当前栈顶位置设置为栈底\n\n栈结构：\n\n![结构](/images/1.png)\n\n\n    \n    \tsubl\t$4, %esp\n    \tmovl\t$1, (%esp)\n\n这两条指令也可以放在一起看\n\n在main函数中我们是f(1)+2 吗？这里有个 立即数1 \n我们要如何使用这个参数呢？肯定需要把他放在内存中放在堆栈中\n\n所以这里 先是下移一个位置，指向一个空的区域，然后把 ‘1’ 放入这个空间中\n\n相当于 push $1\n\n栈结构：\nsubl    $4, %esp\n\n![结构](/images/2.png)\n\nmovl    $1, (%esp)：\n\n![结构](/images/3.png)\n\n\n\n\n        call f\n\ncall f 是两步操作构成的\n- 将 eip 的值入栈。\n- 将 f所指向指令的地址放入 eip中\n\n执行完之后，程序就会跳转到f: 指向的命令中执行：\n\n栈结构：\n![结构](/images/4.png)\n\n\nf:\n\n    \tpushl\t%ebp\n    \tmovl\t%esp, %ebp\n\n\n前两条和main中相同\n\n这时候栈结构我们可以发现。栈在逻辑上的划分：！！！函数调用栈\n\n栈结构：main栈和f栈\n\n![结构](/images/5.png)\n\n\n    \tsubl\t$4, %esp\n    \tmovl\t8(%ebp), %eax\n    \tmovl\t%eax, (%esp)\n\n关键是这三条指令 通过栈结构 \n首先是分配一块空的空间 然后\n我们可以发现ebp指向的是我们之前调用f中传入的参数 1 \n所以eax = 1变成了\n\n栈结构：\n\n\n![结构](/images/6.png)\n\n\n\t    call\tg\n\n栈结构：\n\n![结构](/images/7.png)\n\n保存eip，并给eip赋值为g指令的地址，进行跳转\n\n    \tpushl\t%ebp\n    \tmovl\t%esp, %ebp\n    \tmovl\t8(%ebp), %eax\n    \tsubl\t$3, %eax\n\n前两条指令同样是enter操作\n\n栈结构：\n\n![结构](/images/8.png)\n\n\n        movl\t8(%ebp), %eax\n\n\n栈结构：\n\n![结构](/images/9.png)\n\n通过栈结构知道 将参数放入eax中\n然后 \n\n        subl\t$3, %eax\n\n将eax的值-3并放入eax中\n\n栈结构：\n\n![结构](/images/10.png)\n\n\n    \tpopl\t%ebp\n\n栈结构：\n\n![结构](/images/11.png)\n\n可以看到esp指向的上一个函数调用栈的基址\npopl恢复上一个函数调用栈的地址\n\n\n        ret\n    \nret 和call相反 popl eip 将esp弹出并赋值给eip\n\n栈结构：\n\n![结构](/images/12.png)\n\n使得程序从上次调用的地方开始执行\n即：\nf:\n\n    \tleave\n    \tret\n\nleave 是和 enter 相反的过程\n相当于\n\n        movl %ebp,%esp\n        popl %ebp\n\n栈结构：movl %ebp,%esp\n\n![结构](/images/13.png)\n\n栈结构：popl %ebp\n\n![结构](/images/14.png)\n\nebp的值为上一个之前保存的上一个函数调用栈的栈底地址\n最后 ret 回到 main\n\n栈结构:\n\n![结构](/images/15.png)\n\nmain:\n\n    \taddl\t$2, %eax\n    \tleave\n    \tret\n\n\n栈结构:\n\n![结构](/images/16.png)\n\n之前的计算我们可以发现都是把\n结果放在eax里的\n\n所以 可以发现 return的值就保存在这里\n\n所以 直接 通过eax进行计算\n最后恢复保存的栈底并退出\n\n完成整个程序的执行过程\n\n实验截图：\n\n![结构](/images/sy1.png)\n\n\n\n![结构](/images/sy2.png)\n\n\n### 四、总结\n\n冯诺依曼体系结构实际上就是按照线性的内存结构 执行程序的过程。\n由于 结构是线性的，所以很容易找到数据所在的位置\n比如：充分利用函数调用栈的机制，可以很容易找到上个函数传递过来的参数\n\n\n除了内存意外，计算机在运行过程中，还需要关注体系结构中的寄存器。\n\n不同的寄存器存放了不同的信息，记录数据和指令的位置。\n\n\n> ###[有一个关于函数调用栈的细节](http://www.cnblogs.com/Quincy/archive/2012/03/27/2418835.html)\n>就是为什么向下增长。因为觉得向上增长才是很自然地事情\n查了一下大概有两个理由：\n> 1. 这样的就不用给栈和堆划分明显的分界线\n> 2. 由于堆是向上增长的，所以可以充分利用进程的内存空间\n\n等价指令：\n\ncall $xxx\n\n        push eip\n        movl $xxx,eip\n\n\nret\n\n        popl eip\n\n\npushl $xxx\n\n        subl $4,%esp\n        movl $xxx,%esp\n\n\nenter\n\n       push %ebp\n       movl %esp,%ebp\n\n\nleave\n\n        movl %ebp,%esp\n        popl %ebp\n\n\n\n\n\n\n-------\n附：\n\n- [执行sed –e ‘/^\\s*\\./d’ test_main.s > test_main1.s此命令会删除掉以空格和点开头的行，方便阅读。]( \nhttp://m15934133625.blog.163.com/blog/static/246003087201526102220519/#)\n\n- [objdump 反汇编](\nhttp://itdreamerchen.com/%E7%90%86%E8%A7%A3c%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/\n)\n\n\n\n\n","slug":"Linux_1","published":1,"updated":"2016-03-31T16:52:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt5d0005679y46btnf95","content":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\" target=\"_blank\" rel=\"external\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><h3 id=\"一、-现代计算机模型—冯诺依曼体系结构\"><a href=\"#一、-现代计算机模型—冯诺依曼体系结构\" class=\"headerlink\" title=\"一、 现代计算机模型—冯诺依曼体系结构\"></a>一、 现代计算机模型—冯诺依曼体系结构</h3><p>冯诺依曼体系结构就是指存储程序计算机</p>\n<p>经典的存储程序计算机由以下五部分组成：</p>\n<p><img src=\"http://baike.soso.com/p/20090709/20090709080850-1101162591.jpg\" alt=\"jiego\"></p>\n<p>(其中 实线代表 数据线 虚线代表 控制线)</p>\n<ol>\n<li>采用存储程序方式，指令和数据不加区别混合存储在同一个存储器中，（数据和程序在内存中是没有区别的,它们都是内存中的数据,当EIP指针指向哪 CPU就加载那段内存中的数据,如果是不正确的指令格式,CPU就会发生错误中断. 在现在CPU的保护模式中,每个内存段都其描述符,这个描述符记录着这个内存段的访问权限(可读,可写,可执行).这最就变相的指定了哪个些内存中存储的是指令哪些是数据）<br>指令和数据都可以送到运算器进行运算，即由指令组成的程序是可以修改的。</li>\n<li>存储器是按地址访问的线性编址的一维结构，每个单元的位数是固定的。</li>\n<li>指令由操作码和地址组成。操作码指明本指令的操作类型,地址码指明操作数和地址。操作数本身无数据类型的标志，它的数据类型由操作码确定。</li>\n<li>通过执行指令直接发出控制信号控制计算机的操作。指令在存储器中按其执行顺序存放，由指令计数器指明要执行的指令所在的单元地址。指令计数器只有一个，一般按顺序递增，但执行顺序可按运算结果或当时的外界条件而改变。</li>\n<li>以运算器为中心，I/O设备与存储器间的数据传送都要经过运算器。</li>\n<li>数据以二进制表示。</li>\n</ol>\n<p>（上的现代微处理器体系结构这么课还提到了<a href=\"http://www.cnblogs.com/li-hao/archive/2011/12/21/2296010.html\" target=\"_blank\" rel=\"external\">哈佛结构</a> 和冯诺依曼结构区别主要在于数据和指令分开存储）</p>\n<h3 id=\"二、-X86计算机结构\"><a href=\"#二、-X86计算机结构\" class=\"headerlink\" title=\"二、 X86计算机结构\"></a>二、 X86计算机结构</h3><p><a href=\"http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2501972.html\" target=\"_blank\" rel=\"external\">80X86寄存器详解</a></p>\n<p><img src=\"/images/r2.png\" alt=\"结构\"></p>\n<h3 id=\"三、实验代码汇编分析\"><a href=\"#三、实验代码汇编分析\" class=\"headerlink\" title=\"三、实验代码汇编分析\"></a>三、实验代码汇编分析</h3><p>C语言代码如下：</p>\n<pre><code>int g(int x){\n    return x-3;\n}\nint f(int x){\n    return g(x);\n}\nint main(){\n    return f(1)+2;\n}\n</code></pre><p>通过gcc进行编译后生成*.s汇编代码</p>\n<pre><code>$ gcc -S -o main.s main.c -m32\n</code></pre><p>(注：-m32 代表以32bit为链接库编译 64bit操作系统需要安装<a href=\"http://andycoder.me/fix-32bug-under-ubuntu1404/\" target=\"_blank\" rel=\"external\">libc6:i386</a> 32位库)</p>\n<p>得到汇编代码main.s:<br>(这里删除了.long .global .section <a href=\"http://blog.csdn.net/jnu_simba/article/details/11747901\" target=\"_blank\" rel=\"external\">节或汇编程序辅助信息</a>)</p>\n<pre><code>g:\n    pushl    %ebp\n    movl    %esp, %ebp\n    movl    8(%ebp), %eax\n    subl    $3, %eax\n    popl    %ebp\n    ret\nf:\n    pushl    %ebp\n    movl    %esp, %ebp\n    subl    $4, %esp\n    movl    8(%ebp), %eax\n    movl    %eax, (%esp)\n    call    g\n    leave\n    ret\nmain:\n    pushl    %ebp\n    movl    %esp, %ebp\n    subl    $4, %esp\n    movl    $1, (%esp)\n    call    f\n    addl    $2, %eax\n    leave\n    ret\n</code></pre><hr>\n<p>以下是分析：</p>\n<p>main：</p>\n<pre><code>pushl    %ebp\nmovl    %esp, %ebp\n</code></pre><p>这两条指令可以放在一起看 相当于enter</p>\n<p>进入函数体都会最先执行这条enter指令</p>\n<p>作用是切换到保存上一个栈的栈底，并且将当前栈顶位置设置为栈底</p>\n<p>栈结构：</p>\n<p><img src=\"/images/1.png\" alt=\"结构\"></p>\n<pre><code>subl    $4, %esp\nmovl    $1, (%esp)\n</code></pre><p>这两条指令也可以放在一起看</p>\n<p>在main函数中我们是f(1)+2 吗？这里有个 立即数1<br>我们要如何使用这个参数呢？肯定需要把他放在内存中放在堆栈中</p>\n<p>所以这里 先是下移一个位置，指向一个空的区域，然后把 ‘1’ 放入这个空间中</p>\n<p>相当于 push $1</p>\n<p>栈结构：<br>subl    $4, %esp</p>\n<p><img src=\"/images/2.png\" alt=\"结构\"></p>\n<p>movl    $1, (%esp)：</p>\n<p><img src=\"/images/3.png\" alt=\"结构\"></p>\n<pre><code>call f\n</code></pre><p>call f 是两步操作构成的</p>\n<ul>\n<li>将 eip 的值入栈。</li>\n<li>将 f所指向指令的地址放入 eip中</li>\n</ul>\n<p>执行完之后，程序就会跳转到f: 指向的命令中执行：</p>\n<p>栈结构：<br><img src=\"/images/4.png\" alt=\"结构\"></p>\n<p>f:</p>\n<pre><code>pushl    %ebp\nmovl    %esp, %ebp\n</code></pre><p>前两条和main中相同</p>\n<p>这时候栈结构我们可以发现。栈在逻辑上的划分：！！！函数调用栈</p>\n<p>栈结构：main栈和f栈</p>\n<p><img src=\"/images/5.png\" alt=\"结构\"></p>\n<pre><code>subl    $4, %esp\nmovl    8(%ebp), %eax\nmovl    %eax, (%esp)\n</code></pre><p>关键是这三条指令 通过栈结构<br>首先是分配一块空的空间 然后<br>我们可以发现ebp指向的是我们之前调用f中传入的参数 1<br>所以eax = 1变成了</p>\n<p>栈结构：</p>\n<p><img src=\"/images/6.png\" alt=\"结构\"></p>\n<pre><code>call    g\n</code></pre><p>栈结构：</p>\n<p><img src=\"/images/7.png\" alt=\"结构\"></p>\n<p>保存eip，并给eip赋值为g指令的地址，进行跳转</p>\n<pre><code>pushl    %ebp\nmovl    %esp, %ebp\nmovl    8(%ebp), %eax\nsubl    $3, %eax\n</code></pre><p>前两条指令同样是enter操作</p>\n<p>栈结构：</p>\n<p><img src=\"/images/8.png\" alt=\"结构\"></p>\n<pre><code>movl    8(%ebp), %eax\n</code></pre><p>栈结构：</p>\n<p><img src=\"/images/9.png\" alt=\"结构\"></p>\n<p>通过栈结构知道 将参数放入eax中<br>然后 </p>\n<pre><code>subl    $3, %eax\n</code></pre><p>将eax的值-3并放入eax中</p>\n<p>栈结构：</p>\n<p><img src=\"/images/10.png\" alt=\"结构\"></p>\n<pre><code>popl    %ebp\n</code></pre><p>栈结构：</p>\n<p><img src=\"/images/11.png\" alt=\"结构\"></p>\n<p>可以看到esp指向的上一个函数调用栈的基址<br>popl恢复上一个函数调用栈的地址</p>\n<pre><code>ret\n</code></pre><p>ret 和call相反 popl eip 将esp弹出并赋值给eip</p>\n<p>栈结构：</p>\n<p><img src=\"/images/12.png\" alt=\"结构\"></p>\n<p>使得程序从上次调用的地方开始执行<br>即：<br>f:</p>\n<pre><code>leave\nret\n</code></pre><p>leave 是和 enter 相反的过程<br>相当于</p>\n<pre><code>movl %ebp,%esp\npopl %ebp\n</code></pre><p>栈结构：movl %ebp,%esp</p>\n<p><img src=\"/images/13.png\" alt=\"结构\"></p>\n<p>栈结构：popl %ebp</p>\n<p><img src=\"/images/14.png\" alt=\"结构\"></p>\n<p>ebp的值为上一个之前保存的上一个函数调用栈的栈底地址<br>最后 ret 回到 main</p>\n<p>栈结构:</p>\n<p><img src=\"/images/15.png\" alt=\"结构\"></p>\n<p>main:</p>\n<pre><code>addl    $2, %eax\nleave\nret\n</code></pre><p>栈结构:</p>\n<p><img src=\"/images/16.png\" alt=\"结构\"></p>\n<p>之前的计算我们可以发现都是把<br>结果放在eax里的</p>\n<p>所以 可以发现 return的值就保存在这里</p>\n<p>所以 直接 通过eax进行计算<br>最后恢复保存的栈底并退出</p>\n<p>完成整个程序的执行过程</p>\n<p>实验截图：</p>\n<p><img src=\"/images/sy1.png\" alt=\"结构\"></p>\n<p><img src=\"/images/sy2.png\" alt=\"结构\"></p>\n<h3 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h3><p>冯诺依曼体系结构实际上就是按照线性的内存结构 执行程序的过程。<br>由于 结构是线性的，所以很容易找到数据所在的位置<br>比如：充分利用函数调用栈的机制，可以很容易找到上个函数传递过来的参数</p>\n<p>除了内存意外，计算机在运行过程中，还需要关注体系结构中的寄存器。</p>\n<p>不同的寄存器存放了不同的信息，记录数据和指令的位置。</p>\n<blockquote>\n<p>###<a href=\"http://www.cnblogs.com/Quincy/archive/2012/03/27/2418835.html\" target=\"_blank\" rel=\"external\">有一个关于函数调用栈的细节</a><br>就是为什么向下增长。因为觉得向上增长才是很自然地事情<br>查了一下大概有两个理由：</p>\n<ol>\n<li>这样的就不用给栈和堆划分明显的分界线</li>\n<li>由于堆是向上增长的，所以可以充分利用进程的内存空间</li>\n</ol>\n</blockquote>\n<p>等价指令：</p>\n<p>call $xxx</p>\n<pre><code>push eip\nmovl $xxx,eip\n</code></pre><p>ret</p>\n<pre><code>popl eip\n</code></pre><p>pushl $xxx</p>\n<pre><code>subl $4,%esp\nmovl $xxx,%esp\n</code></pre><p>enter</p>\n<pre><code>push %ebp\nmovl %esp,%ebp\n</code></pre><p>leave</p>\n<pre><code>movl %ebp,%esp\npopl %ebp\n</code></pre><hr>\n<p>附：</p>\n<ul>\n<li><p><a href=\"http://m15934133625.blog.163.com/blog/static/246003087201526102220519/#\" target=\"_blank\" rel=\"external\">执行sed –e ‘/^\\s*./d’ test_main.s &gt; test_main1.s此命令会删除掉以空格和点开头的行，方便阅读。</a></p>\n</li>\n<li><p><a href=\"http://itdreamerchen.com/%E7%90%86%E8%A7%A3c%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/\" target=\"_blank\" rel=\"external\">objdump 反汇编</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><h3 id=\"一、-现代计算机模型—冯诺依曼体系结构\"><a href=\"#一、-现代计算机模型—冯诺依曼体系结构\" class=\"headerlink\" title=\"一、 现代计算机模型—冯诺依曼体系结构\"></a>一、 现代计算机模型—冯诺依曼体系结构</h3><p>冯诺依曼体系结构就是指存储程序计算机</p>\n<p>经典的存储程序计算机由以下五部分组成：</p>\n<p><img src=\"http://baike.soso.com/p/20090709/20090709080850-1101162591.jpg\" alt=\"jiego\"></p>\n<p>(其中 实线代表 数据线 虚线代表 控制线)</p>\n<ol>\n<li>采用存储程序方式，指令和数据不加区别混合存储在同一个存储器中，（数据和程序在内存中是没有区别的,它们都是内存中的数据,当EIP指针指向哪 CPU就加载那段内存中的数据,如果是不正确的指令格式,CPU就会发生错误中断. 在现在CPU的保护模式中,每个内存段都其描述符,这个描述符记录着这个内存段的访问权限(可读,可写,可执行).这最就变相的指定了哪个些内存中存储的是指令哪些是数据）<br>指令和数据都可以送到运算器进行运算，即由指令组成的程序是可以修改的。</li>\n<li>存储器是按地址访问的线性编址的一维结构，每个单元的位数是固定的。</li>\n<li>指令由操作码和地址组成。操作码指明本指令的操作类型,地址码指明操作数和地址。操作数本身无数据类型的标志，它的数据类型由操作码确定。</li>\n<li>通过执行指令直接发出控制信号控制计算机的操作。指令在存储器中按其执行顺序存放，由指令计数器指明要执行的指令所在的单元地址。指令计数器只有一个，一般按顺序递增，但执行顺序可按运算结果或当时的外界条件而改变。</li>\n<li>以运算器为中心，I/O设备与存储器间的数据传送都要经过运算器。</li>\n<li>数据以二进制表示。</li>\n</ol>\n<p>（上的现代微处理器体系结构这么课还提到了<a href=\"http://www.cnblogs.com/li-hao/archive/2011/12/21/2296010.html\">哈佛结构</a> 和冯诺依曼结构区别主要在于数据和指令分开存储）</p>\n<h3 id=\"二、-X86计算机结构\"><a href=\"#二、-X86计算机结构\" class=\"headerlink\" title=\"二、 X86计算机结构\"></a>二、 X86计算机结构</h3><p><a href=\"http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2501972.html\">80X86寄存器详解</a></p>\n<p><img src=\"/images/r2.png\" alt=\"结构\"></p>\n<h3 id=\"三、实验代码汇编分析\"><a href=\"#三、实验代码汇编分析\" class=\"headerlink\" title=\"三、实验代码汇编分析\"></a>三、实验代码汇编分析</h3><p>C语言代码如下：</p>\n<pre><code>int g(int x){\n    return x-3;\n}\nint f(int x){\n    return g(x);\n}\nint main(){\n    return f(1)+2;\n}\n</code></pre><p>通过gcc进行编译后生成*.s汇编代码</p>\n<pre><code>$ gcc -S -o main.s main.c -m32\n</code></pre><p>(注：-m32 代表以32bit为链接库编译 64bit操作系统需要安装<a href=\"http://andycoder.me/fix-32bug-under-ubuntu1404/\">libc6:i386</a> 32位库)</p>\n<p>得到汇编代码main.s:<br>(这里删除了.long .global .section <a href=\"http://blog.csdn.net/jnu_simba/article/details/11747901\">节或汇编程序辅助信息</a>)</p>\n<pre><code>g:\n    pushl    %ebp\n    movl    %esp, %ebp\n    movl    8(%ebp), %eax\n    subl    $3, %eax\n    popl    %ebp\n    ret\nf:\n    pushl    %ebp\n    movl    %esp, %ebp\n    subl    $4, %esp\n    movl    8(%ebp), %eax\n    movl    %eax, (%esp)\n    call    g\n    leave\n    ret\nmain:\n    pushl    %ebp\n    movl    %esp, %ebp\n    subl    $4, %esp\n    movl    $1, (%esp)\n    call    f\n    addl    $2, %eax\n    leave\n    ret\n</code></pre><hr>\n<p>以下是分析：</p>\n<p>main：</p>\n<pre><code>pushl    %ebp\nmovl    %esp, %ebp\n</code></pre><p>这两条指令可以放在一起看 相当于enter</p>\n<p>进入函数体都会最先执行这条enter指令</p>\n<p>作用是切换到保存上一个栈的栈底，并且将当前栈顶位置设置为栈底</p>\n<p>栈结构：</p>\n<p><img src=\"/images/1.png\" alt=\"结构\"></p>\n<pre><code>subl    $4, %esp\nmovl    $1, (%esp)\n</code></pre><p>这两条指令也可以放在一起看</p>\n<p>在main函数中我们是f(1)+2 吗？这里有个 立即数1<br>我们要如何使用这个参数呢？肯定需要把他放在内存中放在堆栈中</p>\n<p>所以这里 先是下移一个位置，指向一个空的区域，然后把 ‘1’ 放入这个空间中</p>\n<p>相当于 push $1</p>\n<p>栈结构：<br>subl    $4, %esp</p>\n<p><img src=\"/images/2.png\" alt=\"结构\"></p>\n<p>movl    $1, (%esp)：</p>\n<p><img src=\"/images/3.png\" alt=\"结构\"></p>\n<pre><code>call f\n</code></pre><p>call f 是两步操作构成的</p>\n<ul>\n<li>将 eip 的值入栈。</li>\n<li>将 f所指向指令的地址放入 eip中</li>\n</ul>\n<p>执行完之后，程序就会跳转到f: 指向的命令中执行：</p>\n<p>栈结构：<br><img src=\"/images/4.png\" alt=\"结构\"></p>\n<p>f:</p>\n<pre><code>pushl    %ebp\nmovl    %esp, %ebp\n</code></pre><p>前两条和main中相同</p>\n<p>这时候栈结构我们可以发现。栈在逻辑上的划分：！！！函数调用栈</p>\n<p>栈结构：main栈和f栈</p>\n<p><img src=\"/images/5.png\" alt=\"结构\"></p>\n<pre><code>subl    $4, %esp\nmovl    8(%ebp), %eax\nmovl    %eax, (%esp)\n</code></pre><p>关键是这三条指令 通过栈结构<br>首先是分配一块空的空间 然后<br>我们可以发现ebp指向的是我们之前调用f中传入的参数 1<br>所以eax = 1变成了</p>\n<p>栈结构：</p>\n<p><img src=\"/images/6.png\" alt=\"结构\"></p>\n<pre><code>call    g\n</code></pre><p>栈结构：</p>\n<p><img src=\"/images/7.png\" alt=\"结构\"></p>\n<p>保存eip，并给eip赋值为g指令的地址，进行跳转</p>\n<pre><code>pushl    %ebp\nmovl    %esp, %ebp\nmovl    8(%ebp), %eax\nsubl    $3, %eax\n</code></pre><p>前两条指令同样是enter操作</p>\n<p>栈结构：</p>\n<p><img src=\"/images/8.png\" alt=\"结构\"></p>\n<pre><code>movl    8(%ebp), %eax\n</code></pre><p>栈结构：</p>\n<p><img src=\"/images/9.png\" alt=\"结构\"></p>\n<p>通过栈结构知道 将参数放入eax中<br>然后 </p>\n<pre><code>subl    $3, %eax\n</code></pre><p>将eax的值-3并放入eax中</p>\n<p>栈结构：</p>\n<p><img src=\"/images/10.png\" alt=\"结构\"></p>\n<pre><code>popl    %ebp\n</code></pre><p>栈结构：</p>\n<p><img src=\"/images/11.png\" alt=\"结构\"></p>\n<p>可以看到esp指向的上一个函数调用栈的基址<br>popl恢复上一个函数调用栈的地址</p>\n<pre><code>ret\n</code></pre><p>ret 和call相反 popl eip 将esp弹出并赋值给eip</p>\n<p>栈结构：</p>\n<p><img src=\"/images/12.png\" alt=\"结构\"></p>\n<p>使得程序从上次调用的地方开始执行<br>即：<br>f:</p>\n<pre><code>leave\nret\n</code></pre><p>leave 是和 enter 相反的过程<br>相当于</p>\n<pre><code>movl %ebp,%esp\npopl %ebp\n</code></pre><p>栈结构：movl %ebp,%esp</p>\n<p><img src=\"/images/13.png\" alt=\"结构\"></p>\n<p>栈结构：popl %ebp</p>\n<p><img src=\"/images/14.png\" alt=\"结构\"></p>\n<p>ebp的值为上一个之前保存的上一个函数调用栈的栈底地址<br>最后 ret 回到 main</p>\n<p>栈结构:</p>\n<p><img src=\"/images/15.png\" alt=\"结构\"></p>\n<p>main:</p>\n<pre><code>addl    $2, %eax\nleave\nret\n</code></pre><p>栈结构:</p>\n<p><img src=\"/images/16.png\" alt=\"结构\"></p>\n<p>之前的计算我们可以发现都是把<br>结果放在eax里的</p>\n<p>所以 可以发现 return的值就保存在这里</p>\n<p>所以 直接 通过eax进行计算<br>最后恢复保存的栈底并退出</p>\n<p>完成整个程序的执行过程</p>\n<p>实验截图：</p>\n<p><img src=\"/images/sy1.png\" alt=\"结构\"></p>\n<p><img src=\"/images/sy2.png\" alt=\"结构\"></p>\n<h3 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h3><p>冯诺依曼体系结构实际上就是按照线性的内存结构 执行程序的过程。<br>由于 结构是线性的，所以很容易找到数据所在的位置<br>比如：充分利用函数调用栈的机制，可以很容易找到上个函数传递过来的参数</p>\n<p>除了内存意外，计算机在运行过程中，还需要关注体系结构中的寄存器。</p>\n<p>不同的寄存器存放了不同的信息，记录数据和指令的位置。</p>\n<blockquote>\n<p>###<a href=\"http://www.cnblogs.com/Quincy/archive/2012/03/27/2418835.html\">有一个关于函数调用栈的细节</a><br>就是为什么向下增长。因为觉得向上增长才是很自然地事情<br>查了一下大概有两个理由：</p>\n<ol>\n<li>这样的就不用给栈和堆划分明显的分界线</li>\n<li>由于堆是向上增长的，所以可以充分利用进程的内存空间</li>\n</ol>\n</blockquote>\n<p>等价指令：</p>\n<p>call $xxx</p>\n<pre><code>push eip\nmovl $xxx,eip\n</code></pre><p>ret</p>\n<pre><code>popl eip\n</code></pre><p>pushl $xxx</p>\n<pre><code>subl $4,%esp\nmovl $xxx,%esp\n</code></pre><p>enter</p>\n<pre><code>push %ebp\nmovl %esp,%ebp\n</code></pre><p>leave</p>\n<pre><code>movl %ebp,%esp\npopl %ebp\n</code></pre><hr>\n<p>附：</p>\n<ul>\n<li><p><a href=\"http://m15934133625.blog.163.com/blog/static/246003087201526102220519/#\">执行sed –e ‘/^\\s*./d’ test_main.s &gt; test_main1.s此命令会删除掉以空格和点开头的行，方便阅读。</a></p>\n</li>\n<li><p><a href=\"http://itdreamerchen.com/%E7%90%86%E8%A7%A3c%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/\">objdump 反汇编</a></p>\n</li>\n</ul>\n"},{"title":"Linux内核分析作业2：一个简单的时间片轮转多道程序内核代码","date":"2016-03-30T16:50:15.000Z","_content":"\n\n\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n---\ngithub项目：[Mykernel](https://github.com/mengning/mykernel)\n\n### 一、步骤整理\n\n请先在下载好[linux-3.9.4.tar.xz](https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.9.4.tar.xz ) \n\n1. 安装 qemu\n\n\t\tsudo apt-get install qemu # install QEMU\n\t\tsudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu\n2. 解压 linux\n\t\n\t\txz -d linux-3.9.4.tar.xz\n\t\ttar -xvf linux-3.9.4.tar\n3. 打内核补丁  [mykernel_for_linux3.9.4sc.patch](https://github.com/mengning/mykernel/blob/master/mykernel_for_linux3.9.4sc.patch)\n\n\t\tpatch -p1 < ../mykernel_for_linux3.9.4sc.patch\n4. 编译运行 \n\n\n\t\t\tmake allnoconfig\n\t\t\tmake\n\t\t\tqemu -kernel arch/x86/boot/bzImage\n\n\n\n实验截图：\n\n\n![enter image description here](/linux2/lab2_1.png)\n\n\n![enter image description here](/linux2/lab2_2.png)\n\n![enter image description here](/linux2/lab2_3.png)\n\n5. 将 mypcb.h 、mymain.c、myinterrupt.c 放入mykernel 文件夹 并编译运行 \n\n![enter image description here](/linux2/lab2_4.png)\n\n\n### 二、内核代码执行过程\n\n核心代码主要由：mypcb.h 、mymain.c、myinterrupt.c三个文件构成\n\n\n\n\n\n#### 1. mypcb.h\n\n\t#define MAX_TASK_NUM        4\n\t#define KERNEL_STACK_SIZE   1024*8\n\n\t/* CPU-specific state of this task */\n\tstruct Thread {\n\t    unsigned long\t\tip;\n\t    unsigned long\t\tsp;\n\t};\n\t\n\ttypedef struct PCB{\n\t    int pid;\n\t    volatile long state;\t/* -1 unrunnable, 0 runnable, >0 stopped */\n\t    char stack[KERNEL_STACK_SIZE];\n\t    /* CPU-specific state of this task */\n\t    struct Thread thread;\n\t    unsigned long\ttask_entry;\n\t    struct PCB *next;\n\t}tPCB;\n\t\n\tvoid my_schedule(void);\n\n这里主要是定义了进程控制块的参数。\n\n参数主要包括了：\n\n\n> - pid 进程标识符\n> - state 进程运行状态\n> - thread 进程寄存器的信息 包括了 堆栈sp指针和当前进程指令ip\n> - task_entry 进程运行代码的入口\n> - 下一个进程控制块（进程控制块是以链表的方式组织的）\n\n#### 2. mymain.h\n\n先说下my_process()\n这个函数是进程调度时会运行的代码\n\n\t\tvoid my_process(void)\n\t{\n\t    int i = 0;\n\t    while(1)\n\t    {\n\t        i++;\n\t        if(i%10000000 == 0)\n\t        {\n\t            printk(KERN_NOTICE \"this is process %d -\\n\",my_current_task->pid);\n\t            if(my_need_sched == 1)\n\t            {\n\t                my_need_sched = 0;\n\t        \t    my_schedule();\n\t        \t}\n\t        \tprintk(KERN_NOTICE \"this is process %d +\\n\",my_current_task->pid);\n\t        }     \n\t    }\n\n逻辑很简单，就是进程执行循环执行某个人物，当执行到i%10000000=0时，会进行调度。\n\n如果my_need_sched =1 会进行主动调度，执行调度函数 my_schedule()\n\n而这个 my_need_sched=1 是每次时钟中断发生时会改变一次，我们后面会看到\n\n接着分析，my_main.c中主要的\n\n\tvoid __init my_start_kernel(void)\n\t{\n\t\tint pid = 0;\n\t    int i;\n\t    /* Initialize process 0*/\n\t    task[pid].pid = pid;\n\t    task[pid].state = 0;/* -1 unrunnable, 0 runnable, >0 stopped */\n\t    task[pid].task_entry = task[pid].thread.ip = (unsigned long)my_process;\n\t    task[pid].thread.sp = (unsigned long)&task[pid].stack[KERNEL_STACK_SIZE-1];\n\t    task[pid].next = &task[pid];\n\t    /*fork more process */\n\t    for(i=1;i<MAX_TASK_NUM;i++)\n\t    {\n\t        memcpy(&task[i],&task[0],sizeof(tPCB));\n\t        task[i].pid = i;\n\t        task[i].state = -1;\n\t        task[i].thread.sp = (unsigned long)&task[i].stack[KERNEL_STACK_SIZE-1];\n\t        task[i].next = task[i-1].next;\n\t        task[i-1].next = &task[i];\n\t    }\n    /* start process 0 by task[0] */\n\t    /* start process 0 by task[0] */\n\t    pid = 0;\n\t    my_current_task = &task[pid];\n\t\tasm volatile(\n\t    \t\"movl %1,%%esp\\n\\t\" \t/* set task[pid].thread.sp to esp */\n\t    \t\"pushl %1\\n\\t\" \t        /* push ebp */\n\t    \t\"pushl %0\\n\\t\" \t        /* push task[pid].thread.ip */\n\t    \t\"ret\\n\\t\" \t            /* pop task[pid].thread.ip to eip */\n\t    \t\"popl %%ebp\\n\\t\"\n\t    \t: \n\t    \t: \"c\" (task[pid].thread.ip),\"d\" (task[pid].thread.sp)\t/* input c or d mean %ecx/%edx*/\n\t\t);\n\t}   \n\n前半部分比较简单。是初始化进程控制块，把他们连接在一起（这是一个循环链表），然后将当前进程my_current_task=task[0];\n\n之后的操作就该是执行该控制块了。有这段汇编实现（**重点**）\n\n\tasm volatile(\n\t\t    \t\"movl %1,%%esp\\n\\t\" \t/* set task[pid].thread.sp to esp */\n\t\t    \t\"pushl %1\\n\\t\" \t        /* push ebp */\n\t\t    \t\"pushl %0\\n\\t\" \t        /* push task[pid].thread.ip */\n\t\t    \t\"ret\\n\\t\" \t            /* pop task[pid].thread.ip to eip */\n\t\t    \t\"popl %%ebp\\n\\t\"\n\t\t    \t: \n\t\t    \t: \"c\" (task[pid].thread.ip),\"d\" (task[pid].thread.sp)\t/* input c or d mean %ecx/%edx*/\n\t\t\t);\n\n这里应该是进行三步：\n\n1.  切换esp\n2.  保存上一个堆栈框架的ebp并且将ebp=esp（相当于entry **这里没有ebp=esp 不够严谨**）\n3. 跳转到task[0]的执行流里（实现方式是先push到esp中，然后ret，当esp指向的元素pop到eip中）\n\n这样一个进程就开始执行了。\n\n#### 3. myinterrupt.c\n\n这里是时钟中断发生的处理函数：\n\n\t\tvoid my_timer_handler(void)\n\t{\n\t#if 1\n\t    if(time_count%1000 == 0 && my_need_sched != 1)\n\t    {\n\t        printk(KERN_NOTICE \">>>my_timer_handler here<<<\\n\");\n\t        my_need_sched = 1;\n\t    } \n\t    time_count ++ ;  \n\t#endif\n\t    return;  \t\n\t}\n\n主要的就是会修改 my_need_sched 这个值触发调度\n\nmy_schedule(void) 调度函数\n\n\ttPCB * next;\n    tPCB * prev;\n\n    if(my_current_task == NULL \n        || my_current_task->next == NULL)\n    {\n    \treturn;\n    }\n    printk(KERN_NOTICE \">>>my_schedule<<<\\n\");\n    /* schedule */\n    next = my_current_task->next;\n    prev = my_current_task;\n\n这一端代码的意思是\n\nnext 为下一个进程\n\nprev 为当前进程\n\n\tif(next->state == 0)/* -1 unrunnable, 0 runnable, >0 stopped */\n\t    {\n\t    \t/* switch to next process */\n\t    \tasm volatile(\t\n\t        \t\"pushl %%ebp\\n\\t\" \t    /* save ebp */\n\t        \t\"movl %%esp,%0\\n\\t\" \t/* save esp */\n\t        \t\"movl %2,%%esp\\n\\t\"     /* restore  esp */\n\t        \t\"movl $1f,%1\\n\\t\"       /* save eip */\t\n\t        \t\"pushl %3\\n\\t\" \n\t        \t\"ret\\n\\t\" \t            /* restore  eip */\n\t        \t\"1:\\t\"                  /* next process start here */\n\t        \t\"popl %%ebp\\n\\t\"\n\t        \t: \"=m\" (prev->thread.sp),\"=m\" (prev->thread.ip)\n\t        \t: \"m\" (next->thread.sp),\"m\" (next->thread.ip)\n\t    \t); \n\t    \tmy_current_task = next; \n\t    \tprintk(KERN_NOTICE \">>>switch %d to %d<<<\\n\",prev->pid,next->pid);   \t\n\t    }\n\t    else\n\t    {\n\t        next->state = 0;\n\t        my_current_task = next;\n\t        printk(KERN_NOTICE \">>>switch %d to %d<<<\\n\",prev->pid,next->pid);\n\t    \t/* switch to new process */\n\t    \tasm volatile(\t\n\t        \t\"pushl %%ebp\\n\\t\" \t    /* save ebp */\n\t        \t\"movl %%esp,%0\\n\\t\" \t/* save esp */\n\t        \t\"movl %2,%%esp\\n\\t\"     /* restore  esp */\n\t        \t\"movl %2,%%ebp\\n\\t\"     /* restore  ebp */\n\t        \t\"movl $1f,%1\\n\\t\"       /* save eip */\t\n\t        \t\"pushl %3\\n\\t\" \n\t        \t\"ret\\n\\t\" \t            /* restore  eip */\n\t        \t: \"=m\" (prev->thread.sp),\"=m\" (prev->thread.ip)\n\t        \t: \"m\" (next->thread.sp),\"m\" (next->thread.ip)\n\t    \t);          \n\t    }   \n\nnext->state 代表运行状态  =0 代表已经运行  =-1 代表 还没有运行\n\n当next进程还没有运行时 进程切换的代码是这样的：\n\n\tasm volatile(\t\n\t        \t\"pushl %%ebp\\n\\t\" \t    /* save ebp */\n\t        \t\"movl %%esp,%0\\n\\t\" \t/* save esp */\n\t        \t\"movl %2,%%esp\\n\\t\"     /* restore  esp */\n\t        \t\"movl %2,%%ebp\\n\\t\"     /* restore  ebp */\n\t        \t\"movl $1f,%1\\n\\t\"       /* save eip */\t\n\t        \t\"pushl %3\\n\\t\" \n\t        \t\"ret\\n\\t\" \t            /* restore  eip */\n\t        \t: \"=m\" (prev->thread.sp),\"=m\" (prev->thread.ip)\n\t        \t: \"m\" (next->thread.sp),\"m\" (next->thread.ip)\n\n步骤如下\n\n首先要保存现场： \n\n1. 保存ebp到当前进程的esp中 pushl %%ebp\\n\\t\n2. 保存当前esp的内容到 当前进程 movl %%esp,%0\n3.  保存eip movl $1f,%1 这里的$1f是下次运行时第一条指令的位置，代表为f （forward）向前方向上 1 标号 所指指令的地址。\n\n还有切换到当前进程的现场：\n\n1.  恢复esp。movl %2,%%esp\n2.  恢复ebp。movl %2,%%ebp  （**刚开始运行 ebp=esp**）\n\n最后跳转到next进程的执行流中:\n和之前一样\n\n\tpushl %3\n\tret   \n\n然后 ret的值就是my_process()这个函数的起始位置。开始执行该函数。\n\n然后 这样运行第一圈之后，又会回到task[0] 此时task[0]已经运行了。所以会执行一下汇编进行进程切换。\n\n\tasm volatile(\t\n\t        \t\"pushl %%ebp\\n\\t\" \t    /* save ebp */\n\t        \t\"movl %%esp,%0\\n\\t\" \t/* save esp */\n\t        \t\"movl %2,%%esp\\n\\t\"     /* restore  esp */\n\t        \t\"movl $1f,%1\\n\\t\"       /* save eip */\t\n\t        \t\"pushl %3\\n\\t\" \n\t        \t\"ret\\n\\t\" \t            /* restore  eip */\n\t        \t\"1:\\t\"                  /* next process start here */\n\t        \t\"popl %%ebp\\n\\t\"\n\t        \t: \"=m\" (prev->thread.sp),\"=m\" (prev->thread.ip)\n\t        \t: \"m\" (next->thread.sp),\"m\" (next->thread.ip)\n\t    \t); \n\n保存现场和恢复现场的部分是和之前一样的。\n除了恢复现场没有恢复ebp\n\n关键是还记得上一次我们保存 当前进程的eip的时候，保存的值是$1f嘛？\n所以 \n\n\tpushl %3\n\tret     \n要进入下一个进程的执行流时，此时的eip 为 1 标号所对应的指令\n\n\t1：popl %%ebp\n\n这样过程就完整了，恢复现场的工作完成了，ebp指向了正确的值。\n\n\n### 三、总结\n\n其实，整个过程最重要的就是理解函数调用栈的框架。\n\n这个框架大概是这样的\n\n![enter image description here](/linux2/end.png)\n\n保持这个框架的完整性即可\n\n### 四、补充\n\n- volatile 限定符 会把变量放在register中  执行流取的时候 要放到寄存器 放到内存容易出现问题\n- 如何 制作整个 mykernel 项目的\n\nmykernel 的制作涉及到了两个问题：\n\n1.  如何设置时钟中断\n2. 如何把控制权交给 mymain.c 中的  my_start_kernel\n\n其实两个问题都可以从  [mykernel_for_linux3.9.4sc.patch](https://github.com/mengning/mykernel/blob/master/mykernel_for_linux3.9.4sc.patch)\n中找到答案\n\n因为文件比较大 我就不贴出来了。。\n\n直接标记大概修改了那些地方：\n\n##### 1.和时钟中断有关 \n\n> - /arch/x86/kernel/time.c 中的 timer_interrupt（） (时钟中断处理函数 会调用my_timer_handler();)\n\n##### 2.和mymain.c相关\n> - /init/main.c 中的 start_kernel()\n\n##### 3.其他细节\n\n> - extern 需要的函数 如：在/arch/x86/kernel/time.c  extern void my_timer_handler(void);\n> - 编写需要的makefile 主要是 /mykernel/Makefile \n> - 同时还需要修改下根目录下的 总Makefile\n> - 还有README  (^_^)Y\n","source":"_posts/Linux_2.md","raw":"---\ntitle: Linux内核分析作业2：一个简单的时间片轮转多道程序内核代码\ndate: 2016-03-31 01:50:15\ntags: linux\ncategories: linux内核分析\n---\n\n\n\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n---\ngithub项目：[Mykernel](https://github.com/mengning/mykernel)\n\n### 一、步骤整理\n\n请先在下载好[linux-3.9.4.tar.xz](https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.9.4.tar.xz ) \n\n1. 安装 qemu\n\n\t\tsudo apt-get install qemu # install QEMU\n\t\tsudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu\n2. 解压 linux\n\t\n\t\txz -d linux-3.9.4.tar.xz\n\t\ttar -xvf linux-3.9.4.tar\n3. 打内核补丁  [mykernel_for_linux3.9.4sc.patch](https://github.com/mengning/mykernel/blob/master/mykernel_for_linux3.9.4sc.patch)\n\n\t\tpatch -p1 < ../mykernel_for_linux3.9.4sc.patch\n4. 编译运行 \n\n\n\t\t\tmake allnoconfig\n\t\t\tmake\n\t\t\tqemu -kernel arch/x86/boot/bzImage\n\n\n\n实验截图：\n\n\n![enter image description here](/linux2/lab2_1.png)\n\n\n![enter image description here](/linux2/lab2_2.png)\n\n![enter image description here](/linux2/lab2_3.png)\n\n5. 将 mypcb.h 、mymain.c、myinterrupt.c 放入mykernel 文件夹 并编译运行 \n\n![enter image description here](/linux2/lab2_4.png)\n\n\n### 二、内核代码执行过程\n\n核心代码主要由：mypcb.h 、mymain.c、myinterrupt.c三个文件构成\n\n\n\n\n\n#### 1. mypcb.h\n\n\t#define MAX_TASK_NUM        4\n\t#define KERNEL_STACK_SIZE   1024*8\n\n\t/* CPU-specific state of this task */\n\tstruct Thread {\n\t    unsigned long\t\tip;\n\t    unsigned long\t\tsp;\n\t};\n\t\n\ttypedef struct PCB{\n\t    int pid;\n\t    volatile long state;\t/* -1 unrunnable, 0 runnable, >0 stopped */\n\t    char stack[KERNEL_STACK_SIZE];\n\t    /* CPU-specific state of this task */\n\t    struct Thread thread;\n\t    unsigned long\ttask_entry;\n\t    struct PCB *next;\n\t}tPCB;\n\t\n\tvoid my_schedule(void);\n\n这里主要是定义了进程控制块的参数。\n\n参数主要包括了：\n\n\n> - pid 进程标识符\n> - state 进程运行状态\n> - thread 进程寄存器的信息 包括了 堆栈sp指针和当前进程指令ip\n> - task_entry 进程运行代码的入口\n> - 下一个进程控制块（进程控制块是以链表的方式组织的）\n\n#### 2. mymain.h\n\n先说下my_process()\n这个函数是进程调度时会运行的代码\n\n\t\tvoid my_process(void)\n\t{\n\t    int i = 0;\n\t    while(1)\n\t    {\n\t        i++;\n\t        if(i%10000000 == 0)\n\t        {\n\t            printk(KERN_NOTICE \"this is process %d -\\n\",my_current_task->pid);\n\t            if(my_need_sched == 1)\n\t            {\n\t                my_need_sched = 0;\n\t        \t    my_schedule();\n\t        \t}\n\t        \tprintk(KERN_NOTICE \"this is process %d +\\n\",my_current_task->pid);\n\t        }     \n\t    }\n\n逻辑很简单，就是进程执行循环执行某个人物，当执行到i%10000000=0时，会进行调度。\n\n如果my_need_sched =1 会进行主动调度，执行调度函数 my_schedule()\n\n而这个 my_need_sched=1 是每次时钟中断发生时会改变一次，我们后面会看到\n\n接着分析，my_main.c中主要的\n\n\tvoid __init my_start_kernel(void)\n\t{\n\t\tint pid = 0;\n\t    int i;\n\t    /* Initialize process 0*/\n\t    task[pid].pid = pid;\n\t    task[pid].state = 0;/* -1 unrunnable, 0 runnable, >0 stopped */\n\t    task[pid].task_entry = task[pid].thread.ip = (unsigned long)my_process;\n\t    task[pid].thread.sp = (unsigned long)&task[pid].stack[KERNEL_STACK_SIZE-1];\n\t    task[pid].next = &task[pid];\n\t    /*fork more process */\n\t    for(i=1;i<MAX_TASK_NUM;i++)\n\t    {\n\t        memcpy(&task[i],&task[0],sizeof(tPCB));\n\t        task[i].pid = i;\n\t        task[i].state = -1;\n\t        task[i].thread.sp = (unsigned long)&task[i].stack[KERNEL_STACK_SIZE-1];\n\t        task[i].next = task[i-1].next;\n\t        task[i-1].next = &task[i];\n\t    }\n    /* start process 0 by task[0] */\n\t    /* start process 0 by task[0] */\n\t    pid = 0;\n\t    my_current_task = &task[pid];\n\t\tasm volatile(\n\t    \t\"movl %1,%%esp\\n\\t\" \t/* set task[pid].thread.sp to esp */\n\t    \t\"pushl %1\\n\\t\" \t        /* push ebp */\n\t    \t\"pushl %0\\n\\t\" \t        /* push task[pid].thread.ip */\n\t    \t\"ret\\n\\t\" \t            /* pop task[pid].thread.ip to eip */\n\t    \t\"popl %%ebp\\n\\t\"\n\t    \t: \n\t    \t: \"c\" (task[pid].thread.ip),\"d\" (task[pid].thread.sp)\t/* input c or d mean %ecx/%edx*/\n\t\t);\n\t}   \n\n前半部分比较简单。是初始化进程控制块，把他们连接在一起（这是一个循环链表），然后将当前进程my_current_task=task[0];\n\n之后的操作就该是执行该控制块了。有这段汇编实现（**重点**）\n\n\tasm volatile(\n\t\t    \t\"movl %1,%%esp\\n\\t\" \t/* set task[pid].thread.sp to esp */\n\t\t    \t\"pushl %1\\n\\t\" \t        /* push ebp */\n\t\t    \t\"pushl %0\\n\\t\" \t        /* push task[pid].thread.ip */\n\t\t    \t\"ret\\n\\t\" \t            /* pop task[pid].thread.ip to eip */\n\t\t    \t\"popl %%ebp\\n\\t\"\n\t\t    \t: \n\t\t    \t: \"c\" (task[pid].thread.ip),\"d\" (task[pid].thread.sp)\t/* input c or d mean %ecx/%edx*/\n\t\t\t);\n\n这里应该是进行三步：\n\n1.  切换esp\n2.  保存上一个堆栈框架的ebp并且将ebp=esp（相当于entry **这里没有ebp=esp 不够严谨**）\n3. 跳转到task[0]的执行流里（实现方式是先push到esp中，然后ret，当esp指向的元素pop到eip中）\n\n这样一个进程就开始执行了。\n\n#### 3. myinterrupt.c\n\n这里是时钟中断发生的处理函数：\n\n\t\tvoid my_timer_handler(void)\n\t{\n\t#if 1\n\t    if(time_count%1000 == 0 && my_need_sched != 1)\n\t    {\n\t        printk(KERN_NOTICE \">>>my_timer_handler here<<<\\n\");\n\t        my_need_sched = 1;\n\t    } \n\t    time_count ++ ;  \n\t#endif\n\t    return;  \t\n\t}\n\n主要的就是会修改 my_need_sched 这个值触发调度\n\nmy_schedule(void) 调度函数\n\n\ttPCB * next;\n    tPCB * prev;\n\n    if(my_current_task == NULL \n        || my_current_task->next == NULL)\n    {\n    \treturn;\n    }\n    printk(KERN_NOTICE \">>>my_schedule<<<\\n\");\n    /* schedule */\n    next = my_current_task->next;\n    prev = my_current_task;\n\n这一端代码的意思是\n\nnext 为下一个进程\n\nprev 为当前进程\n\n\tif(next->state == 0)/* -1 unrunnable, 0 runnable, >0 stopped */\n\t    {\n\t    \t/* switch to next process */\n\t    \tasm volatile(\t\n\t        \t\"pushl %%ebp\\n\\t\" \t    /* save ebp */\n\t        \t\"movl %%esp,%0\\n\\t\" \t/* save esp */\n\t        \t\"movl %2,%%esp\\n\\t\"     /* restore  esp */\n\t        \t\"movl $1f,%1\\n\\t\"       /* save eip */\t\n\t        \t\"pushl %3\\n\\t\" \n\t        \t\"ret\\n\\t\" \t            /* restore  eip */\n\t        \t\"1:\\t\"                  /* next process start here */\n\t        \t\"popl %%ebp\\n\\t\"\n\t        \t: \"=m\" (prev->thread.sp),\"=m\" (prev->thread.ip)\n\t        \t: \"m\" (next->thread.sp),\"m\" (next->thread.ip)\n\t    \t); \n\t    \tmy_current_task = next; \n\t    \tprintk(KERN_NOTICE \">>>switch %d to %d<<<\\n\",prev->pid,next->pid);   \t\n\t    }\n\t    else\n\t    {\n\t        next->state = 0;\n\t        my_current_task = next;\n\t        printk(KERN_NOTICE \">>>switch %d to %d<<<\\n\",prev->pid,next->pid);\n\t    \t/* switch to new process */\n\t    \tasm volatile(\t\n\t        \t\"pushl %%ebp\\n\\t\" \t    /* save ebp */\n\t        \t\"movl %%esp,%0\\n\\t\" \t/* save esp */\n\t        \t\"movl %2,%%esp\\n\\t\"     /* restore  esp */\n\t        \t\"movl %2,%%ebp\\n\\t\"     /* restore  ebp */\n\t        \t\"movl $1f,%1\\n\\t\"       /* save eip */\t\n\t        \t\"pushl %3\\n\\t\" \n\t        \t\"ret\\n\\t\" \t            /* restore  eip */\n\t        \t: \"=m\" (prev->thread.sp),\"=m\" (prev->thread.ip)\n\t        \t: \"m\" (next->thread.sp),\"m\" (next->thread.ip)\n\t    \t);          \n\t    }   \n\nnext->state 代表运行状态  =0 代表已经运行  =-1 代表 还没有运行\n\n当next进程还没有运行时 进程切换的代码是这样的：\n\n\tasm volatile(\t\n\t        \t\"pushl %%ebp\\n\\t\" \t    /* save ebp */\n\t        \t\"movl %%esp,%0\\n\\t\" \t/* save esp */\n\t        \t\"movl %2,%%esp\\n\\t\"     /* restore  esp */\n\t        \t\"movl %2,%%ebp\\n\\t\"     /* restore  ebp */\n\t        \t\"movl $1f,%1\\n\\t\"       /* save eip */\t\n\t        \t\"pushl %3\\n\\t\" \n\t        \t\"ret\\n\\t\" \t            /* restore  eip */\n\t        \t: \"=m\" (prev->thread.sp),\"=m\" (prev->thread.ip)\n\t        \t: \"m\" (next->thread.sp),\"m\" (next->thread.ip)\n\n步骤如下\n\n首先要保存现场： \n\n1. 保存ebp到当前进程的esp中 pushl %%ebp\\n\\t\n2. 保存当前esp的内容到 当前进程 movl %%esp,%0\n3.  保存eip movl $1f,%1 这里的$1f是下次运行时第一条指令的位置，代表为f （forward）向前方向上 1 标号 所指指令的地址。\n\n还有切换到当前进程的现场：\n\n1.  恢复esp。movl %2,%%esp\n2.  恢复ebp。movl %2,%%ebp  （**刚开始运行 ebp=esp**）\n\n最后跳转到next进程的执行流中:\n和之前一样\n\n\tpushl %3\n\tret   \n\n然后 ret的值就是my_process()这个函数的起始位置。开始执行该函数。\n\n然后 这样运行第一圈之后，又会回到task[0] 此时task[0]已经运行了。所以会执行一下汇编进行进程切换。\n\n\tasm volatile(\t\n\t        \t\"pushl %%ebp\\n\\t\" \t    /* save ebp */\n\t        \t\"movl %%esp,%0\\n\\t\" \t/* save esp */\n\t        \t\"movl %2,%%esp\\n\\t\"     /* restore  esp */\n\t        \t\"movl $1f,%1\\n\\t\"       /* save eip */\t\n\t        \t\"pushl %3\\n\\t\" \n\t        \t\"ret\\n\\t\" \t            /* restore  eip */\n\t        \t\"1:\\t\"                  /* next process start here */\n\t        \t\"popl %%ebp\\n\\t\"\n\t        \t: \"=m\" (prev->thread.sp),\"=m\" (prev->thread.ip)\n\t        \t: \"m\" (next->thread.sp),\"m\" (next->thread.ip)\n\t    \t); \n\n保存现场和恢复现场的部分是和之前一样的。\n除了恢复现场没有恢复ebp\n\n关键是还记得上一次我们保存 当前进程的eip的时候，保存的值是$1f嘛？\n所以 \n\n\tpushl %3\n\tret     \n要进入下一个进程的执行流时，此时的eip 为 1 标号所对应的指令\n\n\t1：popl %%ebp\n\n这样过程就完整了，恢复现场的工作完成了，ebp指向了正确的值。\n\n\n### 三、总结\n\n其实，整个过程最重要的就是理解函数调用栈的框架。\n\n这个框架大概是这样的\n\n![enter image description here](/linux2/end.png)\n\n保持这个框架的完整性即可\n\n### 四、补充\n\n- volatile 限定符 会把变量放在register中  执行流取的时候 要放到寄存器 放到内存容易出现问题\n- 如何 制作整个 mykernel 项目的\n\nmykernel 的制作涉及到了两个问题：\n\n1.  如何设置时钟中断\n2. 如何把控制权交给 mymain.c 中的  my_start_kernel\n\n其实两个问题都可以从  [mykernel_for_linux3.9.4sc.patch](https://github.com/mengning/mykernel/blob/master/mykernel_for_linux3.9.4sc.patch)\n中找到答案\n\n因为文件比较大 我就不贴出来了。。\n\n直接标记大概修改了那些地方：\n\n##### 1.和时钟中断有关 \n\n> - /arch/x86/kernel/time.c 中的 timer_interrupt（） (时钟中断处理函数 会调用my_timer_handler();)\n\n##### 2.和mymain.c相关\n> - /init/main.c 中的 start_kernel()\n\n##### 3.其他细节\n\n> - extern 需要的函数 如：在/arch/x86/kernel/time.c  extern void my_timer_handler(void);\n> - 编写需要的makefile 主要是 /mykernel/Makefile \n> - 同时还需要修改下根目录下的 总Makefile\n> - 还有README  (^_^)Y\n","slug":"Linux_2","published":1,"updated":"2016-03-31T16:52:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt5g0008679yundjijgh","content":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\" target=\"_blank\" rel=\"external\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><hr>\n<p>github项目：<a href=\"https://github.com/mengning/mykernel\" target=\"_blank\" rel=\"external\">Mykernel</a></p>\n<h3 id=\"一、步骤整理\"><a href=\"#一、步骤整理\" class=\"headerlink\" title=\"一、步骤整理\"></a>一、步骤整理</h3><p>请先在下载好<a href=\"https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.9.4.tar.xz\" target=\"_blank\" rel=\"external\">linux-3.9.4.tar.xz</a> </p>\n<ol>\n<li><p>安装 qemu</p>\n<pre><code>sudo apt-get install qemu # install QEMU\nsudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu\n</code></pre></li>\n<li><p>解压 linux</p>\n<pre><code>xz -d linux-3.9.4.tar.xz\ntar -xvf linux-3.9.4.tar\n</code></pre></li>\n<li><p>打内核补丁  <a href=\"https://github.com/mengning/mykernel/blob/master/mykernel_for_linux3.9.4sc.patch\" target=\"_blank\" rel=\"external\">mykernel_for_linux3.9.4sc.patch</a></p>\n<pre><code>patch -p1 &lt; ../mykernel_for_linux3.9.4sc.patch\n</code></pre></li>\n<li>编译运行 </li>\n</ol>\n<pre><code>make allnoconfig\nmake\nqemu -kernel arch/x86/boot/bzImage\n</code></pre><p>实验截图：</p>\n<p><img src=\"/linux2/lab2_1.png\" alt=\"enter image description here\"></p>\n<p><img src=\"/linux2/lab2_2.png\" alt=\"enter image description here\"></p>\n<p><img src=\"/linux2/lab2_3.png\" alt=\"enter image description here\"></p>\n<ol>\n<li>将 mypcb.h 、mymain.c、myinterrupt.c 放入mykernel 文件夹 并编译运行 </li>\n</ol>\n<p><img src=\"/linux2/lab2_4.png\" alt=\"enter image description here\"></p>\n<h3 id=\"二、内核代码执行过程\"><a href=\"#二、内核代码执行过程\" class=\"headerlink\" title=\"二、内核代码执行过程\"></a>二、内核代码执行过程</h3><p>核心代码主要由：mypcb.h 、mymain.c、myinterrupt.c三个文件构成</p>\n<h4 id=\"1-mypcb-h\"><a href=\"#1-mypcb-h\" class=\"headerlink\" title=\"1. mypcb.h\"></a>1. mypcb.h</h4><pre><code>#define MAX_TASK_NUM        4\n#define KERNEL_STACK_SIZE   1024*8\n\n/* CPU-specific state of this task */\nstruct Thread {\n    unsigned long        ip;\n    unsigned long        sp;\n};\n\ntypedef struct PCB{\n    int pid;\n    volatile long state;    /* -1 unrunnable, 0 runnable, &gt;0 stopped */\n    char stack[KERNEL_STACK_SIZE];\n    /* CPU-specific state of this task */\n    struct Thread thread;\n    unsigned long    task_entry;\n    struct PCB *next;\n}tPCB;\n\nvoid my_schedule(void);\n</code></pre><p>这里主要是定义了进程控制块的参数。</p>\n<p>参数主要包括了：</p>\n<blockquote>\n<ul>\n<li>pid 进程标识符</li>\n<li>state 进程运行状态</li>\n<li>thread 进程寄存器的信息 包括了 堆栈sp指针和当前进程指令ip</li>\n<li>task_entry 进程运行代码的入口</li>\n<li>下一个进程控制块（进程控制块是以链表的方式组织的）</li>\n</ul>\n</blockquote>\n<h4 id=\"2-mymain-h\"><a href=\"#2-mymain-h\" class=\"headerlink\" title=\"2. mymain.h\"></a>2. mymain.h</h4><p>先说下my_process()<br>这个函数是进程调度时会运行的代码</p>\n<pre><code>    void my_process(void)\n{\n    int i = 0;\n    while(1)\n    {\n        i++;\n        if(i%10000000 == 0)\n        {\n            printk(KERN_NOTICE &quot;this is process %d -\\n&quot;,my_current_task-&gt;pid);\n            if(my_need_sched == 1)\n            {\n                my_need_sched = 0;\n                my_schedule();\n            }\n            printk(KERN_NOTICE &quot;this is process %d +\\n&quot;,my_current_task-&gt;pid);\n        }     \n    }\n</code></pre><p>逻辑很简单，就是进程执行循环执行某个人物，当执行到i%10000000=0时，会进行调度。</p>\n<p>如果my_need_sched =1 会进行主动调度，执行调度函数 my_schedule()</p>\n<p>而这个 my_need_sched=1 是每次时钟中断发生时会改变一次，我们后面会看到</p>\n<p>接着分析，my_main.c中主要的</p>\n<pre><code>void __init my_start_kernel(void)\n{\n    int pid = 0;\n    int i;\n    /* Initialize process 0*/\n    task[pid].pid = pid;\n    task[pid].state = 0;/* -1 unrunnable, 0 runnable, &gt;0 stopped */\n    task[pid].task_entry = task[pid].thread.ip = (unsigned long)my_process;\n    task[pid].thread.sp = (unsigned long)&amp;task[pid].stack[KERNEL_STACK_SIZE-1];\n    task[pid].next = &amp;task[pid];\n    /*fork more process */\n    for(i=1;i&lt;MAX_TASK_NUM;i++)\n    {\n        memcpy(&amp;task[i],&amp;task[0],sizeof(tPCB));\n        task[i].pid = i;\n        task[i].state = -1;\n        task[i].thread.sp = (unsigned long)&amp;task[i].stack[KERNEL_STACK_SIZE-1];\n        task[i].next = task[i-1].next;\n        task[i-1].next = &amp;task[i];\n    }\n/* start process 0 by task[0] */\n    /* start process 0 by task[0] */\n    pid = 0;\n    my_current_task = &amp;task[pid];\n    asm volatile(\n        &quot;movl %1,%%esp\\n\\t&quot;     /* set task[pid].thread.sp to esp */\n        &quot;pushl %1\\n\\t&quot;             /* push ebp */\n        &quot;pushl %0\\n\\t&quot;             /* push task[pid].thread.ip */\n        &quot;ret\\n\\t&quot;                 /* pop task[pid].thread.ip to eip */\n        &quot;popl %%ebp\\n\\t&quot;\n        : \n        : &quot;c&quot; (task[pid].thread.ip),&quot;d&quot; (task[pid].thread.sp)    /* input c or d mean %ecx/%edx*/\n    );\n}   \n</code></pre><p>前半部分比较简单。是初始化进程控制块，把他们连接在一起（这是一个循环链表），然后将当前进程my_current_task=task[0];</p>\n<p>之后的操作就该是执行该控制块了。有这段汇编实现（<strong>重点</strong>）</p>\n<pre><code>asm volatile(\n            &quot;movl %1,%%esp\\n\\t&quot;     /* set task[pid].thread.sp to esp */\n            &quot;pushl %1\\n\\t&quot;             /* push ebp */\n            &quot;pushl %0\\n\\t&quot;             /* push task[pid].thread.ip */\n            &quot;ret\\n\\t&quot;                 /* pop task[pid].thread.ip to eip */\n            &quot;popl %%ebp\\n\\t&quot;\n            : \n            : &quot;c&quot; (task[pid].thread.ip),&quot;d&quot; (task[pid].thread.sp)    /* input c or d mean %ecx/%edx*/\n        );\n</code></pre><p>这里应该是进行三步：</p>\n<ol>\n<li>切换esp</li>\n<li>保存上一个堆栈框架的ebp并且将ebp=esp（相当于entry <strong>这里没有ebp=esp 不够严谨</strong>）</li>\n<li>跳转到task[0]的执行流里（实现方式是先push到esp中，然后ret，当esp指向的元素pop到eip中）</li>\n</ol>\n<p>这样一个进程就开始执行了。</p>\n<h4 id=\"3-myinterrupt-c\"><a href=\"#3-myinterrupt-c\" class=\"headerlink\" title=\"3. myinterrupt.c\"></a>3. myinterrupt.c</h4><p>这里是时钟中断发生的处理函数：</p>\n<pre><code>    void my_timer_handler(void)\n{\n#if 1\n    if(time_count%1000 == 0 &amp;&amp; my_need_sched != 1)\n    {\n        printk(KERN_NOTICE &quot;&gt;&gt;&gt;my_timer_handler here&lt;&lt;&lt;\\n&quot;);\n        my_need_sched = 1;\n    } \n    time_count ++ ;  \n#endif\n    return;      \n}\n</code></pre><p>主要的就是会修改 my_need_sched 这个值触发调度</p>\n<p>my_schedule(void) 调度函数</p>\n<pre><code>tPCB * next;\ntPCB * prev;\n\nif(my_current_task == NULL \n    || my_current_task-&gt;next == NULL)\n{\n    return;\n}\nprintk(KERN_NOTICE &quot;&gt;&gt;&gt;my_schedule&lt;&lt;&lt;\\n&quot;);\n/* schedule */\nnext = my_current_task-&gt;next;\nprev = my_current_task;\n</code></pre><p>这一端代码的意思是</p>\n<p>next 为下一个进程</p>\n<p>prev 为当前进程</p>\n<pre><code>if(next-&gt;state == 0)/* -1 unrunnable, 0 runnable, &gt;0 stopped */\n    {\n        /* switch to next process */\n        asm volatile(    \n            &quot;pushl %%ebp\\n\\t&quot;         /* save ebp */\n            &quot;movl %%esp,%0\\n\\t&quot;     /* save esp */\n            &quot;movl %2,%%esp\\n\\t&quot;     /* restore  esp */\n            &quot;movl $1f,%1\\n\\t&quot;       /* save eip */    \n            &quot;pushl %3\\n\\t&quot; \n            &quot;ret\\n\\t&quot;                 /* restore  eip */\n            &quot;1:\\t&quot;                  /* next process start here */\n            &quot;popl %%ebp\\n\\t&quot;\n            : &quot;=m&quot; (prev-&gt;thread.sp),&quot;=m&quot; (prev-&gt;thread.ip)\n            : &quot;m&quot; (next-&gt;thread.sp),&quot;m&quot; (next-&gt;thread.ip)\n        ); \n        my_current_task = next; \n        printk(KERN_NOTICE &quot;&gt;&gt;&gt;switch %d to %d&lt;&lt;&lt;\\n&quot;,prev-&gt;pid,next-&gt;pid);       \n    }\n    else\n    {\n        next-&gt;state = 0;\n        my_current_task = next;\n        printk(KERN_NOTICE &quot;&gt;&gt;&gt;switch %d to %d&lt;&lt;&lt;\\n&quot;,prev-&gt;pid,next-&gt;pid);\n        /* switch to new process */\n        asm volatile(    \n            &quot;pushl %%ebp\\n\\t&quot;         /* save ebp */\n            &quot;movl %%esp,%0\\n\\t&quot;     /* save esp */\n            &quot;movl %2,%%esp\\n\\t&quot;     /* restore  esp */\n            &quot;movl %2,%%ebp\\n\\t&quot;     /* restore  ebp */\n            &quot;movl $1f,%1\\n\\t&quot;       /* save eip */    \n            &quot;pushl %3\\n\\t&quot; \n            &quot;ret\\n\\t&quot;                 /* restore  eip */\n            : &quot;=m&quot; (prev-&gt;thread.sp),&quot;=m&quot; (prev-&gt;thread.ip)\n            : &quot;m&quot; (next-&gt;thread.sp),&quot;m&quot; (next-&gt;thread.ip)\n        );          \n    }   \n</code></pre><p>next-&gt;state 代表运行状态  =0 代表已经运行  =-1 代表 还没有运行</p>\n<p>当next进程还没有运行时 进程切换的代码是这样的：</p>\n<pre><code>asm volatile(    \n            &quot;pushl %%ebp\\n\\t&quot;         /* save ebp */\n            &quot;movl %%esp,%0\\n\\t&quot;     /* save esp */\n            &quot;movl %2,%%esp\\n\\t&quot;     /* restore  esp */\n            &quot;movl %2,%%ebp\\n\\t&quot;     /* restore  ebp */\n            &quot;movl $1f,%1\\n\\t&quot;       /* save eip */    \n            &quot;pushl %3\\n\\t&quot; \n            &quot;ret\\n\\t&quot;                 /* restore  eip */\n            : &quot;=m&quot; (prev-&gt;thread.sp),&quot;=m&quot; (prev-&gt;thread.ip)\n            : &quot;m&quot; (next-&gt;thread.sp),&quot;m&quot; (next-&gt;thread.ip)\n</code></pre><p>步骤如下</p>\n<p>首先要保存现场： </p>\n<ol>\n<li>保存ebp到当前进程的esp中 pushl %%ebp\\n\\t</li>\n<li>保存当前esp的内容到 当前进程 movl %%esp,%0</li>\n<li>保存eip movl $1f,%1 这里的$1f是下次运行时第一条指令的位置，代表为f （forward）向前方向上 1 标号 所指指令的地址。</li>\n</ol>\n<p>还有切换到当前进程的现场：</p>\n<ol>\n<li>恢复esp。movl %2,%%esp</li>\n<li>恢复ebp。movl %2,%%ebp  （<strong>刚开始运行 ebp=esp</strong>）</li>\n</ol>\n<p>最后跳转到next进程的执行流中:<br>和之前一样</p>\n<pre><code>pushl %3\nret   \n</code></pre><p>然后 ret的值就是my_process()这个函数的起始位置。开始执行该函数。</p>\n<p>然后 这样运行第一圈之后，又会回到task[0] 此时task[0]已经运行了。所以会执行一下汇编进行进程切换。</p>\n<pre><code>asm volatile(    \n            &quot;pushl %%ebp\\n\\t&quot;         /* save ebp */\n            &quot;movl %%esp,%0\\n\\t&quot;     /* save esp */\n            &quot;movl %2,%%esp\\n\\t&quot;     /* restore  esp */\n            &quot;movl $1f,%1\\n\\t&quot;       /* save eip */    \n            &quot;pushl %3\\n\\t&quot; \n            &quot;ret\\n\\t&quot;                 /* restore  eip */\n            &quot;1:\\t&quot;                  /* next process start here */\n            &quot;popl %%ebp\\n\\t&quot;\n            : &quot;=m&quot; (prev-&gt;thread.sp),&quot;=m&quot; (prev-&gt;thread.ip)\n            : &quot;m&quot; (next-&gt;thread.sp),&quot;m&quot; (next-&gt;thread.ip)\n        ); \n</code></pre><p>保存现场和恢复现场的部分是和之前一样的。<br>除了恢复现场没有恢复ebp</p>\n<p>关键是还记得上一次我们保存 当前进程的eip的时候，保存的值是$1f嘛？<br>所以 </p>\n<pre><code>pushl %3\nret     \n</code></pre><p>要进入下一个进程的执行流时，此时的eip 为 1 标号所对应的指令</p>\n<pre><code>1：popl %%ebp\n</code></pre><p>这样过程就完整了，恢复现场的工作完成了，ebp指向了正确的值。</p>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><p>其实，整个过程最重要的就是理解函数调用栈的框架。</p>\n<p>这个框架大概是这样的</p>\n<p><img src=\"/linux2/end.png\" alt=\"enter image description here\"></p>\n<p>保持这个框架的完整性即可</p>\n<h3 id=\"四、补充\"><a href=\"#四、补充\" class=\"headerlink\" title=\"四、补充\"></a>四、补充</h3><ul>\n<li>volatile 限定符 会把变量放在register中  执行流取的时候 要放到寄存器 放到内存容易出现问题</li>\n<li>如何 制作整个 mykernel 项目的</li>\n</ul>\n<p>mykernel 的制作涉及到了两个问题：</p>\n<ol>\n<li>如何设置时钟中断</li>\n<li>如何把控制权交给 mymain.c 中的  my_start_kernel</li>\n</ol>\n<p>其实两个问题都可以从  <a href=\"https://github.com/mengning/mykernel/blob/master/mykernel_for_linux3.9.4sc.patch\" target=\"_blank\" rel=\"external\">mykernel_for_linux3.9.4sc.patch</a><br>中找到答案</p>\n<p>因为文件比较大 我就不贴出来了。。</p>\n<p>直接标记大概修改了那些地方：</p>\n<h5 id=\"1-和时钟中断有关\"><a href=\"#1-和时钟中断有关\" class=\"headerlink\" title=\"1.和时钟中断有关\"></a>1.和时钟中断有关</h5><blockquote>\n<ul>\n<li>/arch/x86/kernel/time.c 中的 timer_interrupt（） (时钟中断处理函数 会调用my_timer_handler();)</li>\n</ul>\n</blockquote>\n<h5 id=\"2-和mymain-c相关\"><a href=\"#2-和mymain-c相关\" class=\"headerlink\" title=\"2.和mymain.c相关\"></a>2.和mymain.c相关</h5><blockquote>\n<ul>\n<li>/init/main.c 中的 start_kernel()</li>\n</ul>\n</blockquote>\n<h5 id=\"3-其他细节\"><a href=\"#3-其他细节\" class=\"headerlink\" title=\"3.其他细节\"></a>3.其他细节</h5><blockquote>\n<ul>\n<li>extern 需要的函数 如：在/arch/x86/kernel/time.c  extern void my_timer_handler(void);</li>\n<li>编写需要的makefile 主要是 /mykernel/Makefile </li>\n<li>同时还需要修改下根目录下的 总Makefile</li>\n<li>还有README  (^_^)Y</li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><hr>\n<p>github项目：<a href=\"https://github.com/mengning/mykernel\">Mykernel</a></p>\n<h3 id=\"一、步骤整理\"><a href=\"#一、步骤整理\" class=\"headerlink\" title=\"一、步骤整理\"></a>一、步骤整理</h3><p>请先在下载好<a href=\"https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.9.4.tar.xz\">linux-3.9.4.tar.xz</a> </p>\n<ol>\n<li><p>安装 qemu</p>\n<pre><code>sudo apt-get install qemu # install QEMU\nsudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu\n</code></pre></li>\n<li><p>解压 linux</p>\n<pre><code>xz -d linux-3.9.4.tar.xz\ntar -xvf linux-3.9.4.tar\n</code></pre></li>\n<li><p>打内核补丁  <a href=\"https://github.com/mengning/mykernel/blob/master/mykernel_for_linux3.9.4sc.patch\">mykernel_for_linux3.9.4sc.patch</a></p>\n<pre><code>patch -p1 &lt; ../mykernel_for_linux3.9.4sc.patch\n</code></pre></li>\n<li>编译运行 </li>\n</ol>\n<pre><code>make allnoconfig\nmake\nqemu -kernel arch/x86/boot/bzImage\n</code></pre><p>实验截图：</p>\n<p><img src=\"/linux2/lab2_1.png\" alt=\"enter image description here\"></p>\n<p><img src=\"/linux2/lab2_2.png\" alt=\"enter image description here\"></p>\n<p><img src=\"/linux2/lab2_3.png\" alt=\"enter image description here\"></p>\n<ol>\n<li>将 mypcb.h 、mymain.c、myinterrupt.c 放入mykernel 文件夹 并编译运行 </li>\n</ol>\n<p><img src=\"/linux2/lab2_4.png\" alt=\"enter image description here\"></p>\n<h3 id=\"二、内核代码执行过程\"><a href=\"#二、内核代码执行过程\" class=\"headerlink\" title=\"二、内核代码执行过程\"></a>二、内核代码执行过程</h3><p>核心代码主要由：mypcb.h 、mymain.c、myinterrupt.c三个文件构成</p>\n<h4 id=\"1-mypcb-h\"><a href=\"#1-mypcb-h\" class=\"headerlink\" title=\"1. mypcb.h\"></a>1. mypcb.h</h4><pre><code>#define MAX_TASK_NUM        4\n#define KERNEL_STACK_SIZE   1024*8\n\n/* CPU-specific state of this task */\nstruct Thread {\n    unsigned long        ip;\n    unsigned long        sp;\n};\n\ntypedef struct PCB{\n    int pid;\n    volatile long state;    /* -1 unrunnable, 0 runnable, &gt;0 stopped */\n    char stack[KERNEL_STACK_SIZE];\n    /* CPU-specific state of this task */\n    struct Thread thread;\n    unsigned long    task_entry;\n    struct PCB *next;\n}tPCB;\n\nvoid my_schedule(void);\n</code></pre><p>这里主要是定义了进程控制块的参数。</p>\n<p>参数主要包括了：</p>\n<blockquote>\n<ul>\n<li>pid 进程标识符</li>\n<li>state 进程运行状态</li>\n<li>thread 进程寄存器的信息 包括了 堆栈sp指针和当前进程指令ip</li>\n<li>task_entry 进程运行代码的入口</li>\n<li>下一个进程控制块（进程控制块是以链表的方式组织的）</li>\n</ul>\n</blockquote>\n<h4 id=\"2-mymain-h\"><a href=\"#2-mymain-h\" class=\"headerlink\" title=\"2. mymain.h\"></a>2. mymain.h</h4><p>先说下my_process()<br>这个函数是进程调度时会运行的代码</p>\n<pre><code>    void my_process(void)\n{\n    int i = 0;\n    while(1)\n    {\n        i++;\n        if(i%10000000 == 0)\n        {\n            printk(KERN_NOTICE &quot;this is process %d -\\n&quot;,my_current_task-&gt;pid);\n            if(my_need_sched == 1)\n            {\n                my_need_sched = 0;\n                my_schedule();\n            }\n            printk(KERN_NOTICE &quot;this is process %d +\\n&quot;,my_current_task-&gt;pid);\n        }     \n    }\n</code></pre><p>逻辑很简单，就是进程执行循环执行某个人物，当执行到i%10000000=0时，会进行调度。</p>\n<p>如果my_need_sched =1 会进行主动调度，执行调度函数 my_schedule()</p>\n<p>而这个 my_need_sched=1 是每次时钟中断发生时会改变一次，我们后面会看到</p>\n<p>接着分析，my_main.c中主要的</p>\n<pre><code>void __init my_start_kernel(void)\n{\n    int pid = 0;\n    int i;\n    /* Initialize process 0*/\n    task[pid].pid = pid;\n    task[pid].state = 0;/* -1 unrunnable, 0 runnable, &gt;0 stopped */\n    task[pid].task_entry = task[pid].thread.ip = (unsigned long)my_process;\n    task[pid].thread.sp = (unsigned long)&amp;task[pid].stack[KERNEL_STACK_SIZE-1];\n    task[pid].next = &amp;task[pid];\n    /*fork more process */\n    for(i=1;i&lt;MAX_TASK_NUM;i++)\n    {\n        memcpy(&amp;task[i],&amp;task[0],sizeof(tPCB));\n        task[i].pid = i;\n        task[i].state = -1;\n        task[i].thread.sp = (unsigned long)&amp;task[i].stack[KERNEL_STACK_SIZE-1];\n        task[i].next = task[i-1].next;\n        task[i-1].next = &amp;task[i];\n    }\n/* start process 0 by task[0] */\n    /* start process 0 by task[0] */\n    pid = 0;\n    my_current_task = &amp;task[pid];\n    asm volatile(\n        &quot;movl %1,%%esp\\n\\t&quot;     /* set task[pid].thread.sp to esp */\n        &quot;pushl %1\\n\\t&quot;             /* push ebp */\n        &quot;pushl %0\\n\\t&quot;             /* push task[pid].thread.ip */\n        &quot;ret\\n\\t&quot;                 /* pop task[pid].thread.ip to eip */\n        &quot;popl %%ebp\\n\\t&quot;\n        : \n        : &quot;c&quot; (task[pid].thread.ip),&quot;d&quot; (task[pid].thread.sp)    /* input c or d mean %ecx/%edx*/\n    );\n}   \n</code></pre><p>前半部分比较简单。是初始化进程控制块，把他们连接在一起（这是一个循环链表），然后将当前进程my_current_task=task[0];</p>\n<p>之后的操作就该是执行该控制块了。有这段汇编实现（<strong>重点</strong>）</p>\n<pre><code>asm volatile(\n            &quot;movl %1,%%esp\\n\\t&quot;     /* set task[pid].thread.sp to esp */\n            &quot;pushl %1\\n\\t&quot;             /* push ebp */\n            &quot;pushl %0\\n\\t&quot;             /* push task[pid].thread.ip */\n            &quot;ret\\n\\t&quot;                 /* pop task[pid].thread.ip to eip */\n            &quot;popl %%ebp\\n\\t&quot;\n            : \n            : &quot;c&quot; (task[pid].thread.ip),&quot;d&quot; (task[pid].thread.sp)    /* input c or d mean %ecx/%edx*/\n        );\n</code></pre><p>这里应该是进行三步：</p>\n<ol>\n<li>切换esp</li>\n<li>保存上一个堆栈框架的ebp并且将ebp=esp（相当于entry <strong>这里没有ebp=esp 不够严谨</strong>）</li>\n<li>跳转到task[0]的执行流里（实现方式是先push到esp中，然后ret，当esp指向的元素pop到eip中）</li>\n</ol>\n<p>这样一个进程就开始执行了。</p>\n<h4 id=\"3-myinterrupt-c\"><a href=\"#3-myinterrupt-c\" class=\"headerlink\" title=\"3. myinterrupt.c\"></a>3. myinterrupt.c</h4><p>这里是时钟中断发生的处理函数：</p>\n<pre><code>    void my_timer_handler(void)\n{\n#if 1\n    if(time_count%1000 == 0 &amp;&amp; my_need_sched != 1)\n    {\n        printk(KERN_NOTICE &quot;&gt;&gt;&gt;my_timer_handler here&lt;&lt;&lt;\\n&quot;);\n        my_need_sched = 1;\n    } \n    time_count ++ ;  \n#endif\n    return;      \n}\n</code></pre><p>主要的就是会修改 my_need_sched 这个值触发调度</p>\n<p>my_schedule(void) 调度函数</p>\n<pre><code>tPCB * next;\ntPCB * prev;\n\nif(my_current_task == NULL \n    || my_current_task-&gt;next == NULL)\n{\n    return;\n}\nprintk(KERN_NOTICE &quot;&gt;&gt;&gt;my_schedule&lt;&lt;&lt;\\n&quot;);\n/* schedule */\nnext = my_current_task-&gt;next;\nprev = my_current_task;\n</code></pre><p>这一端代码的意思是</p>\n<p>next 为下一个进程</p>\n<p>prev 为当前进程</p>\n<pre><code>if(next-&gt;state == 0)/* -1 unrunnable, 0 runnable, &gt;0 stopped */\n    {\n        /* switch to next process */\n        asm volatile(    \n            &quot;pushl %%ebp\\n\\t&quot;         /* save ebp */\n            &quot;movl %%esp,%0\\n\\t&quot;     /* save esp */\n            &quot;movl %2,%%esp\\n\\t&quot;     /* restore  esp */\n            &quot;movl $1f,%1\\n\\t&quot;       /* save eip */    \n            &quot;pushl %3\\n\\t&quot; \n            &quot;ret\\n\\t&quot;                 /* restore  eip */\n            &quot;1:\\t&quot;                  /* next process start here */\n            &quot;popl %%ebp\\n\\t&quot;\n            : &quot;=m&quot; (prev-&gt;thread.sp),&quot;=m&quot; (prev-&gt;thread.ip)\n            : &quot;m&quot; (next-&gt;thread.sp),&quot;m&quot; (next-&gt;thread.ip)\n        ); \n        my_current_task = next; \n        printk(KERN_NOTICE &quot;&gt;&gt;&gt;switch %d to %d&lt;&lt;&lt;\\n&quot;,prev-&gt;pid,next-&gt;pid);       \n    }\n    else\n    {\n        next-&gt;state = 0;\n        my_current_task = next;\n        printk(KERN_NOTICE &quot;&gt;&gt;&gt;switch %d to %d&lt;&lt;&lt;\\n&quot;,prev-&gt;pid,next-&gt;pid);\n        /* switch to new process */\n        asm volatile(    \n            &quot;pushl %%ebp\\n\\t&quot;         /* save ebp */\n            &quot;movl %%esp,%0\\n\\t&quot;     /* save esp */\n            &quot;movl %2,%%esp\\n\\t&quot;     /* restore  esp */\n            &quot;movl %2,%%ebp\\n\\t&quot;     /* restore  ebp */\n            &quot;movl $1f,%1\\n\\t&quot;       /* save eip */    \n            &quot;pushl %3\\n\\t&quot; \n            &quot;ret\\n\\t&quot;                 /* restore  eip */\n            : &quot;=m&quot; (prev-&gt;thread.sp),&quot;=m&quot; (prev-&gt;thread.ip)\n            : &quot;m&quot; (next-&gt;thread.sp),&quot;m&quot; (next-&gt;thread.ip)\n        );          \n    }   \n</code></pre><p>next-&gt;state 代表运行状态  =0 代表已经运行  =-1 代表 还没有运行</p>\n<p>当next进程还没有运行时 进程切换的代码是这样的：</p>\n<pre><code>asm volatile(    \n            &quot;pushl %%ebp\\n\\t&quot;         /* save ebp */\n            &quot;movl %%esp,%0\\n\\t&quot;     /* save esp */\n            &quot;movl %2,%%esp\\n\\t&quot;     /* restore  esp */\n            &quot;movl %2,%%ebp\\n\\t&quot;     /* restore  ebp */\n            &quot;movl $1f,%1\\n\\t&quot;       /* save eip */    \n            &quot;pushl %3\\n\\t&quot; \n            &quot;ret\\n\\t&quot;                 /* restore  eip */\n            : &quot;=m&quot; (prev-&gt;thread.sp),&quot;=m&quot; (prev-&gt;thread.ip)\n            : &quot;m&quot; (next-&gt;thread.sp),&quot;m&quot; (next-&gt;thread.ip)\n</code></pre><p>步骤如下</p>\n<p>首先要保存现场： </p>\n<ol>\n<li>保存ebp到当前进程的esp中 pushl %%ebp\\n\\t</li>\n<li>保存当前esp的内容到 当前进程 movl %%esp,%0</li>\n<li>保存eip movl $1f,%1 这里的$1f是下次运行时第一条指令的位置，代表为f （forward）向前方向上 1 标号 所指指令的地址。</li>\n</ol>\n<p>还有切换到当前进程的现场：</p>\n<ol>\n<li>恢复esp。movl %2,%%esp</li>\n<li>恢复ebp。movl %2,%%ebp  （<strong>刚开始运行 ebp=esp</strong>）</li>\n</ol>\n<p>最后跳转到next进程的执行流中:<br>和之前一样</p>\n<pre><code>pushl %3\nret   \n</code></pre><p>然后 ret的值就是my_process()这个函数的起始位置。开始执行该函数。</p>\n<p>然后 这样运行第一圈之后，又会回到task[0] 此时task[0]已经运行了。所以会执行一下汇编进行进程切换。</p>\n<pre><code>asm volatile(    \n            &quot;pushl %%ebp\\n\\t&quot;         /* save ebp */\n            &quot;movl %%esp,%0\\n\\t&quot;     /* save esp */\n            &quot;movl %2,%%esp\\n\\t&quot;     /* restore  esp */\n            &quot;movl $1f,%1\\n\\t&quot;       /* save eip */    \n            &quot;pushl %3\\n\\t&quot; \n            &quot;ret\\n\\t&quot;                 /* restore  eip */\n            &quot;1:\\t&quot;                  /* next process start here */\n            &quot;popl %%ebp\\n\\t&quot;\n            : &quot;=m&quot; (prev-&gt;thread.sp),&quot;=m&quot; (prev-&gt;thread.ip)\n            : &quot;m&quot; (next-&gt;thread.sp),&quot;m&quot; (next-&gt;thread.ip)\n        ); \n</code></pre><p>保存现场和恢复现场的部分是和之前一样的。<br>除了恢复现场没有恢复ebp</p>\n<p>关键是还记得上一次我们保存 当前进程的eip的时候，保存的值是$1f嘛？<br>所以 </p>\n<pre><code>pushl %3\nret     \n</code></pre><p>要进入下一个进程的执行流时，此时的eip 为 1 标号所对应的指令</p>\n<pre><code>1：popl %%ebp\n</code></pre><p>这样过程就完整了，恢复现场的工作完成了，ebp指向了正确的值。</p>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><p>其实，整个过程最重要的就是理解函数调用栈的框架。</p>\n<p>这个框架大概是这样的</p>\n<p><img src=\"/linux2/end.png\" alt=\"enter image description here\"></p>\n<p>保持这个框架的完整性即可</p>\n<h3 id=\"四、补充\"><a href=\"#四、补充\" class=\"headerlink\" title=\"四、补充\"></a>四、补充</h3><ul>\n<li>volatile 限定符 会把变量放在register中  执行流取的时候 要放到寄存器 放到内存容易出现问题</li>\n<li>如何 制作整个 mykernel 项目的</li>\n</ul>\n<p>mykernel 的制作涉及到了两个问题：</p>\n<ol>\n<li>如何设置时钟中断</li>\n<li>如何把控制权交给 mymain.c 中的  my_start_kernel</li>\n</ol>\n<p>其实两个问题都可以从  <a href=\"https://github.com/mengning/mykernel/blob/master/mykernel_for_linux3.9.4sc.patch\">mykernel_for_linux3.9.4sc.patch</a><br>中找到答案</p>\n<p>因为文件比较大 我就不贴出来了。。</p>\n<p>直接标记大概修改了那些地方：</p>\n<h5 id=\"1-和时钟中断有关\"><a href=\"#1-和时钟中断有关\" class=\"headerlink\" title=\"1.和时钟中断有关\"></a>1.和时钟中断有关</h5><blockquote>\n<ul>\n<li>/arch/x86/kernel/time.c 中的 timer_interrupt（） (时钟中断处理函数 会调用my_timer_handler();)</li>\n</ul>\n</blockquote>\n<h5 id=\"2-和mymain-c相关\"><a href=\"#2-和mymain-c相关\" class=\"headerlink\" title=\"2.和mymain.c相关\"></a>2.和mymain.c相关</h5><blockquote>\n<ul>\n<li>/init/main.c 中的 start_kernel()</li>\n</ul>\n</blockquote>\n<h5 id=\"3-其他细节\"><a href=\"#3-其他细节\" class=\"headerlink\" title=\"3.其他细节\"></a>3.其他细节</h5><blockquote>\n<ul>\n<li>extern 需要的函数 如：在/arch/x86/kernel/time.c  extern void my_timer_handler(void);</li>\n<li>编写需要的makefile 主要是 /mykernel/Makefile </li>\n<li>同时还需要修改下根目录下的 总Makefile</li>\n<li>还有README  (^_^)Y</li>\n</ul>\n</blockquote>\n"},{"title":"Linux内核分析作业3：跟踪分析Linux内核的启动过程","date":"2016-03-30T16:50:15.000Z","_content":"\n\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n---\n\n### 一、实验步骤整理\n\n#### 1.下载Linux-3.18.6\n\t\n[Linux-3.18.6.tar.xz下载地址](https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.18.6.tar.xz)\n\t\n\n#### 2.解压Linux\n\n\t\txz -d linux-3.18.6.tar.xz\n\t\ttar -xvf linux-3.18.6.tar\n\n查看项目文件夹：\n\n![enter image description here](/linux3/lab3_1.png)\n\n\n#### 3.设置编译选项并编译内核\n\n设置成i386的配置：\n\t\t\n\tmake i386_defconfig \n\n截图：\n\n![enter image description here](/linux3/lab3_2.png)\n\n进入图像化配置界面：\n\n\tmake menuconfig\n\n并设置成调试信息开启：\n\n\tkernel hacking—>\n\t[*] compile the kernel with debug info\n\n截图：\n\n![enter image description here](/linux3/lab3_5.png)\n\n最后编译（等待若干时间后）：\n\n\tmake\n\n#### make menuconfig 遇到的问题：\n\n- 提示 “unable to find ncurses libraries ...”\n\n![enter image description here](/linux3/bug1.png)\n\n解决办法：安装 libncurses5-dev  \n\n\tsudo apt-get install libncurses5-dev\n\n- Your display is too small to run menuconfig\n\n![enter image description here](/linux3/bug2.png)\n\n解决方法：直接把窗口最大化就行了！\n\n#### 4.制作根文件系统\n\n\t\tcd ~/LinuxKernel/\n\t\tmkdir rootfs\n\t\tgit clone  https://github.com/mengning/menu.git\n\t\tcd menu\n\t\tgcc -o init linktable.c menu.c test.c -m32 -static –lpthread\n\t\t\n\t\tcd ../rootfs\n\t\tcp ../menu/init ./\n\t\tfind . | cpio -o -Hnewc |gzip -9 > ../rootfs.img\n\n（注：最后一步实际上是有三个部分组成 find命令 和cpio命令和 gzip命令 cpio是备份归档的命令，gzip是压缩）\n\n#### 5.运行menuOS 并进行设置调试\n\n启动：\n\n\tqemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img\n\t\t\n运行截图：\n\n![enter image description here](/linux3/lab3_4.png)\n\n启动调试：\n\n\tqemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -s -S\n\n注：\n\n>  -S freeze CPU at startup (use ’c’ to start execution) 第一开始运行时停住\n>  \n>  -s shorthand for -gdb tcp::1234 若不想使用1234端口，则可以使用-gdb tcp:xxxx来取代-s选项\n\n再开启另外一个shell，运行gdb\n\n\tgdb\n\t\n\t(gdb)file linux-3.18.6/vmlinux # 在gdb界面中targe remote之前加载符号表 \n\t\n\t(gdb)target remote:1234 # 建立gdb和gdbserver之间的连接,按c 让qemu上的Linux继续运行 \n\t\n\t(gdb)break start_kernel # 断点的设置可以在target remote之前，也可以在之后 \n\n\t(gdb)list 查看源代码\n\t\n\t(gdb)continue 继续运行到下一个断点\n\n截图：\n\t\n![enter image description here](/linux3/lab3_7.png)\t\n\t\n\n### 二、启动过程分析 \n\n\n\n整体上看，启动流程大致是这样的：\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"./linux3/start1.gif\"  />\n\n</div>\n\n加电或者复位是先从bios启动，bios完成基本的硬件自检和环境初始化后，将bootloader（linux是grub，windows是ntloader）拷贝到内存。\n\n然后执行bootloader，bootloader会进一步初始化，读取硬件信息，加载分区表，初始化中断向量表以及初始化页表等一系列初始化真正内核启动代码运行环境的操作，最后通过b start_kernel，跳转并执行start_kernel\n\nstart_kernel 的主要功能是\n进一步完成的存储管理、设备管理、文件管理、进程管理等任务的初始化\n\n这一块的代码相当复杂，直接mark下基本的：\n\n- tick_init();  //时钟源初始化\n\n- setup_arch（）; //最后一点和体系结构相关的初始化，开启mmu，初始化内存结构段表，页表啥的\n\n- init_IRQ（）; //对中断向量表的初始化\n\n- trap_init（）；//进一步初始化硬件中断，主要是中断链表，中断处理函数\n\n- sched_init（） //和进程调度相关的初始化\n\n- time_init（）//定时器的初始化\n\n- console_init（）  //终端初始化，tty\n\n- vfs_caches_init_early(); //虚拟文件系统初始化，后面挂载根文件系统用\n\n主要分析下 rest_init()\n\n\n\tstatic noinline void __init_refok rest_init(void)\n\t{\n\t\tint pid;\n\t\n\t\trcu_scheduler_starting();\n\n\t\tkernel_thread(kernel_init, NULL, CLONE_FS);\n\t\tnuma_default_policy();\n\t\tpid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n\t\trcu_read_lock();\n\t\tkthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);\n\t\trcu_read_unlock();\n\t\tcomplete(&kthreadd_done);\n\n\t\tinit_idle_bootup_task(current);\n\t\tschedule_preempt_disabled();\n\t\t\n\t\tcpu_startup_entry(CPUHP_ONLINE);\n\t}\n\n**rcu\\_scheduler_starting()**\n\n看了解释，这个函数是完成schedule最后的初始化工作，就是打开对RCU锁的检测，因为后面也会用到。RCU是一个高性能的读写锁，具体的请参考：[Linux 2.6内核中新的锁机制--RCU](https://www.ibm.com/developerworks/cn/linux/l-rcu/)\n\n **kernel_thread(kernel_init, NULL, CLONE_FS);**\n\n\n启动一个内核线程，这个内核线程的执行体是kernel_init（）\n\n他的第一句话就是kernel_init_freeable(void) 中的\n\n **wait_for_completion(&kthreadd_done);**\n\n意思是需要等待kthreadd_done这个信号量释放，在之后的代码中才会释放。因此我们先往下看\n\n **numa_default_policy();**\n\n设定NUMA系统的内存访问策略为默认\n这里的NUMA 是[非均匀访存模型](https://zh.wikipedia.org/wiki/%E9%9D%9E%E5%9D%87%E5%8C%80%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%9E%8B)，目测和SMP有关\n\n **pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);**\n\n\n这里又会创建一个[kthreadd](http://blog.csdn.net/lchjustc/article/details/6910663)内核线程，这个线程首先会根据kthread_create_list 循环创建其他内核线程，然后会通过该线程管理和调度别的内核线程（貌似又被称为worker_thread,好像还和中断处理的下半部分有关了，mark下回头看）\n\n\trcu_read_lock();\n\tkthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);\n\trcu_read_unlock();\n\tcomplete(&kthreadd_done);\n\n这就是可以理解为将threadd根据kthread_create_list初始化的内核线程链表赋值给kthreadd_task\n\n **kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);**\n\n作用是通过pid来查找其对应的task_struct的结构体 \n可以猜到 task_struct肯定是链表\n\n剩下的内容就是start_kernel如何沦为idle进程：(●'◡'●)\n\n\tinit_idle_bootup_task(current);\n\tschedule_preempt_disabled();  //关调度抢占\n\tcpu_startup_entry(CPUHP_ONLINE);\n\n **init_idle_bootup_task(current);**  将当前进程也就是0号进程init_task 的[sched_class](http://home.ustc.edu.cn/~hchunhui/linux_sched.html) 设置成 idle 大概意思应该是调度时机为idle，即cpu空闲时调度\n\n **cpu_startup_entry(CPUHP_ONLINE);**\n\n这个老师分析过了。最后会进入/linux-3.18.6/kernel/sched/idle.c 中的\n**static void cpu_idle_loop(void)**\n这是一个死循环。\ninit_task完全堕落成0号进程了。\n\n回到之前的 kernel_init \n\n前面会进行很多初始化工作，内存的，SMP的，锁检测的。\n\n比较重要的是 **do_basic_setup()**;  里面涉及到了一系列驱动程序的加载 \n\n之后会进行一系列复杂的根文件系统加载工作，先创建虚拟文件系统rootfs，然后根据不同的文件系统类型和格式，会有不同的加载根文件系统。\n\n最终他会启动开始运行init程序，也就是系统启动时会自动加载的程序，\n如果你没有在启动参数里设置（execute_command中没有），那么最终会\n\n\trun_init_process(\"/sbin/init\");\n    run_init_process(\"/etc/init\");\n    run_init_process(\"/bin/init\");\n    run_init_process(\"/bin/sh\");\n\n在这四个默认位置寻找init程序，如果没有，则内核panic\n\n\t panic(\"No init found. Try passing init= option to kernel. \"\n     \"See Linux Documentation/init.txt for guidance.\");\n\n到这里基本上就都结束了。\n\n\n### 三、 总结\n\nLinux内核启动流程水太深了。\n\n但是 我们要明白 1号进程为init进程，0号进程为idle进程，是原来init_task变成的。\n\n-----\n\n附：\n\n相关链接已经贴到文中\n\n \n顺便提一下  发现 [IBM\n developerWorks](https://www.ibm.com/developerworks/cn/) 中有很多很好很有深度的资料！ 强烈推荐！\n","source":"_posts/Linux_3.md","raw":"---\ntitle: Linux内核分析作业3：跟踪分析Linux内核的启动过程\ndate: 2016-03-31 01:50:15\ntags: linux\ncategories: linux内核分析\n---\n\n\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n---\n\n### 一、实验步骤整理\n\n#### 1.下载Linux-3.18.6\n\t\n[Linux-3.18.6.tar.xz下载地址](https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.18.6.tar.xz)\n\t\n\n#### 2.解压Linux\n\n\t\txz -d linux-3.18.6.tar.xz\n\t\ttar -xvf linux-3.18.6.tar\n\n查看项目文件夹：\n\n![enter image description here](/linux3/lab3_1.png)\n\n\n#### 3.设置编译选项并编译内核\n\n设置成i386的配置：\n\t\t\n\tmake i386_defconfig \n\n截图：\n\n![enter image description here](/linux3/lab3_2.png)\n\n进入图像化配置界面：\n\n\tmake menuconfig\n\n并设置成调试信息开启：\n\n\tkernel hacking—>\n\t[*] compile the kernel with debug info\n\n截图：\n\n![enter image description here](/linux3/lab3_5.png)\n\n最后编译（等待若干时间后）：\n\n\tmake\n\n#### make menuconfig 遇到的问题：\n\n- 提示 “unable to find ncurses libraries ...”\n\n![enter image description here](/linux3/bug1.png)\n\n解决办法：安装 libncurses5-dev  \n\n\tsudo apt-get install libncurses5-dev\n\n- Your display is too small to run menuconfig\n\n![enter image description here](/linux3/bug2.png)\n\n解决方法：直接把窗口最大化就行了！\n\n#### 4.制作根文件系统\n\n\t\tcd ~/LinuxKernel/\n\t\tmkdir rootfs\n\t\tgit clone  https://github.com/mengning/menu.git\n\t\tcd menu\n\t\tgcc -o init linktable.c menu.c test.c -m32 -static –lpthread\n\t\t\n\t\tcd ../rootfs\n\t\tcp ../menu/init ./\n\t\tfind . | cpio -o -Hnewc |gzip -9 > ../rootfs.img\n\n（注：最后一步实际上是有三个部分组成 find命令 和cpio命令和 gzip命令 cpio是备份归档的命令，gzip是压缩）\n\n#### 5.运行menuOS 并进行设置调试\n\n启动：\n\n\tqemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img\n\t\t\n运行截图：\n\n![enter image description here](/linux3/lab3_4.png)\n\n启动调试：\n\n\tqemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -s -S\n\n注：\n\n>  -S freeze CPU at startup (use ’c’ to start execution) 第一开始运行时停住\n>  \n>  -s shorthand for -gdb tcp::1234 若不想使用1234端口，则可以使用-gdb tcp:xxxx来取代-s选项\n\n再开启另外一个shell，运行gdb\n\n\tgdb\n\t\n\t(gdb)file linux-3.18.6/vmlinux # 在gdb界面中targe remote之前加载符号表 \n\t\n\t(gdb)target remote:1234 # 建立gdb和gdbserver之间的连接,按c 让qemu上的Linux继续运行 \n\t\n\t(gdb)break start_kernel # 断点的设置可以在target remote之前，也可以在之后 \n\n\t(gdb)list 查看源代码\n\t\n\t(gdb)continue 继续运行到下一个断点\n\n截图：\n\t\n![enter image description here](/linux3/lab3_7.png)\t\n\t\n\n### 二、启动过程分析 \n\n\n\n整体上看，启动流程大致是这样的：\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"./linux3/start1.gif\"  />\n\n</div>\n\n加电或者复位是先从bios启动，bios完成基本的硬件自检和环境初始化后，将bootloader（linux是grub，windows是ntloader）拷贝到内存。\n\n然后执行bootloader，bootloader会进一步初始化，读取硬件信息，加载分区表，初始化中断向量表以及初始化页表等一系列初始化真正内核启动代码运行环境的操作，最后通过b start_kernel，跳转并执行start_kernel\n\nstart_kernel 的主要功能是\n进一步完成的存储管理、设备管理、文件管理、进程管理等任务的初始化\n\n这一块的代码相当复杂，直接mark下基本的：\n\n- tick_init();  //时钟源初始化\n\n- setup_arch（）; //最后一点和体系结构相关的初始化，开启mmu，初始化内存结构段表，页表啥的\n\n- init_IRQ（）; //对中断向量表的初始化\n\n- trap_init（）；//进一步初始化硬件中断，主要是中断链表，中断处理函数\n\n- sched_init（） //和进程调度相关的初始化\n\n- time_init（）//定时器的初始化\n\n- console_init（）  //终端初始化，tty\n\n- vfs_caches_init_early(); //虚拟文件系统初始化，后面挂载根文件系统用\n\n主要分析下 rest_init()\n\n\n\tstatic noinline void __init_refok rest_init(void)\n\t{\n\t\tint pid;\n\t\n\t\trcu_scheduler_starting();\n\n\t\tkernel_thread(kernel_init, NULL, CLONE_FS);\n\t\tnuma_default_policy();\n\t\tpid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n\t\trcu_read_lock();\n\t\tkthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);\n\t\trcu_read_unlock();\n\t\tcomplete(&kthreadd_done);\n\n\t\tinit_idle_bootup_task(current);\n\t\tschedule_preempt_disabled();\n\t\t\n\t\tcpu_startup_entry(CPUHP_ONLINE);\n\t}\n\n**rcu\\_scheduler_starting()**\n\n看了解释，这个函数是完成schedule最后的初始化工作，就是打开对RCU锁的检测，因为后面也会用到。RCU是一个高性能的读写锁，具体的请参考：[Linux 2.6内核中新的锁机制--RCU](https://www.ibm.com/developerworks/cn/linux/l-rcu/)\n\n **kernel_thread(kernel_init, NULL, CLONE_FS);**\n\n\n启动一个内核线程，这个内核线程的执行体是kernel_init（）\n\n他的第一句话就是kernel_init_freeable(void) 中的\n\n **wait_for_completion(&kthreadd_done);**\n\n意思是需要等待kthreadd_done这个信号量释放，在之后的代码中才会释放。因此我们先往下看\n\n **numa_default_policy();**\n\n设定NUMA系统的内存访问策略为默认\n这里的NUMA 是[非均匀访存模型](https://zh.wikipedia.org/wiki/%E9%9D%9E%E5%9D%87%E5%8C%80%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%9E%8B)，目测和SMP有关\n\n **pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);**\n\n\n这里又会创建一个[kthreadd](http://blog.csdn.net/lchjustc/article/details/6910663)内核线程，这个线程首先会根据kthread_create_list 循环创建其他内核线程，然后会通过该线程管理和调度别的内核线程（貌似又被称为worker_thread,好像还和中断处理的下半部分有关了，mark下回头看）\n\n\trcu_read_lock();\n\tkthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);\n\trcu_read_unlock();\n\tcomplete(&kthreadd_done);\n\n这就是可以理解为将threadd根据kthread_create_list初始化的内核线程链表赋值给kthreadd_task\n\n **kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);**\n\n作用是通过pid来查找其对应的task_struct的结构体 \n可以猜到 task_struct肯定是链表\n\n剩下的内容就是start_kernel如何沦为idle进程：(●'◡'●)\n\n\tinit_idle_bootup_task(current);\n\tschedule_preempt_disabled();  //关调度抢占\n\tcpu_startup_entry(CPUHP_ONLINE);\n\n **init_idle_bootup_task(current);**  将当前进程也就是0号进程init_task 的[sched_class](http://home.ustc.edu.cn/~hchunhui/linux_sched.html) 设置成 idle 大概意思应该是调度时机为idle，即cpu空闲时调度\n\n **cpu_startup_entry(CPUHP_ONLINE);**\n\n这个老师分析过了。最后会进入/linux-3.18.6/kernel/sched/idle.c 中的\n**static void cpu_idle_loop(void)**\n这是一个死循环。\ninit_task完全堕落成0号进程了。\n\n回到之前的 kernel_init \n\n前面会进行很多初始化工作，内存的，SMP的，锁检测的。\n\n比较重要的是 **do_basic_setup()**;  里面涉及到了一系列驱动程序的加载 \n\n之后会进行一系列复杂的根文件系统加载工作，先创建虚拟文件系统rootfs，然后根据不同的文件系统类型和格式，会有不同的加载根文件系统。\n\n最终他会启动开始运行init程序，也就是系统启动时会自动加载的程序，\n如果你没有在启动参数里设置（execute_command中没有），那么最终会\n\n\trun_init_process(\"/sbin/init\");\n    run_init_process(\"/etc/init\");\n    run_init_process(\"/bin/init\");\n    run_init_process(\"/bin/sh\");\n\n在这四个默认位置寻找init程序，如果没有，则内核panic\n\n\t panic(\"No init found. Try passing init= option to kernel. \"\n     \"See Linux Documentation/init.txt for guidance.\");\n\n到这里基本上就都结束了。\n\n\n### 三、 总结\n\nLinux内核启动流程水太深了。\n\n但是 我们要明白 1号进程为init进程，0号进程为idle进程，是原来init_task变成的。\n\n-----\n\n附：\n\n相关链接已经贴到文中\n\n \n顺便提一下  发现 [IBM\n developerWorks](https://www.ibm.com/developerworks/cn/) 中有很多很好很有深度的资料！ 强烈推荐！\n","slug":"Linux_3","published":1,"updated":"2016-03-31T17:01:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt5k000b679ylmmtvoi2","content":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\" target=\"_blank\" rel=\"external\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><hr>\n<h3 id=\"一、实验步骤整理\"><a href=\"#一、实验步骤整理\" class=\"headerlink\" title=\"一、实验步骤整理\"></a>一、实验步骤整理</h3><h4 id=\"1-下载Linux-3-18-6\"><a href=\"#1-下载Linux-3-18-6\" class=\"headerlink\" title=\"1.下载Linux-3.18.6\"></a>1.下载Linux-3.18.6</h4><p><a href=\"https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.18.6.tar.xz\" target=\"_blank\" rel=\"external\">Linux-3.18.6.tar.xz下载地址</a></p>\n<h4 id=\"2-解压Linux\"><a href=\"#2-解压Linux\" class=\"headerlink\" title=\"2.解压Linux\"></a>2.解压Linux</h4><pre><code>xz -d linux-3.18.6.tar.xz\ntar -xvf linux-3.18.6.tar\n</code></pre><p>查看项目文件夹：</p>\n<p><img src=\"/linux3/lab3_1.png\" alt=\"enter image description here\"></p>\n<h4 id=\"3-设置编译选项并编译内核\"><a href=\"#3-设置编译选项并编译内核\" class=\"headerlink\" title=\"3.设置编译选项并编译内核\"></a>3.设置编译选项并编译内核</h4><p>设置成i386的配置：</p>\n<pre><code>make i386_defconfig \n</code></pre><p>截图：</p>\n<p><img src=\"/linux3/lab3_2.png\" alt=\"enter image description here\"></p>\n<p>进入图像化配置界面：</p>\n<pre><code>make menuconfig\n</code></pre><p>并设置成调试信息开启：</p>\n<pre><code>kernel hacking—&gt;\n[*] compile the kernel with debug info\n</code></pre><p>截图：</p>\n<p><img src=\"/linux3/lab3_5.png\" alt=\"enter image description here\"></p>\n<p>最后编译（等待若干时间后）：</p>\n<pre><code>make\n</code></pre><h4 id=\"make-menuconfig-遇到的问题：\"><a href=\"#make-menuconfig-遇到的问题：\" class=\"headerlink\" title=\"make menuconfig 遇到的问题：\"></a>make menuconfig 遇到的问题：</h4><ul>\n<li>提示 “unable to find ncurses libraries …”</li>\n</ul>\n<p><img src=\"/linux3/bug1.png\" alt=\"enter image description here\"></p>\n<p>解决办法：安装 libncurses5-dev  </p>\n<pre><code>sudo apt-get install libncurses5-dev\n</code></pre><ul>\n<li>Your display is too small to run menuconfig</li>\n</ul>\n<p><img src=\"/linux3/bug2.png\" alt=\"enter image description here\"></p>\n<p>解决方法：直接把窗口最大化就行了！</p>\n<h4 id=\"4-制作根文件系统\"><a href=\"#4-制作根文件系统\" class=\"headerlink\" title=\"4.制作根文件系统\"></a>4.制作根文件系统</h4><pre><code>cd ~/LinuxKernel/\nmkdir rootfs\ngit clone  https://github.com/mengning/menu.git\ncd menu\ngcc -o init linktable.c menu.c test.c -m32 -static –lpthread\n\ncd ../rootfs\ncp ../menu/init ./\nfind . | cpio -o -Hnewc |gzip -9 &gt; ../rootfs.img\n</code></pre><p>（注：最后一步实际上是有三个部分组成 find命令 和cpio命令和 gzip命令 cpio是备份归档的命令，gzip是压缩）</p>\n<h4 id=\"5-运行menuOS-并进行设置调试\"><a href=\"#5-运行menuOS-并进行设置调试\" class=\"headerlink\" title=\"5.运行menuOS 并进行设置调试\"></a>5.运行menuOS 并进行设置调试</h4><p>启动：</p>\n<pre><code>qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img\n</code></pre><p>运行截图：</p>\n<p><img src=\"/linux3/lab3_4.png\" alt=\"enter image description here\"></p>\n<p>启动调试：</p>\n<pre><code>qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -s -S\n</code></pre><p>注：</p>\n<blockquote>\n<p> -S freeze CPU at startup (use ’c’ to start execution) 第一开始运行时停住</p>\n<p> -s shorthand for -gdb tcp::1234 若不想使用1234端口，则可以使用-gdb tcp:xxxx来取代-s选项</p>\n</blockquote>\n<p>再开启另外一个shell，运行gdb</p>\n<pre><code>gdb\n\n(gdb)file linux-3.18.6/vmlinux # 在gdb界面中targe remote之前加载符号表 \n\n(gdb)target remote:1234 # 建立gdb和gdbserver之间的连接,按c 让qemu上的Linux继续运行 \n\n(gdb)break start_kernel # 断点的设置可以在target remote之前，也可以在之后 \n\n(gdb)list 查看源代码\n\n(gdb)continue 继续运行到下一个断点\n</code></pre><p>截图：</p>\n<p><img src=\"/linux3/lab3_7.png\" alt=\"enter image description here\">    </p>\n<h3 id=\"二、启动过程分析\"><a href=\"#二、启动过程分析\" class=\"headerlink\" title=\"二、启动过程分析\"></a>二、启动过程分析</h3><p>整体上看，启动流程大致是这样的：</p>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"./linux3/start1.gif\"><br><br></div>\n\n<p>加电或者复位是先从bios启动，bios完成基本的硬件自检和环境初始化后，将bootloader（linux是grub，windows是ntloader）拷贝到内存。</p>\n<p>然后执行bootloader，bootloader会进一步初始化，读取硬件信息，加载分区表，初始化中断向量表以及初始化页表等一系列初始化真正内核启动代码运行环境的操作，最后通过b start_kernel，跳转并执行start_kernel</p>\n<p>start_kernel 的主要功能是<br>进一步完成的存储管理、设备管理、文件管理、进程管理等任务的初始化</p>\n<p>这一块的代码相当复杂，直接mark下基本的：</p>\n<ul>\n<li><p>tick_init();  //时钟源初始化</p>\n</li>\n<li><p>setup_arch（）; //最后一点和体系结构相关的初始化，开启mmu，初始化内存结构段表，页表啥的</p>\n</li>\n<li><p>init_IRQ（）; //对中断向量表的初始化</p>\n</li>\n<li><p>trap_init（）；//进一步初始化硬件中断，主要是中断链表，中断处理函数</p>\n</li>\n<li><p>sched_init（） //和进程调度相关的初始化</p>\n</li>\n<li><p>time_init（）//定时器的初始化</p>\n</li>\n<li><p>console_init（）  //终端初始化，tty</p>\n</li>\n<li><p>vfs_caches_init_early(); //虚拟文件系统初始化，后面挂载根文件系统用</p>\n</li>\n</ul>\n<p>主要分析下 rest_init()</p>\n<pre><code>static noinline void __init_refok rest_init(void)\n{\n    int pid;\n\n    rcu_scheduler_starting();\n\n    kernel_thread(kernel_init, NULL, CLONE_FS);\n    numa_default_policy();\n    pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n    rcu_read_lock();\n    kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);\n    rcu_read_unlock();\n    complete(&amp;kthreadd_done);\n\n    init_idle_bootup_task(current);\n    schedule_preempt_disabled();\n\n    cpu_startup_entry(CPUHP_ONLINE);\n}\n</code></pre><p><strong>rcu_scheduler_starting()</strong></p>\n<p>看了解释，这个函数是完成schedule最后的初始化工作，就是打开对RCU锁的检测，因为后面也会用到。RCU是一个高性能的读写锁，具体的请参考：<a href=\"https://www.ibm.com/developerworks/cn/linux/l-rcu/\" target=\"_blank\" rel=\"external\">Linux 2.6内核中新的锁机制–RCU</a></p>\n<p> <strong>kernel_thread(kernel_init, NULL, CLONE_FS);</strong></p>\n<p>启动一个内核线程，这个内核线程的执行体是kernel_init（）</p>\n<p>他的第一句话就是kernel_init_freeable(void) 中的</p>\n<p> <strong>wait_for_completion(&amp;kthreadd_done);</strong></p>\n<p>意思是需要等待kthreadd_done这个信号量释放，在之后的代码中才会释放。因此我们先往下看</p>\n<p> <strong>numa_default_policy();</strong></p>\n<p>设定NUMA系统的内存访问策略为默认<br>这里的NUMA 是<a href=\"https://zh.wikipedia.org/wiki/%E9%9D%9E%E5%9D%87%E5%8C%80%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%9E%8B\" target=\"_blank\" rel=\"external\">非均匀访存模型</a>，目测和SMP有关</p>\n<p> <strong>pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);</strong></p>\n<p>这里又会创建一个<a href=\"http://blog.csdn.net/lchjustc/article/details/6910663\" target=\"_blank\" rel=\"external\">kthreadd</a>内核线程，这个线程首先会根据kthread_create_list 循环创建其他内核线程，然后会通过该线程管理和调度别的内核线程（貌似又被称为worker_thread,好像还和中断处理的下半部分有关了，mark下回头看）</p>\n<pre><code>rcu_read_lock();\nkthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);\nrcu_read_unlock();\ncomplete(&amp;kthreadd_done);\n</code></pre><p>这就是可以理解为将threadd根据kthread_create_list初始化的内核线程链表赋值给kthreadd_task</p>\n<p> <strong>kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</strong></p>\n<p>作用是通过pid来查找其对应的task_struct的结构体<br>可以猜到 task_struct肯定是链表</p>\n<p>剩下的内容就是start_kernel如何沦为idle进程：(●’◡’●)</p>\n<pre><code>init_idle_bootup_task(current);\nschedule_preempt_disabled();  //关调度抢占\ncpu_startup_entry(CPUHP_ONLINE);\n</code></pre><p> <strong>init_idle_bootup_task(current);</strong>  将当前进程也就是0号进程init_task 的<a href=\"http://home.ustc.edu.cn/~hchunhui/linux_sched.html\" target=\"_blank\" rel=\"external\">sched_class</a> 设置成 idle 大概意思应该是调度时机为idle，即cpu空闲时调度</p>\n<p> <strong>cpu_startup_entry(CPUHP_ONLINE);</strong></p>\n<p>这个老师分析过了。最后会进入/linux-3.18.6/kernel/sched/idle.c 中的<br><strong>static void cpu_idle_loop(void)</strong><br>这是一个死循环。<br>init_task完全堕落成0号进程了。</p>\n<p>回到之前的 kernel_init </p>\n<p>前面会进行很多初始化工作，内存的，SMP的，锁检测的。</p>\n<p>比较重要的是 <strong>do_basic_setup()</strong>;  里面涉及到了一系列驱动程序的加载 </p>\n<p>之后会进行一系列复杂的根文件系统加载工作，先创建虚拟文件系统rootfs，然后根据不同的文件系统类型和格式，会有不同的加载根文件系统。</p>\n<p>最终他会启动开始运行init程序，也就是系统启动时会自动加载的程序，<br>如果你没有在启动参数里设置（execute_command中没有），那么最终会</p>\n<pre><code>run_init_process(&quot;/sbin/init&quot;);\nrun_init_process(&quot;/etc/init&quot;);\nrun_init_process(&quot;/bin/init&quot;);\nrun_init_process(&quot;/bin/sh&quot;);\n</code></pre><p>在这四个默认位置寻找init程序，如果没有，则内核panic</p>\n<pre><code>panic(&quot;No init found. Try passing init= option to kernel. &quot;\n&quot;See Linux Documentation/init.txt for guidance.&quot;);\n</code></pre><p>到这里基本上就都结束了。</p>\n<h3 id=\"三、-总结\"><a href=\"#三、-总结\" class=\"headerlink\" title=\"三、 总结\"></a>三、 总结</h3><p>Linux内核启动流程水太深了。</p>\n<p>但是 我们要明白 1号进程为init进程，0号进程为idle进程，是原来init_task变成的。</p>\n<hr>\n<p>附：</p>\n<p>相关链接已经贴到文中</p>\n<p>顺便提一下  发现 <a href=\"https://www.ibm.com/developerworks/cn/\" target=\"_blank\" rel=\"external\">IBM<br> developerWorks</a> 中有很多很好很有深度的资料！ 强烈推荐！</p>\n","excerpt":"","more":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><hr>\n<h3 id=\"一、实验步骤整理\"><a href=\"#一、实验步骤整理\" class=\"headerlink\" title=\"一、实验步骤整理\"></a>一、实验步骤整理</h3><h4 id=\"1-下载Linux-3-18-6\"><a href=\"#1-下载Linux-3-18-6\" class=\"headerlink\" title=\"1.下载Linux-3.18.6\"></a>1.下载Linux-3.18.6</h4><p><a href=\"https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.18.6.tar.xz\">Linux-3.18.6.tar.xz下载地址</a></p>\n<h4 id=\"2-解压Linux\"><a href=\"#2-解压Linux\" class=\"headerlink\" title=\"2.解压Linux\"></a>2.解压Linux</h4><pre><code>xz -d linux-3.18.6.tar.xz\ntar -xvf linux-3.18.6.tar\n</code></pre><p>查看项目文件夹：</p>\n<p><img src=\"/linux3/lab3_1.png\" alt=\"enter image description here\"></p>\n<h4 id=\"3-设置编译选项并编译内核\"><a href=\"#3-设置编译选项并编译内核\" class=\"headerlink\" title=\"3.设置编译选项并编译内核\"></a>3.设置编译选项并编译内核</h4><p>设置成i386的配置：</p>\n<pre><code>make i386_defconfig \n</code></pre><p>截图：</p>\n<p><img src=\"/linux3/lab3_2.png\" alt=\"enter image description here\"></p>\n<p>进入图像化配置界面：</p>\n<pre><code>make menuconfig\n</code></pre><p>并设置成调试信息开启：</p>\n<pre><code>kernel hacking—&gt;\n[*] compile the kernel with debug info\n</code></pre><p>截图：</p>\n<p><img src=\"/linux3/lab3_5.png\" alt=\"enter image description here\"></p>\n<p>最后编译（等待若干时间后）：</p>\n<pre><code>make\n</code></pre><h4 id=\"make-menuconfig-遇到的问题：\"><a href=\"#make-menuconfig-遇到的问题：\" class=\"headerlink\" title=\"make menuconfig 遇到的问题：\"></a>make menuconfig 遇到的问题：</h4><ul>\n<li>提示 “unable to find ncurses libraries …”</li>\n</ul>\n<p><img src=\"/linux3/bug1.png\" alt=\"enter image description here\"></p>\n<p>解决办法：安装 libncurses5-dev  </p>\n<pre><code>sudo apt-get install libncurses5-dev\n</code></pre><ul>\n<li>Your display is too small to run menuconfig</li>\n</ul>\n<p><img src=\"/linux3/bug2.png\" alt=\"enter image description here\"></p>\n<p>解决方法：直接把窗口最大化就行了！</p>\n<h4 id=\"4-制作根文件系统\"><a href=\"#4-制作根文件系统\" class=\"headerlink\" title=\"4.制作根文件系统\"></a>4.制作根文件系统</h4><pre><code>cd ~/LinuxKernel/\nmkdir rootfs\ngit clone  https://github.com/mengning/menu.git\ncd menu\ngcc -o init linktable.c menu.c test.c -m32 -static –lpthread\n\ncd ../rootfs\ncp ../menu/init ./\nfind . | cpio -o -Hnewc |gzip -9 &gt; ../rootfs.img\n</code></pre><p>（注：最后一步实际上是有三个部分组成 find命令 和cpio命令和 gzip命令 cpio是备份归档的命令，gzip是压缩）</p>\n<h4 id=\"5-运行menuOS-并进行设置调试\"><a href=\"#5-运行menuOS-并进行设置调试\" class=\"headerlink\" title=\"5.运行menuOS 并进行设置调试\"></a>5.运行menuOS 并进行设置调试</h4><p>启动：</p>\n<pre><code>qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img\n</code></pre><p>运行截图：</p>\n<p><img src=\"/linux3/lab3_4.png\" alt=\"enter image description here\"></p>\n<p>启动调试：</p>\n<pre><code>qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -s -S\n</code></pre><p>注：</p>\n<blockquote>\n<p> -S freeze CPU at startup (use ’c’ to start execution) 第一开始运行时停住</p>\n<p> -s shorthand for -gdb tcp::1234 若不想使用1234端口，则可以使用-gdb tcp:xxxx来取代-s选项</p>\n</blockquote>\n<p>再开启另外一个shell，运行gdb</p>\n<pre><code>gdb\n\n(gdb)file linux-3.18.6/vmlinux # 在gdb界面中targe remote之前加载符号表 \n\n(gdb)target remote:1234 # 建立gdb和gdbserver之间的连接,按c 让qemu上的Linux继续运行 \n\n(gdb)break start_kernel # 断点的设置可以在target remote之前，也可以在之后 \n\n(gdb)list 查看源代码\n\n(gdb)continue 继续运行到下一个断点\n</code></pre><p>截图：</p>\n<p><img src=\"/linux3/lab3_7.png\" alt=\"enter image description here\">    </p>\n<h3 id=\"二、启动过程分析\"><a href=\"#二、启动过程分析\" class=\"headerlink\" title=\"二、启动过程分析\"></a>二、启动过程分析</h3><p>整体上看，启动流程大致是这样的：</p>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"./linux3/start1.gif\"  /><br><br></div>\n\n<p>加电或者复位是先从bios启动，bios完成基本的硬件自检和环境初始化后，将bootloader（linux是grub，windows是ntloader）拷贝到内存。</p>\n<p>然后执行bootloader，bootloader会进一步初始化，读取硬件信息，加载分区表，初始化中断向量表以及初始化页表等一系列初始化真正内核启动代码运行环境的操作，最后通过b start_kernel，跳转并执行start_kernel</p>\n<p>start_kernel 的主要功能是<br>进一步完成的存储管理、设备管理、文件管理、进程管理等任务的初始化</p>\n<p>这一块的代码相当复杂，直接mark下基本的：</p>\n<ul>\n<li><p>tick_init();  //时钟源初始化</p>\n</li>\n<li><p>setup_arch（）; //最后一点和体系结构相关的初始化，开启mmu，初始化内存结构段表，页表啥的</p>\n</li>\n<li><p>init_IRQ（）; //对中断向量表的初始化</p>\n</li>\n<li><p>trap_init（）；//进一步初始化硬件中断，主要是中断链表，中断处理函数</p>\n</li>\n<li><p>sched_init（） //和进程调度相关的初始化</p>\n</li>\n<li><p>time_init（）//定时器的初始化</p>\n</li>\n<li><p>console_init（）  //终端初始化，tty</p>\n</li>\n<li><p>vfs_caches_init_early(); //虚拟文件系统初始化，后面挂载根文件系统用</p>\n</li>\n</ul>\n<p>主要分析下 rest_init()</p>\n<pre><code>static noinline void __init_refok rest_init(void)\n{\n    int pid;\n\n    rcu_scheduler_starting();\n\n    kernel_thread(kernel_init, NULL, CLONE_FS);\n    numa_default_policy();\n    pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n    rcu_read_lock();\n    kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);\n    rcu_read_unlock();\n    complete(&amp;kthreadd_done);\n\n    init_idle_bootup_task(current);\n    schedule_preempt_disabled();\n\n    cpu_startup_entry(CPUHP_ONLINE);\n}\n</code></pre><p><strong>rcu_scheduler_starting()</strong></p>\n<p>看了解释，这个函数是完成schedule最后的初始化工作，就是打开对RCU锁的检测，因为后面也会用到。RCU是一个高性能的读写锁，具体的请参考：<a href=\"https://www.ibm.com/developerworks/cn/linux/l-rcu/\">Linux 2.6内核中新的锁机制–RCU</a></p>\n<p> <strong>kernel_thread(kernel_init, NULL, CLONE_FS);</strong></p>\n<p>启动一个内核线程，这个内核线程的执行体是kernel_init（）</p>\n<p>他的第一句话就是kernel_init_freeable(void) 中的</p>\n<p> <strong>wait_for_completion(&amp;kthreadd_done);</strong></p>\n<p>意思是需要等待kthreadd_done这个信号量释放，在之后的代码中才会释放。因此我们先往下看</p>\n<p> <strong>numa_default_policy();</strong></p>\n<p>设定NUMA系统的内存访问策略为默认<br>这里的NUMA 是<a href=\"https://zh.wikipedia.org/wiki/%E9%9D%9E%E5%9D%87%E5%8C%80%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%9E%8B\">非均匀访存模型</a>，目测和SMP有关</p>\n<p> <strong>pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);</strong></p>\n<p>这里又会创建一个<a href=\"http://blog.csdn.net/lchjustc/article/details/6910663\">kthreadd</a>内核线程，这个线程首先会根据kthread_create_list 循环创建其他内核线程，然后会通过该线程管理和调度别的内核线程（貌似又被称为worker_thread,好像还和中断处理的下半部分有关了，mark下回头看）</p>\n<pre><code>rcu_read_lock();\nkthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);\nrcu_read_unlock();\ncomplete(&amp;kthreadd_done);\n</code></pre><p>这就是可以理解为将threadd根据kthread_create_list初始化的内核线程链表赋值给kthreadd_task</p>\n<p> <strong>kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</strong></p>\n<p>作用是通过pid来查找其对应的task_struct的结构体<br>可以猜到 task_struct肯定是链表</p>\n<p>剩下的内容就是start_kernel如何沦为idle进程：(●’◡’●)</p>\n<pre><code>init_idle_bootup_task(current);\nschedule_preempt_disabled();  //关调度抢占\ncpu_startup_entry(CPUHP_ONLINE);\n</code></pre><p> <strong>init_idle_bootup_task(current);</strong>  将当前进程也就是0号进程init_task 的<a href=\"http://home.ustc.edu.cn/~hchunhui/linux_sched.html\">sched_class</a> 设置成 idle 大概意思应该是调度时机为idle，即cpu空闲时调度</p>\n<p> <strong>cpu_startup_entry(CPUHP_ONLINE);</strong></p>\n<p>这个老师分析过了。最后会进入/linux-3.18.6/kernel/sched/idle.c 中的<br><strong>static void cpu_idle_loop(void)</strong><br>这是一个死循环。<br>init_task完全堕落成0号进程了。</p>\n<p>回到之前的 kernel_init </p>\n<p>前面会进行很多初始化工作，内存的，SMP的，锁检测的。</p>\n<p>比较重要的是 <strong>do_basic_setup()</strong>;  里面涉及到了一系列驱动程序的加载 </p>\n<p>之后会进行一系列复杂的根文件系统加载工作，先创建虚拟文件系统rootfs，然后根据不同的文件系统类型和格式，会有不同的加载根文件系统。</p>\n<p>最终他会启动开始运行init程序，也就是系统启动时会自动加载的程序，<br>如果你没有在启动参数里设置（execute_command中没有），那么最终会</p>\n<pre><code>run_init_process(&quot;/sbin/init&quot;);\nrun_init_process(&quot;/etc/init&quot;);\nrun_init_process(&quot;/bin/init&quot;);\nrun_init_process(&quot;/bin/sh&quot;);\n</code></pre><p>在这四个默认位置寻找init程序，如果没有，则内核panic</p>\n<pre><code>panic(&quot;No init found. Try passing init= option to kernel. &quot;\n&quot;See Linux Documentation/init.txt for guidance.&quot;);\n</code></pre><p>到这里基本上就都结束了。</p>\n<h3 id=\"三、-总结\"><a href=\"#三、-总结\" class=\"headerlink\" title=\"三、 总结\"></a>三、 总结</h3><p>Linux内核启动流程水太深了。</p>\n<p>但是 我们要明白 1号进程为init进程，0号进程为idle进程，是原来init_task变成的。</p>\n<hr>\n<p>附：</p>\n<p>相关链接已经贴到文中</p>\n<p>顺便提一下  发现 <a href=\"https://www.ibm.com/developerworks/cn/\">IBM<br> developerWorks</a> 中有很多很好很有深度的资料！ 强烈推荐！</p>\n"},{"title":"Linux内核分析4：两种方式使用同一个系统调用","date":"2016-03-30T16:50:15.000Z","_content":"\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n\n\n<h4>注：因为这次作业和上次作业写重复了。所以我就补充说明一下。全部写在前面了。</h4>\n\nAPI实现的系统调用流程图：\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"/linux5/lab1.png\"  />\n\n</div>\n\n具体的系统调用处理过程：\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"/linux5/lab2.png\"  />\n\n</div>\n\n两个小问题：\n\n- 是如何找到系统调用处理函数的？\n\n中断门。\n\n在trap_init（）\n里面有一句 set_system_trap_gate(SYSCALL_VECTOR, &system_call);\n\n设置系统中断门。\n\n这里会形成IDT表项。\n\n里面记录了系统段的选择子以及偏移量。\n\n并且IDT具体的服务函数是和根据中断号相关的。\n\n通过IDT基地址+8*中断号\n\n然后找到中断服务函数（例如：system_call ）\n\n- 参数传递\n\nSYSCALL_DEFINEx\n\n例如调用 getpid()\n\nSYSCALL_DEFINE0(getpid)\n\n这里x就是参数个数。\n\n为什么要这样解释是他要做一些参数格式的转换。\n\n\n\n### 一、 过程整理\n\n我这里使用的系统调用是getpid() 用于获取当前的进程id，系统调用号是20（0x14）\n\n直接截图：\n\n\n- 使用库函数进行系统调用：\n\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"/linux4/lab1.png\"  />\n\n</div>\n\n运行:\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"/linux4/lab2.png\"  />\n\n</div>\n\n- 使用内嵌汇编系统调用：\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"/linux4/lab3.png\"  />\n\n</div>\n\n运行：\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"/linux4/lab4.png\"  />\n\n</div>\n\n（注：这里获取的pid是肯定不一样的，因为每次运行程序都会分配一个）\n\n\n### 二、 关于系统调用\n\n#### 1.软中断 中断 和系统调用\n\n首先系统调用是一种特殊的中断，是程序或者说是用户主动进行向内核请求服务的\n\n硬件中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。\n如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，\n跳到中断处理程序的入口点，进行中断处理。\n\n但是我之前一直没分清楚软中断和系统调用的区别,\n我又查了一下，觉得可能是这样的。\n\n软中断是一种机制，由软件模拟中断**信号**主动申请来访问内核的服务，让内核帮助处理一些操作。\n\n\n系统调用是一种具体的实现，可以由用户主动发出。\n\n程序异常也是一种软中断，比如说缺页异常。\n\n中断下半段的处理也是通过软中断实现的，通过ksoftirqd内核线程去处理未完成的操作\n\n\n#### 2.系统调用的过程（源码分析）\n\n在/linux-3.18.6/arch/x86/kernel/traps.c中 有系统调用的初始化：\n\n\t\tset_system_trap_gate(SYSCALL_VECTOR, &system_call);\n\n调用**trap_init()**就会执行到这里。其中**SYSCALL_VECTOR  = 0x80** 因此我们就是通过 INT  0x80触发系统调用的。\n\n系统调用时的处理函数是**asmlinkage int system_call(void);**\n\n system_call 具体的实现在内核加载的时候就已经加载到内存中了。\n\n在/linux-3.18.6/arch/x86/kernel/entry_32.S 中 有system_call的实现：\n\n\tENTRY(system_call)\n\t...\n\t\n\tSAVE_ALL\n\t\n\t....\n\t\n\tcmpl $(NR_syscalls), %eax\n\t...\n\tsyscall_call:\n\t\tcall *sys_call_table(,%eax,4)\n\tsyscall_after_call:\n\t\t....\n\tsyscall_exit:jne syscall_exit_work\n\t\t....\n\n\trestore_all:\n\t\tTRACE_IRQS_IRET\n\trestore_all_notrace:\n\t.....\n\trestore_nocheck:\n\t\tRESTORE_REGS 4\t\t\t# skip orig_eax/error_code\n\t...\n\tENDPROC(system_call)\n\n实现可以分为三步看：\n\n**1.保存现场，通用寄存器**\n\t\n在硬件做完对 esp，eip ，eflags保存之后\n\n我们可以清晰的看到 linux system_call 对 其他寄存器的保存 ---- **SAVE_ALL**\n\nSAVE_ALL 的实现在文件最开始的地方：\n\n\t.macro SAVE_ALL\n\tcld\n\tPUSH_GS\n\tpushl_cfi %fs\n\t/*CFI_REL_OFFSET fs, 0;*/\n\tpushl_cfi %es\n\t/*CFI_REL_OFFSET es, 0;*/\n\tpushl_cfi %ds\n\t/*CFI_REL_OFFSET ds, 0;*/\n\tpushl_cfi %eax\n\tCFI_REL_OFFSET eax, 0\n\tpushl_cfi %ebp \n\t....(省略)\n\t\n**2.获取系统调用号（没注意到参数在哪里获取？）**\n\n\tcmpl $(NR_syscalls), %eax \n\n应该是比较系统调用号看是否存在吧\n\n\tcall *sys_call_table(,%eax,4)\n\n通过系统调用表跳转到具体的系统调用\n\n**3.恢复现场并退出中断**\n\n\tsyscall_exit:jne syscall_exit_work\n\n跳转到 **syscall_exit_work** 处理\n最后一句是跳转到 jmp **resume_userspace** \n\n**resume_userspace** 最后一句是jmp **restore_all** \n\n（**注：这里无意中发现了  jmp restore_all之前会进行jne work_pending，这里会设置need_resched 判断调度！**）\n\n然后发现**RESTORE_ALL** 这个宏实际上是不存在的！\n\n**restore_all** 只执行了 TRACE_IRQS_IRET 用来判断中断是否关闭，若是关闭便打开\n\n然后顺序执行 **restore_all_notrace:** 关键的 **RESTORE_REGS**  4\n\n这才是真正的恢复现场！\n\n\n\t.macro RESTORE_INT_REGS\n\t\tpopl_cfi %ebx\n\t\tCFI_RESTORE ebx\n\t\tpopl_cfi %ecx\n\t\tCFI_RESTORE ecx\n\t\tpopl_cfi %edx\n\t\tCFI_RESTORE edx\n\t\tpopl_cfi %esi\n\t\tCFI_RESTORE esi\n\t\tpopl_cfi %edi\n\t\tCFI_RESTORE edi\n\t\tpopl_cfi %ebp\n\t\tCFI_RESTORE ebp\n\t\tpopl_cfi %eax\n\t\tCFI_RESTORE eax\n\t.endm\n\t.macro RESTORE_REGS pop=0\n\t\tRESTORE_INT_REGS\n\t...\n\t\nover\t\t\n\t\n\n\n#### 3.API函数的实现\n\n简要说明下：\n\n所有api函数都可以在\nlinux-3.18.6/arch/x86/syscalls/syscall_32.tbl 找到对应的系统调用处理函数\n如：reboot - > sys_reboot\n\n这些函数的绝大多数实现都在linux-3.18.6/kernel/sys.c\n\n之前系统调用在内核中的入口也都是sys_xxx\n现在都改为SYSCALL_DEFINE定义的了\n\n\n具体请看：Linux系统调用之SYSCALL_DEFINE(http://blog.csdn.net/hxmhyp/article/details/22699669)\n\n### 三、总结\n\n三层皮只是系统调用通过API实现的时候才会有的，封装例程包装了系统调用。但是实际上我们用内嵌汇编实现，和三层皮是没什么关系的。\n","source":"_posts/Linux_45.md","raw":"---\ntitle: Linux内核分析4：两种方式使用同一个系统调用\ndate: 2016-03-31 01:50:15\ntags: [linux,linux内核]\ncategories: linux内核分析\n---\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n\n\n<h4>注：因为这次作业和上次作业写重复了。所以我就补充说明一下。全部写在前面了。</h4>\n\nAPI实现的系统调用流程图：\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"/linux5/lab1.png\"  />\n\n</div>\n\n具体的系统调用处理过程：\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"/linux5/lab2.png\"  />\n\n</div>\n\n两个小问题：\n\n- 是如何找到系统调用处理函数的？\n\n中断门。\n\n在trap_init（）\n里面有一句 set_system_trap_gate(SYSCALL_VECTOR, &system_call);\n\n设置系统中断门。\n\n这里会形成IDT表项。\n\n里面记录了系统段的选择子以及偏移量。\n\n并且IDT具体的服务函数是和根据中断号相关的。\n\n通过IDT基地址+8*中断号\n\n然后找到中断服务函数（例如：system_call ）\n\n- 参数传递\n\nSYSCALL_DEFINEx\n\n例如调用 getpid()\n\nSYSCALL_DEFINE0(getpid)\n\n这里x就是参数个数。\n\n为什么要这样解释是他要做一些参数格式的转换。\n\n\n\n### 一、 过程整理\n\n我这里使用的系统调用是getpid() 用于获取当前的进程id，系统调用号是20（0x14）\n\n直接截图：\n\n\n- 使用库函数进行系统调用：\n\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"/linux4/lab1.png\"  />\n\n</div>\n\n运行:\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"/linux4/lab2.png\"  />\n\n</div>\n\n- 使用内嵌汇编系统调用：\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"/linux4/lab3.png\"  />\n\n</div>\n\n运行：\n\n<div style=\"margin:0 auto;text-align:center;width:100%\">\n\n<img src=\"/linux4/lab4.png\"  />\n\n</div>\n\n（注：这里获取的pid是肯定不一样的，因为每次运行程序都会分配一个）\n\n\n### 二、 关于系统调用\n\n#### 1.软中断 中断 和系统调用\n\n首先系统调用是一种特殊的中断，是程序或者说是用户主动进行向内核请求服务的\n\n硬件中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。\n如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，\n跳到中断处理程序的入口点，进行中断处理。\n\n但是我之前一直没分清楚软中断和系统调用的区别,\n我又查了一下，觉得可能是这样的。\n\n软中断是一种机制，由软件模拟中断**信号**主动申请来访问内核的服务，让内核帮助处理一些操作。\n\n\n系统调用是一种具体的实现，可以由用户主动发出。\n\n程序异常也是一种软中断，比如说缺页异常。\n\n中断下半段的处理也是通过软中断实现的，通过ksoftirqd内核线程去处理未完成的操作\n\n\n#### 2.系统调用的过程（源码分析）\n\n在/linux-3.18.6/arch/x86/kernel/traps.c中 有系统调用的初始化：\n\n\t\tset_system_trap_gate(SYSCALL_VECTOR, &system_call);\n\n调用**trap_init()**就会执行到这里。其中**SYSCALL_VECTOR  = 0x80** 因此我们就是通过 INT  0x80触发系统调用的。\n\n系统调用时的处理函数是**asmlinkage int system_call(void);**\n\n system_call 具体的实现在内核加载的时候就已经加载到内存中了。\n\n在/linux-3.18.6/arch/x86/kernel/entry_32.S 中 有system_call的实现：\n\n\tENTRY(system_call)\n\t...\n\t\n\tSAVE_ALL\n\t\n\t....\n\t\n\tcmpl $(NR_syscalls), %eax\n\t...\n\tsyscall_call:\n\t\tcall *sys_call_table(,%eax,4)\n\tsyscall_after_call:\n\t\t....\n\tsyscall_exit:jne syscall_exit_work\n\t\t....\n\n\trestore_all:\n\t\tTRACE_IRQS_IRET\n\trestore_all_notrace:\n\t.....\n\trestore_nocheck:\n\t\tRESTORE_REGS 4\t\t\t# skip orig_eax/error_code\n\t...\n\tENDPROC(system_call)\n\n实现可以分为三步看：\n\n**1.保存现场，通用寄存器**\n\t\n在硬件做完对 esp，eip ，eflags保存之后\n\n我们可以清晰的看到 linux system_call 对 其他寄存器的保存 ---- **SAVE_ALL**\n\nSAVE_ALL 的实现在文件最开始的地方：\n\n\t.macro SAVE_ALL\n\tcld\n\tPUSH_GS\n\tpushl_cfi %fs\n\t/*CFI_REL_OFFSET fs, 0;*/\n\tpushl_cfi %es\n\t/*CFI_REL_OFFSET es, 0;*/\n\tpushl_cfi %ds\n\t/*CFI_REL_OFFSET ds, 0;*/\n\tpushl_cfi %eax\n\tCFI_REL_OFFSET eax, 0\n\tpushl_cfi %ebp \n\t....(省略)\n\t\n**2.获取系统调用号（没注意到参数在哪里获取？）**\n\n\tcmpl $(NR_syscalls), %eax \n\n应该是比较系统调用号看是否存在吧\n\n\tcall *sys_call_table(,%eax,4)\n\n通过系统调用表跳转到具体的系统调用\n\n**3.恢复现场并退出中断**\n\n\tsyscall_exit:jne syscall_exit_work\n\n跳转到 **syscall_exit_work** 处理\n最后一句是跳转到 jmp **resume_userspace** \n\n**resume_userspace** 最后一句是jmp **restore_all** \n\n（**注：这里无意中发现了  jmp restore_all之前会进行jne work_pending，这里会设置need_resched 判断调度！**）\n\n然后发现**RESTORE_ALL** 这个宏实际上是不存在的！\n\n**restore_all** 只执行了 TRACE_IRQS_IRET 用来判断中断是否关闭，若是关闭便打开\n\n然后顺序执行 **restore_all_notrace:** 关键的 **RESTORE_REGS**  4\n\n这才是真正的恢复现场！\n\n\n\t.macro RESTORE_INT_REGS\n\t\tpopl_cfi %ebx\n\t\tCFI_RESTORE ebx\n\t\tpopl_cfi %ecx\n\t\tCFI_RESTORE ecx\n\t\tpopl_cfi %edx\n\t\tCFI_RESTORE edx\n\t\tpopl_cfi %esi\n\t\tCFI_RESTORE esi\n\t\tpopl_cfi %edi\n\t\tCFI_RESTORE edi\n\t\tpopl_cfi %ebp\n\t\tCFI_RESTORE ebp\n\t\tpopl_cfi %eax\n\t\tCFI_RESTORE eax\n\t.endm\n\t.macro RESTORE_REGS pop=0\n\t\tRESTORE_INT_REGS\n\t...\n\t\nover\t\t\n\t\n\n\n#### 3.API函数的实现\n\n简要说明下：\n\n所有api函数都可以在\nlinux-3.18.6/arch/x86/syscalls/syscall_32.tbl 找到对应的系统调用处理函数\n如：reboot - > sys_reboot\n\n这些函数的绝大多数实现都在linux-3.18.6/kernel/sys.c\n\n之前系统调用在内核中的入口也都是sys_xxx\n现在都改为SYSCALL_DEFINE定义的了\n\n\n具体请看：Linux系统调用之SYSCALL_DEFINE(http://blog.csdn.net/hxmhyp/article/details/22699669)\n\n### 三、总结\n\n三层皮只是系统调用通过API实现的时候才会有的，封装例程包装了系统调用。但是实际上我们用内嵌汇编实现，和三层皮是没什么关系的。\n","slug":"Linux_45","published":1,"updated":"2016-03-31T17:03:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt5m000e679yrrbn5vj1","content":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\" target=\"_blank\" rel=\"external\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><h4>注：因为这次作业和上次作业写重复了。所以我就补充说明一下。全部写在前面了。</h4>\n\n<p>API实现的系统调用流程图：</p>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"/linux5/lab1.png\"><br><br></div>\n\n<p>具体的系统调用处理过程：</p>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"/linux5/lab2.png\"><br><br></div>\n\n<p>两个小问题：</p>\n<ul>\n<li>是如何找到系统调用处理函数的？</li>\n</ul>\n<p>中断门。</p>\n<p>在trap_init（）<br>里面有一句 set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);</p>\n<p>设置系统中断门。</p>\n<p>这里会形成IDT表项。</p>\n<p>里面记录了系统段的选择子以及偏移量。</p>\n<p>并且IDT具体的服务函数是和根据中断号相关的。</p>\n<p>通过IDT基地址+8*中断号</p>\n<p>然后找到中断服务函数（例如：system_call ）</p>\n<ul>\n<li>参数传递</li>\n</ul>\n<p>SYSCALL_DEFINEx</p>\n<p>例如调用 getpid()</p>\n<p>SYSCALL_DEFINE0(getpid)</p>\n<p>这里x就是参数个数。</p>\n<p>为什么要这样解释是他要做一些参数格式的转换。</p>\n<h3 id=\"一、-过程整理\"><a href=\"#一、-过程整理\" class=\"headerlink\" title=\"一、 过程整理\"></a>一、 过程整理</h3><p>我这里使用的系统调用是getpid() 用于获取当前的进程id，系统调用号是20（0x14）</p>\n<p>直接截图：</p>\n<ul>\n<li>使用库函数进行系统调用：</li>\n</ul>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"/linux4/lab1.png\"><br><br></div>\n\n<p>运行:</p>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"/linux4/lab2.png\"><br><br></div>\n\n<ul>\n<li>使用内嵌汇编系统调用：</li>\n</ul>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"/linux4/lab3.png\"><br><br></div>\n\n<p>运行：</p>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"/linux4/lab4.png\"><br><br></div>\n\n<p>（注：这里获取的pid是肯定不一样的，因为每次运行程序都会分配一个）</p>\n<h3 id=\"二、-关于系统调用\"><a href=\"#二、-关于系统调用\" class=\"headerlink\" title=\"二、 关于系统调用\"></a>二、 关于系统调用</h3><h4 id=\"1-软中断-中断-和系统调用\"><a href=\"#1-软中断-中断-和系统调用\" class=\"headerlink\" title=\"1.软中断 中断 和系统调用\"></a>1.软中断 中断 和系统调用</h4><p>首先系统调用是一种特殊的中断，是程序或者说是用户主动进行向内核请求服务的</p>\n<p>硬件中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。<br>如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，<br>跳到中断处理程序的入口点，进行中断处理。</p>\n<p>但是我之前一直没分清楚软中断和系统调用的区别,<br>我又查了一下，觉得可能是这样的。</p>\n<p>软中断是一种机制，由软件模拟中断<strong>信号</strong>主动申请来访问内核的服务，让内核帮助处理一些操作。</p>\n<p>系统调用是一种具体的实现，可以由用户主动发出。</p>\n<p>程序异常也是一种软中断，比如说缺页异常。</p>\n<p>中断下半段的处理也是通过软中断实现的，通过ksoftirqd内核线程去处理未完成的操作</p>\n<h4 id=\"2-系统调用的过程（源码分析）\"><a href=\"#2-系统调用的过程（源码分析）\" class=\"headerlink\" title=\"2.系统调用的过程（源码分析）\"></a>2.系统调用的过程（源码分析）</h4><p>在/linux-3.18.6/arch/x86/kernel/traps.c中 有系统调用的初始化：</p>\n<pre><code>set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);\n</code></pre><p>调用<strong>trap_init()</strong>就会执行到这里。其中<strong>SYSCALL_VECTOR  = 0x80</strong> 因此我们就是通过 INT  0x80触发系统调用的。</p>\n<p>系统调用时的处理函数是<strong>asmlinkage int system_call(void);</strong></p>\n<p> system_call 具体的实现在内核加载的时候就已经加载到内存中了。</p>\n<p>在/linux-3.18.6/arch/x86/kernel/entry_32.S 中 有system_call的实现：</p>\n<pre><code>ENTRY(system_call)\n...\n\nSAVE_ALL\n\n....\n\ncmpl $(NR_syscalls), %eax\n...\nsyscall_call:\n    call *sys_call_table(,%eax,4)\nsyscall_after_call:\n    ....\nsyscall_exit:jne syscall_exit_work\n    ....\n\nrestore_all:\n    TRACE_IRQS_IRET\nrestore_all_notrace:\n.....\nrestore_nocheck:\n    RESTORE_REGS 4            # skip orig_eax/error_code\n...\nENDPROC(system_call)\n</code></pre><p>实现可以分为三步看：</p>\n<p><strong>1.保存现场，通用寄存器</strong></p>\n<p>在硬件做完对 esp，eip ，eflags保存之后</p>\n<p>我们可以清晰的看到 linux system_call 对 其他寄存器的保存 —- <strong>SAVE_ALL</strong></p>\n<p>SAVE_ALL 的实现在文件最开始的地方：</p>\n<pre><code>.macro SAVE_ALL\ncld\nPUSH_GS\npushl_cfi %fs\n/*CFI_REL_OFFSET fs, 0;*/\npushl_cfi %es\n/*CFI_REL_OFFSET es, 0;*/\npushl_cfi %ds\n/*CFI_REL_OFFSET ds, 0;*/\npushl_cfi %eax\nCFI_REL_OFFSET eax, 0\npushl_cfi %ebp \n....(省略)\n</code></pre><p><strong>2.获取系统调用号（没注意到参数在哪里获取？）</strong></p>\n<pre><code>cmpl $(NR_syscalls), %eax \n</code></pre><p>应该是比较系统调用号看是否存在吧</p>\n<pre><code>call *sys_call_table(,%eax,4)\n</code></pre><p>通过系统调用表跳转到具体的系统调用</p>\n<p><strong>3.恢复现场并退出中断</strong></p>\n<pre><code>syscall_exit:jne syscall_exit_work\n</code></pre><p>跳转到 <strong>syscall_exit_work</strong> 处理<br>最后一句是跳转到 jmp <strong>resume_userspace</strong> </p>\n<p><strong>resume_userspace</strong> 最后一句是jmp <strong>restore_all</strong> </p>\n<p>（<strong>注：这里无意中发现了  jmp restore_all之前会进行jne work_pending，这里会设置need_resched 判断调度！</strong>）</p>\n<p>然后发现<strong>RESTORE_ALL</strong> 这个宏实际上是不存在的！</p>\n<p><strong>restore_all</strong> 只执行了 TRACE_IRQS_IRET 用来判断中断是否关闭，若是关闭便打开</p>\n<p>然后顺序执行 <strong>restore_all_notrace:</strong> 关键的 <strong>RESTORE_REGS</strong>  4</p>\n<p>这才是真正的恢复现场！</p>\n<pre><code>.macro RESTORE_INT_REGS\n    popl_cfi %ebx\n    CFI_RESTORE ebx\n    popl_cfi %ecx\n    CFI_RESTORE ecx\n    popl_cfi %edx\n    CFI_RESTORE edx\n    popl_cfi %esi\n    CFI_RESTORE esi\n    popl_cfi %edi\n    CFI_RESTORE edi\n    popl_cfi %ebp\n    CFI_RESTORE ebp\n    popl_cfi %eax\n    CFI_RESTORE eax\n.endm\n.macro RESTORE_REGS pop=0\n    RESTORE_INT_REGS\n...\n</code></pre><p>over        </p>\n<h4 id=\"3-API函数的实现\"><a href=\"#3-API函数的实现\" class=\"headerlink\" title=\"3.API函数的实现\"></a>3.API函数的实现</h4><p>简要说明下：</p>\n<p>所有api函数都可以在<br>linux-3.18.6/arch/x86/syscalls/syscall_32.tbl 找到对应的系统调用处理函数<br>如：reboot - &gt; sys_reboot</p>\n<p>这些函数的绝大多数实现都在linux-3.18.6/kernel/sys.c</p>\n<p>之前系统调用在内核中的入口也都是sys_xxx<br>现在都改为SYSCALL_DEFINE定义的了</p>\n<p>具体请看：Linux系统调用之SYSCALL_DEFINE(<a href=\"http://blog.csdn.net/hxmhyp/article/details/22699669\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/hxmhyp/article/details/22699669</a>)</p>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><p>三层皮只是系统调用通过API实现的时候才会有的，封装例程包装了系统调用。但是实际上我们用内嵌汇编实现，和三层皮是没什么关系的。</p>\n","excerpt":"","more":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><h4>注：因为这次作业和上次作业写重复了。所以我就补充说明一下。全部写在前面了。</h4>\n\n<p>API实现的系统调用流程图：</p>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"/linux5/lab1.png\"  /><br><br></div>\n\n<p>具体的系统调用处理过程：</p>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"/linux5/lab2.png\"  /><br><br></div>\n\n<p>两个小问题：</p>\n<ul>\n<li>是如何找到系统调用处理函数的？</li>\n</ul>\n<p>中断门。</p>\n<p>在trap_init（）<br>里面有一句 set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);</p>\n<p>设置系统中断门。</p>\n<p>这里会形成IDT表项。</p>\n<p>里面记录了系统段的选择子以及偏移量。</p>\n<p>并且IDT具体的服务函数是和根据中断号相关的。</p>\n<p>通过IDT基地址+8*中断号</p>\n<p>然后找到中断服务函数（例如：system_call ）</p>\n<ul>\n<li>参数传递</li>\n</ul>\n<p>SYSCALL_DEFINEx</p>\n<p>例如调用 getpid()</p>\n<p>SYSCALL_DEFINE0(getpid)</p>\n<p>这里x就是参数个数。</p>\n<p>为什么要这样解释是他要做一些参数格式的转换。</p>\n<h3 id=\"一、-过程整理\"><a href=\"#一、-过程整理\" class=\"headerlink\" title=\"一、 过程整理\"></a>一、 过程整理</h3><p>我这里使用的系统调用是getpid() 用于获取当前的进程id，系统调用号是20（0x14）</p>\n<p>直接截图：</p>\n<ul>\n<li>使用库函数进行系统调用：</li>\n</ul>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"/linux4/lab1.png\"  /><br><br></div>\n\n<p>运行:</p>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"/linux4/lab2.png\"  /><br><br></div>\n\n<ul>\n<li>使用内嵌汇编系统调用：</li>\n</ul>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"/linux4/lab3.png\"  /><br><br></div>\n\n<p>运行：</p>\n<div style=\"margin:0 auto;text-align:center;width:100%\"><br><br><img src=\"/linux4/lab4.png\"  /><br><br></div>\n\n<p>（注：这里获取的pid是肯定不一样的，因为每次运行程序都会分配一个）</p>\n<h3 id=\"二、-关于系统调用\"><a href=\"#二、-关于系统调用\" class=\"headerlink\" title=\"二、 关于系统调用\"></a>二、 关于系统调用</h3><h4 id=\"1-软中断-中断-和系统调用\"><a href=\"#1-软中断-中断-和系统调用\" class=\"headerlink\" title=\"1.软中断 中断 和系统调用\"></a>1.软中断 中断 和系统调用</h4><p>首先系统调用是一种特殊的中断，是程序或者说是用户主动进行向内核请求服务的</p>\n<p>硬件中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。<br>如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，<br>跳到中断处理程序的入口点，进行中断处理。</p>\n<p>但是我之前一直没分清楚软中断和系统调用的区别,<br>我又查了一下，觉得可能是这样的。</p>\n<p>软中断是一种机制，由软件模拟中断<strong>信号</strong>主动申请来访问内核的服务，让内核帮助处理一些操作。</p>\n<p>系统调用是一种具体的实现，可以由用户主动发出。</p>\n<p>程序异常也是一种软中断，比如说缺页异常。</p>\n<p>中断下半段的处理也是通过软中断实现的，通过ksoftirqd内核线程去处理未完成的操作</p>\n<h4 id=\"2-系统调用的过程（源码分析）\"><a href=\"#2-系统调用的过程（源码分析）\" class=\"headerlink\" title=\"2.系统调用的过程（源码分析）\"></a>2.系统调用的过程（源码分析）</h4><p>在/linux-3.18.6/arch/x86/kernel/traps.c中 有系统调用的初始化：</p>\n<pre><code>set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);\n</code></pre><p>调用<strong>trap_init()</strong>就会执行到这里。其中<strong>SYSCALL_VECTOR  = 0x80</strong> 因此我们就是通过 INT  0x80触发系统调用的。</p>\n<p>系统调用时的处理函数是<strong>asmlinkage int system_call(void);</strong></p>\n<p> system_call 具体的实现在内核加载的时候就已经加载到内存中了。</p>\n<p>在/linux-3.18.6/arch/x86/kernel/entry_32.S 中 有system_call的实现：</p>\n<pre><code>ENTRY(system_call)\n...\n\nSAVE_ALL\n\n....\n\ncmpl $(NR_syscalls), %eax\n...\nsyscall_call:\n    call *sys_call_table(,%eax,4)\nsyscall_after_call:\n    ....\nsyscall_exit:jne syscall_exit_work\n    ....\n\nrestore_all:\n    TRACE_IRQS_IRET\nrestore_all_notrace:\n.....\nrestore_nocheck:\n    RESTORE_REGS 4            # skip orig_eax/error_code\n...\nENDPROC(system_call)\n</code></pre><p>实现可以分为三步看：</p>\n<p><strong>1.保存现场，通用寄存器</strong></p>\n<p>在硬件做完对 esp，eip ，eflags保存之后</p>\n<p>我们可以清晰的看到 linux system_call 对 其他寄存器的保存 —- <strong>SAVE_ALL</strong></p>\n<p>SAVE_ALL 的实现在文件最开始的地方：</p>\n<pre><code>.macro SAVE_ALL\ncld\nPUSH_GS\npushl_cfi %fs\n/*CFI_REL_OFFSET fs, 0;*/\npushl_cfi %es\n/*CFI_REL_OFFSET es, 0;*/\npushl_cfi %ds\n/*CFI_REL_OFFSET ds, 0;*/\npushl_cfi %eax\nCFI_REL_OFFSET eax, 0\npushl_cfi %ebp \n....(省略)\n</code></pre><p><strong>2.获取系统调用号（没注意到参数在哪里获取？）</strong></p>\n<pre><code>cmpl $(NR_syscalls), %eax \n</code></pre><p>应该是比较系统调用号看是否存在吧</p>\n<pre><code>call *sys_call_table(,%eax,4)\n</code></pre><p>通过系统调用表跳转到具体的系统调用</p>\n<p><strong>3.恢复现场并退出中断</strong></p>\n<pre><code>syscall_exit:jne syscall_exit_work\n</code></pre><p>跳转到 <strong>syscall_exit_work</strong> 处理<br>最后一句是跳转到 jmp <strong>resume_userspace</strong> </p>\n<p><strong>resume_userspace</strong> 最后一句是jmp <strong>restore_all</strong> </p>\n<p>（<strong>注：这里无意中发现了  jmp restore_all之前会进行jne work_pending，这里会设置need_resched 判断调度！</strong>）</p>\n<p>然后发现<strong>RESTORE_ALL</strong> 这个宏实际上是不存在的！</p>\n<p><strong>restore_all</strong> 只执行了 TRACE_IRQS_IRET 用来判断中断是否关闭，若是关闭便打开</p>\n<p>然后顺序执行 <strong>restore_all_notrace:</strong> 关键的 <strong>RESTORE_REGS</strong>  4</p>\n<p>这才是真正的恢复现场！</p>\n<pre><code>.macro RESTORE_INT_REGS\n    popl_cfi %ebx\n    CFI_RESTORE ebx\n    popl_cfi %ecx\n    CFI_RESTORE ecx\n    popl_cfi %edx\n    CFI_RESTORE edx\n    popl_cfi %esi\n    CFI_RESTORE esi\n    popl_cfi %edi\n    CFI_RESTORE edi\n    popl_cfi %ebp\n    CFI_RESTORE ebp\n    popl_cfi %eax\n    CFI_RESTORE eax\n.endm\n.macro RESTORE_REGS pop=0\n    RESTORE_INT_REGS\n...\n</code></pre><p>over        </p>\n<h4 id=\"3-API函数的实现\"><a href=\"#3-API函数的实现\" class=\"headerlink\" title=\"3.API函数的实现\"></a>3.API函数的实现</h4><p>简要说明下：</p>\n<p>所有api函数都可以在<br>linux-3.18.6/arch/x86/syscalls/syscall_32.tbl 找到对应的系统调用处理函数<br>如：reboot - &gt; sys_reboot</p>\n<p>这些函数的绝大多数实现都在linux-3.18.6/kernel/sys.c</p>\n<p>之前系统调用在内核中的入口也都是sys_xxx<br>现在都改为SYSCALL_DEFINE定义的了</p>\n<p>具体请看：Linux系统调用之SYSCALL_DEFINE(<a href=\"http://blog.csdn.net/hxmhyp/article/details/22699669\">http://blog.csdn.net/hxmhyp/article/details/22699669</a>)</p>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><p>三层皮只是系统调用通过API实现的时候才会有的，封装例程包装了系统调用。但是实际上我们用内嵌汇编实现，和三层皮是没什么关系的。</p>\n"},{"title":"Linux内核分析作业6：分析Linux内核创建一个新进程的过程","date":"2016-03-30T16:50:15.000Z","_content":"\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n---\n\n### 一、过程整理\n\n这里的过程大致上和[第三次实验](https://easyforgood.github.io/Linux_3)类似\n\n具体不同就是需要将test_fork.c 替换为 test.c即可。\n\n另外设置断点是现在 run_init_process 设置了一个。\n\n然后再设置do_fork那些。\n\n不然半个小时之后才能进入想要的。\n\n\n\n### 二、关于task_struct 结构\n\n找到了这篇博客还是挺好的。介绍的很详细和全面\n\n[Linux进程管理之task_struct结构体（上）](http://blog.csdn.net/npy_lp/article/details/7292563)\n\n[Linux进程管理之task_struct结构体（下）](http://blog.csdn.net/npy_lp/article/details/7335187)\n\n简单总结一下和 进程管理、内存管理、文件系统有关的主要部分:\n\n1.  进程状态 \n\t\t\n\t\tvolatile long state;  \n\t\tint exit_state;\n\n这张图很经典：\n\n![enter image description here](http://my.csdn.net/uploads/201204/14/1334337470_8447.jpg)\n\n2. 进程标识符\n\n\t\t/*一般情况 32768 个进程*/\n\t\tpid_t pid;  \n\t\t/*线程组的领头线程 getpid()返回值*/\n\t\tpid_t tgid;  \n\n3. 进程调度 \n\t\t\n\t\t/* prio用于保存动态优先级 static_prio静态优先级 normal_prio的值取决于静态优先级和调度策略*/\n\t\tint prio, static_prio, normal_prio; \n\t\t/*实时优先级*/ \n\t\tunsigned int rt_priority;  \n\t\t/*调度类*/\n\t\tconst struct sched_class *sched_class;  \n\t\t？/*普通进程调用实体*/\n\t\tstruct sched_entity se;\n\t\t？/*实时进程调用实体*/  \n\t\tstruct sched_rt_entity rt;  \n\t\t/*调度策略*/\n\t\tunsigned int policy;  \n\t\t/*控制进程可以在哪里处理器上运行*/\n\t\tcpumask_t cpus_allowed; \t\n\n3. 进程内核栈\n\n\t\t/*指向下面的内核栈结构体的“栈底”*/\n\t\tvoid *stack;\n\t\t\n\t\t/*内核栈结构体*/\n\t\tunion thread_union {  \n\t\t\t    struct thread_info thread_info;  \n\t\t\t\tunsigned long stack[THREAD_SIZE/sizeof(long)];  //内核栈大小为THREAD_SIZE 一般为8K\n\t\t};  \n\n\t![enter image description here](http://blog.chinaunix.net/attachment/201111/4/20543672_13203954065UzM.jpeg)\n\n4. 进程地址空间 \n\t\t\n\t\t\t/*mm指向进程所拥有的内存描述符。active_mm表示所使用的内存描述符*/\n\t\t\tstruct mm_struct *mm, *active_mm;\n\t\t\t/*记录堆栈随机化的信息，为了安全引入的*/\n\t\t\tunsigned brk_randomized:1;\n\t\t\t/*进程缓存相关*/\n\t\t\tstruct task_rss_stat\trss_stat;\n\n5.  文件\n\n\t\t/* 和文件系统相关的信息*/  \n\t    int link_count, total_link_count;  \n\t\t/* 进程当前和跟目录 */  \n\t    struct fs_struct *fs;  \n\t\t/* 已打开文件表*/  \n\t    struct files_struct *files;  \n\n\n### 三、 创建一个新进程的过程\n\n整体流程：\n\n![enter image description here](/linux6/lab1.png)\n\n解释我遇到的两个问题：\n\n第一个问题是 创建子进程之后是如何调度的？\n\n其实上述流程图所示。\n\n一般情况下。先运行父进程，在运行子进程。\n\n父进程在给子进程的thread_struct中的ip 赋了ret_from_fork后。\n\n他走完整个do_fork（）后，会回到系统调用syscall_exit退出。\n\n还记得系统调用最后会进行调度。\n\n调度到子进程。\n\n这时候子进程从ret_from_fork执行后，也会进入syscall_exit \n\n又重新进行了调度，把控制权交给了父进程。\n\n所以先进行父进程的输出\n\n（注：这只是我看代码的一种理解。我在猜想也有可能进程不进行调度）\n\n---\n\n第二个问题: 内存是怎么分配的。\n\n这里涉及到了发现了两个知识点。\n\n一个是伙伴系统进行内存分配。一个是slab分配器。\n\n在dup_task_struct  中实现的。\n\n为task_struct 和 thread_info 开辟内存\n\nthread_info 就是之前有提过的内核栈。 具体情况见上图。\n\ntsk = alloc_task_struct_node(node); \n\nti = alloc_thread_info_node(tsk, node);\n\n这里 由于两个 数据结构 较小，而且分配的时候内存长度不变。因此都是slab分配器分配的。\n\n主要是这两个地方要重新分配。\n\n其他的地方通过copy_MM()共享同一空间就可以了。\n\n---\n\n最后说一下我对整个调用栈的理解。\n\ncopy_process() 中的copy_thread() \n\nthread_struct 这个结构非常重要\n，里面其实就是一个类似于pt_regs 这个数据结构，记录和处理器相关的寄存器的值。\n\n(注：我去查一下之前的内核版本信息。发现这个 task_strutct 中的thread_struct thread 这个属性在Linux2.4.16叫 thread_struct tss。 tss 啊！！百度一下你就知道是什么了 里面就是记录了任务状态！所以对应的ip就是之前用户空间的ip！)\n\n进程切换的时候。\nlinux会恢复cpu的内容，所以thread->ip自然就被恢复到eip寄存器中了\n\n同时 copy_thread 里面的ax也要赋值为0.这样才会通过返回值区分父子进程\n\n\n### 四、 总结\n\n仔细琢磨就会发现原来，fork的父子进程都是用同样的代码。\n\n\n\n\n-----\n\n","source":"_posts/Linux_6.md","raw":"---\ntitle: Linux内核分析作业6：分析Linux内核创建一个新进程的过程\ndate: 2016-03-31 01:50:15\ntags: linux\ncategories: linux内核分析\n---\n\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n---\n\n### 一、过程整理\n\n这里的过程大致上和[第三次实验](https://easyforgood.github.io/Linux_3)类似\n\n具体不同就是需要将test_fork.c 替换为 test.c即可。\n\n另外设置断点是现在 run_init_process 设置了一个。\n\n然后再设置do_fork那些。\n\n不然半个小时之后才能进入想要的。\n\n\n\n### 二、关于task_struct 结构\n\n找到了这篇博客还是挺好的。介绍的很详细和全面\n\n[Linux进程管理之task_struct结构体（上）](http://blog.csdn.net/npy_lp/article/details/7292563)\n\n[Linux进程管理之task_struct结构体（下）](http://blog.csdn.net/npy_lp/article/details/7335187)\n\n简单总结一下和 进程管理、内存管理、文件系统有关的主要部分:\n\n1.  进程状态 \n\t\t\n\t\tvolatile long state;  \n\t\tint exit_state;\n\n这张图很经典：\n\n![enter image description here](http://my.csdn.net/uploads/201204/14/1334337470_8447.jpg)\n\n2. 进程标识符\n\n\t\t/*一般情况 32768 个进程*/\n\t\tpid_t pid;  \n\t\t/*线程组的领头线程 getpid()返回值*/\n\t\tpid_t tgid;  \n\n3. 进程调度 \n\t\t\n\t\t/* prio用于保存动态优先级 static_prio静态优先级 normal_prio的值取决于静态优先级和调度策略*/\n\t\tint prio, static_prio, normal_prio; \n\t\t/*实时优先级*/ \n\t\tunsigned int rt_priority;  \n\t\t/*调度类*/\n\t\tconst struct sched_class *sched_class;  \n\t\t？/*普通进程调用实体*/\n\t\tstruct sched_entity se;\n\t\t？/*实时进程调用实体*/  \n\t\tstruct sched_rt_entity rt;  \n\t\t/*调度策略*/\n\t\tunsigned int policy;  \n\t\t/*控制进程可以在哪里处理器上运行*/\n\t\tcpumask_t cpus_allowed; \t\n\n3. 进程内核栈\n\n\t\t/*指向下面的内核栈结构体的“栈底”*/\n\t\tvoid *stack;\n\t\t\n\t\t/*内核栈结构体*/\n\t\tunion thread_union {  \n\t\t\t    struct thread_info thread_info;  \n\t\t\t\tunsigned long stack[THREAD_SIZE/sizeof(long)];  //内核栈大小为THREAD_SIZE 一般为8K\n\t\t};  \n\n\t![enter image description here](http://blog.chinaunix.net/attachment/201111/4/20543672_13203954065UzM.jpeg)\n\n4. 进程地址空间 \n\t\t\n\t\t\t/*mm指向进程所拥有的内存描述符。active_mm表示所使用的内存描述符*/\n\t\t\tstruct mm_struct *mm, *active_mm;\n\t\t\t/*记录堆栈随机化的信息，为了安全引入的*/\n\t\t\tunsigned brk_randomized:1;\n\t\t\t/*进程缓存相关*/\n\t\t\tstruct task_rss_stat\trss_stat;\n\n5.  文件\n\n\t\t/* 和文件系统相关的信息*/  \n\t    int link_count, total_link_count;  \n\t\t/* 进程当前和跟目录 */  \n\t    struct fs_struct *fs;  \n\t\t/* 已打开文件表*/  \n\t    struct files_struct *files;  \n\n\n### 三、 创建一个新进程的过程\n\n整体流程：\n\n![enter image description here](/linux6/lab1.png)\n\n解释我遇到的两个问题：\n\n第一个问题是 创建子进程之后是如何调度的？\n\n其实上述流程图所示。\n\n一般情况下。先运行父进程，在运行子进程。\n\n父进程在给子进程的thread_struct中的ip 赋了ret_from_fork后。\n\n他走完整个do_fork（）后，会回到系统调用syscall_exit退出。\n\n还记得系统调用最后会进行调度。\n\n调度到子进程。\n\n这时候子进程从ret_from_fork执行后，也会进入syscall_exit \n\n又重新进行了调度，把控制权交给了父进程。\n\n所以先进行父进程的输出\n\n（注：这只是我看代码的一种理解。我在猜想也有可能进程不进行调度）\n\n---\n\n第二个问题: 内存是怎么分配的。\n\n这里涉及到了发现了两个知识点。\n\n一个是伙伴系统进行内存分配。一个是slab分配器。\n\n在dup_task_struct  中实现的。\n\n为task_struct 和 thread_info 开辟内存\n\nthread_info 就是之前有提过的内核栈。 具体情况见上图。\n\ntsk = alloc_task_struct_node(node); \n\nti = alloc_thread_info_node(tsk, node);\n\n这里 由于两个 数据结构 较小，而且分配的时候内存长度不变。因此都是slab分配器分配的。\n\n主要是这两个地方要重新分配。\n\n其他的地方通过copy_MM()共享同一空间就可以了。\n\n---\n\n最后说一下我对整个调用栈的理解。\n\ncopy_process() 中的copy_thread() \n\nthread_struct 这个结构非常重要\n，里面其实就是一个类似于pt_regs 这个数据结构，记录和处理器相关的寄存器的值。\n\n(注：我去查一下之前的内核版本信息。发现这个 task_strutct 中的thread_struct thread 这个属性在Linux2.4.16叫 thread_struct tss。 tss 啊！！百度一下你就知道是什么了 里面就是记录了任务状态！所以对应的ip就是之前用户空间的ip！)\n\n进程切换的时候。\nlinux会恢复cpu的内容，所以thread->ip自然就被恢复到eip寄存器中了\n\n同时 copy_thread 里面的ax也要赋值为0.这样才会通过返回值区分父子进程\n\n\n### 四、 总结\n\n仔细琢磨就会发现原来，fork的父子进程都是用同样的代码。\n\n\n\n\n-----\n\n","slug":"Linux_6","published":1,"updated":"2016-03-31T17:02:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt5r000j679yq9anpst0","content":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\" target=\"_blank\" rel=\"external\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><hr>\n<h3 id=\"一、过程整理\"><a href=\"#一、过程整理\" class=\"headerlink\" title=\"一、过程整理\"></a>一、过程整理</h3><p>这里的过程大致上和<a href=\"https://easyforgood.github.io/Linux_3\" target=\"_blank\" rel=\"external\">第三次实验</a>类似</p>\n<p>具体不同就是需要将test_fork.c 替换为 test.c即可。</p>\n<p>另外设置断点是现在 run_init_process 设置了一个。</p>\n<p>然后再设置do_fork那些。</p>\n<p>不然半个小时之后才能进入想要的。</p>\n<h3 id=\"二、关于task-struct-结构\"><a href=\"#二、关于task-struct-结构\" class=\"headerlink\" title=\"二、关于task_struct 结构\"></a>二、关于task_struct 结构</h3><p>找到了这篇博客还是挺好的。介绍的很详细和全面</p>\n<p><a href=\"http://blog.csdn.net/npy_lp/article/details/7292563\" target=\"_blank\" rel=\"external\">Linux进程管理之task_struct结构体（上）</a></p>\n<p><a href=\"http://blog.csdn.net/npy_lp/article/details/7335187\" target=\"_blank\" rel=\"external\">Linux进程管理之task_struct结构体（下）</a></p>\n<p>简单总结一下和 进程管理、内存管理、文件系统有关的主要部分:</p>\n<ol>\n<li><p>进程状态 </p>\n<pre><code>volatile long state;  \nint exit_state;\n</code></pre></li>\n</ol>\n<p>这张图很经典：</p>\n<p><img src=\"http://my.csdn.net/uploads/201204/14/1334337470_8447.jpg\" alt=\"enter image description here\"></p>\n<ol>\n<li><p>进程标识符</p>\n<pre><code>/*一般情况 32768 个进程*/\npid_t pid;  \n/*线程组的领头线程 getpid()返回值*/\npid_t tgid;  \n</code></pre></li>\n<li><p>进程调度 </p>\n<pre><code>/* prio用于保存动态优先级 static_prio静态优先级 normal_prio的值取决于静态优先级和调度策略*/\nint prio, static_prio, normal_prio; \n/*实时优先级*/ \nunsigned int rt_priority;  \n/*调度类*/\nconst struct sched_class *sched_class;  \n？/*普通进程调用实体*/\nstruct sched_entity se;\n？/*实时进程调用实体*/  \nstruct sched_rt_entity rt;  \n/*调度策略*/\nunsigned int policy;  \n/*控制进程可以在哪里处理器上运行*/\ncpumask_t cpus_allowed;     \n</code></pre></li>\n<li><p>进程内核栈</p>\n<pre><code>/*指向下面的内核栈结构体的“栈底”*/\nvoid *stack;\n\n/*内核栈结构体*/\nunion thread_union {  \n        struct thread_info thread_info;  \n        unsigned long stack[THREAD_SIZE/sizeof(long)];  //内核栈大小为THREAD_SIZE 一般为8K\n};  \n</code></pre><p> <img src=\"http://blog.chinaunix.net/attachment/201111/4/20543672_13203954065UzM.jpeg\" alt=\"enter image description here\"></p>\n</li>\n<li><p>进程地址空间 </p>\n<pre><code>/*mm指向进程所拥有的内存描述符。active_mm表示所使用的内存描述符*/\nstruct mm_struct *mm, *active_mm;\n/*记录堆栈随机化的信息，为了安全引入的*/\nunsigned brk_randomized:1;\n/*进程缓存相关*/\nstruct task_rss_stat    rss_stat;\n</code></pre></li>\n<li><p>文件</p>\n<pre><code>/* 和文件系统相关的信息*/  \nint link_count, total_link_count;  \n/* 进程当前和跟目录 */  \nstruct fs_struct *fs;  \n/* 已打开文件表*/  \nstruct files_struct *files;  \n</code></pre></li>\n</ol>\n<h3 id=\"三、-创建一个新进程的过程\"><a href=\"#三、-创建一个新进程的过程\" class=\"headerlink\" title=\"三、 创建一个新进程的过程\"></a>三、 创建一个新进程的过程</h3><p>整体流程：</p>\n<p><img src=\"/linux6/lab1.png\" alt=\"enter image description here\"></p>\n<p>解释我遇到的两个问题：</p>\n<p>第一个问题是 创建子进程之后是如何调度的？</p>\n<p>其实上述流程图所示。</p>\n<p>一般情况下。先运行父进程，在运行子进程。</p>\n<p>父进程在给子进程的thread_struct中的ip 赋了ret_from_fork后。</p>\n<p>他走完整个do_fork（）后，会回到系统调用syscall_exit退出。</p>\n<p>还记得系统调用最后会进行调度。</p>\n<p>调度到子进程。</p>\n<p>这时候子进程从ret_from_fork执行后，也会进入syscall_exit </p>\n<p>又重新进行了调度，把控制权交给了父进程。</p>\n<p>所以先进行父进程的输出</p>\n<p>（注：这只是我看代码的一种理解。我在猜想也有可能进程不进行调度）</p>\n<hr>\n<p>第二个问题: 内存是怎么分配的。</p>\n<p>这里涉及到了发现了两个知识点。</p>\n<p>一个是伙伴系统进行内存分配。一个是slab分配器。</p>\n<p>在dup_task_struct  中实现的。</p>\n<p>为task_struct 和 thread_info 开辟内存</p>\n<p>thread_info 就是之前有提过的内核栈。 具体情况见上图。</p>\n<p>tsk = alloc_task_struct_node(node); </p>\n<p>ti = alloc_thread_info_node(tsk, node);</p>\n<p>这里 由于两个 数据结构 较小，而且分配的时候内存长度不变。因此都是slab分配器分配的。</p>\n<p>主要是这两个地方要重新分配。</p>\n<p>其他的地方通过copy_MM()共享同一空间就可以了。</p>\n<hr>\n<p>最后说一下我对整个调用栈的理解。</p>\n<p>copy_process() 中的copy_thread() </p>\n<p>thread_struct 这个结构非常重要<br>，里面其实就是一个类似于pt_regs 这个数据结构，记录和处理器相关的寄存器的值。</p>\n<p>(注：我去查一下之前的内核版本信息。发现这个 task_strutct 中的thread_struct thread 这个属性在Linux2.4.16叫 thread_struct tss。 tss 啊！！百度一下你就知道是什么了 里面就是记录了任务状态！所以对应的ip就是之前用户空间的ip！)</p>\n<p>进程切换的时候。<br>linux会恢复cpu的内容，所以thread-&gt;ip自然就被恢复到eip寄存器中了</p>\n<p>同时 copy_thread 里面的ax也要赋值为0.这样才会通过返回值区分父子进程</p>\n<h3 id=\"四、-总结\"><a href=\"#四、-总结\" class=\"headerlink\" title=\"四、 总结\"></a>四、 总结</h3><p>仔细琢磨就会发现原来，fork的父子进程都是用同样的代码。</p>\n<hr>\n","excerpt":"","more":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><hr>\n<h3 id=\"一、过程整理\"><a href=\"#一、过程整理\" class=\"headerlink\" title=\"一、过程整理\"></a>一、过程整理</h3><p>这里的过程大致上和<a href=\"https://easyforgood.github.io/Linux_3\">第三次实验</a>类似</p>\n<p>具体不同就是需要将test_fork.c 替换为 test.c即可。</p>\n<p>另外设置断点是现在 run_init_process 设置了一个。</p>\n<p>然后再设置do_fork那些。</p>\n<p>不然半个小时之后才能进入想要的。</p>\n<h3 id=\"二、关于task-struct-结构\"><a href=\"#二、关于task-struct-结构\" class=\"headerlink\" title=\"二、关于task_struct 结构\"></a>二、关于task_struct 结构</h3><p>找到了这篇博客还是挺好的。介绍的很详细和全面</p>\n<p><a href=\"http://blog.csdn.net/npy_lp/article/details/7292563\">Linux进程管理之task_struct结构体（上）</a></p>\n<p><a href=\"http://blog.csdn.net/npy_lp/article/details/7335187\">Linux进程管理之task_struct结构体（下）</a></p>\n<p>简单总结一下和 进程管理、内存管理、文件系统有关的主要部分:</p>\n<ol>\n<li><p>进程状态 </p>\n<pre><code>volatile long state;  \nint exit_state;\n</code></pre></li>\n</ol>\n<p>这张图很经典：</p>\n<p><img src=\"http://my.csdn.net/uploads/201204/14/1334337470_8447.jpg\" alt=\"enter image description here\"></p>\n<ol>\n<li><p>进程标识符</p>\n<pre><code>/*一般情况 32768 个进程*/\npid_t pid;  \n/*线程组的领头线程 getpid()返回值*/\npid_t tgid;  \n</code></pre></li>\n<li><p>进程调度 </p>\n<pre><code>/* prio用于保存动态优先级 static_prio静态优先级 normal_prio的值取决于静态优先级和调度策略*/\nint prio, static_prio, normal_prio; \n/*实时优先级*/ \nunsigned int rt_priority;  \n/*调度类*/\nconst struct sched_class *sched_class;  \n？/*普通进程调用实体*/\nstruct sched_entity se;\n？/*实时进程调用实体*/  \nstruct sched_rt_entity rt;  \n/*调度策略*/\nunsigned int policy;  \n/*控制进程可以在哪里处理器上运行*/\ncpumask_t cpus_allowed;     \n</code></pre></li>\n<li><p>进程内核栈</p>\n<pre><code>/*指向下面的内核栈结构体的“栈底”*/\nvoid *stack;\n\n/*内核栈结构体*/\nunion thread_union {  \n        struct thread_info thread_info;  \n        unsigned long stack[THREAD_SIZE/sizeof(long)];  //内核栈大小为THREAD_SIZE 一般为8K\n};  \n</code></pre><p> <img src=\"http://blog.chinaunix.net/attachment/201111/4/20543672_13203954065UzM.jpeg\" alt=\"enter image description here\"></p>\n</li>\n<li><p>进程地址空间 </p>\n<pre><code>/*mm指向进程所拥有的内存描述符。active_mm表示所使用的内存描述符*/\nstruct mm_struct *mm, *active_mm;\n/*记录堆栈随机化的信息，为了安全引入的*/\nunsigned brk_randomized:1;\n/*进程缓存相关*/\nstruct task_rss_stat    rss_stat;\n</code></pre></li>\n<li><p>文件</p>\n<pre><code>/* 和文件系统相关的信息*/  \nint link_count, total_link_count;  \n/* 进程当前和跟目录 */  \nstruct fs_struct *fs;  \n/* 已打开文件表*/  \nstruct files_struct *files;  \n</code></pre></li>\n</ol>\n<h3 id=\"三、-创建一个新进程的过程\"><a href=\"#三、-创建一个新进程的过程\" class=\"headerlink\" title=\"三、 创建一个新进程的过程\"></a>三、 创建一个新进程的过程</h3><p>整体流程：</p>\n<p><img src=\"/linux6/lab1.png\" alt=\"enter image description here\"></p>\n<p>解释我遇到的两个问题：</p>\n<p>第一个问题是 创建子进程之后是如何调度的？</p>\n<p>其实上述流程图所示。</p>\n<p>一般情况下。先运行父进程，在运行子进程。</p>\n<p>父进程在给子进程的thread_struct中的ip 赋了ret_from_fork后。</p>\n<p>他走完整个do_fork（）后，会回到系统调用syscall_exit退出。</p>\n<p>还记得系统调用最后会进行调度。</p>\n<p>调度到子进程。</p>\n<p>这时候子进程从ret_from_fork执行后，也会进入syscall_exit </p>\n<p>又重新进行了调度，把控制权交给了父进程。</p>\n<p>所以先进行父进程的输出</p>\n<p>（注：这只是我看代码的一种理解。我在猜想也有可能进程不进行调度）</p>\n<hr>\n<p>第二个问题: 内存是怎么分配的。</p>\n<p>这里涉及到了发现了两个知识点。</p>\n<p>一个是伙伴系统进行内存分配。一个是slab分配器。</p>\n<p>在dup_task_struct  中实现的。</p>\n<p>为task_struct 和 thread_info 开辟内存</p>\n<p>thread_info 就是之前有提过的内核栈。 具体情况见上图。</p>\n<p>tsk = alloc_task_struct_node(node); </p>\n<p>ti = alloc_thread_info_node(tsk, node);</p>\n<p>这里 由于两个 数据结构 较小，而且分配的时候内存长度不变。因此都是slab分配器分配的。</p>\n<p>主要是这两个地方要重新分配。</p>\n<p>其他的地方通过copy_MM()共享同一空间就可以了。</p>\n<hr>\n<p>最后说一下我对整个调用栈的理解。</p>\n<p>copy_process() 中的copy_thread() </p>\n<p>thread_struct 这个结构非常重要<br>，里面其实就是一个类似于pt_regs 这个数据结构，记录和处理器相关的寄存器的值。</p>\n<p>(注：我去查一下之前的内核版本信息。发现这个 task_strutct 中的thread_struct thread 这个属性在Linux2.4.16叫 thread_struct tss。 tss 啊！！百度一下你就知道是什么了 里面就是记录了任务状态！所以对应的ip就是之前用户空间的ip！)</p>\n<p>进程切换的时候。<br>linux会恢复cpu的内容，所以thread-&gt;ip自然就被恢复到eip寄存器中了</p>\n<p>同时 copy_thread 里面的ax也要赋值为0.这样才会通过返回值区分父子进程</p>\n<h3 id=\"四、-总结\"><a href=\"#四、-总结\" class=\"headerlink\" title=\"四、 总结\"></a>四、 总结</h3><p>仔细琢磨就会发现原来，fork的父子进程都是用同样的代码。</p>\n<hr>\n"},{"title":"Linux内核分析作业7：Linux内核如何装载和启动一个可执行程序","date":"2016-03-30T16:50:15.000Z","_content":"\n\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n---\n\n### 一、知识点总结\n\n- **预处理、编译和链接**：\n\ngcc -E -o hello.cpp hello.c -m32  //预处理\n\ngcc -x cpp-output -S -o hello.s hello.cpp -m32  //编译\n\ngcc -x assembler -c hello.s -o hello.o -m32  //汇编\n\ngcc -o hello hello.o -m32  //链接\n\ngcc -o hello.static hello.o -m32 -static  //静态链接\n\n\n- **ELF文件格式** ：\n\n分成三种：\n\n1.  可重定位的对象文件(Relocatable file)\n\n\n2.  可执行的对象文件(Executable file)\n\n3. 可被共享的对象文件(Shared object file)\n\n\t\nelf文件主要包括了：\n\n ELF header :  elf头部，基本信息\n\nProgram header table  执行文件信息;只出现在执行文件中.\n \n Section data ：  Section的实际数据;一些section有特殊的含义\n \nSection headers ： 每个section的header\n\n> 装载ELF的目的一般是确定各个区域的边界：text区的起始和终止位置，data区的起始\t\n> 和终止位置，bss区的起始和终止位置，heap和stack的起始位置（它们的终止位置是 \n> 动态变化的）。还有就是把text区和data区的内容做mmap映射：ELF文件的内容不会\n> 被 真地拷贝到内存，只有当真正需要的时候，内核才会通过page fault的形式把文件\n> 存复制到内存中去。\n\n\n\n\n- **可执行程序的执行环境**: \n\n\n\n\n> 与 Unix类似，Linux 中的程序和命令通常由命令解释器执行，这一命令解释器称为 shell。用户输入命令之后，shell 会在搜索路径（shell 变量PATH中包含搜索路径）指定的目录中搜索和输入命令匹配的映象（可执行的二进制代码）名称。如果发现匹配的映象，shell 负责装载并执行该映像。shell 首先利用 fork 系统调用建立子进程，然后用找到的可执行映象文件覆盖子进程正在执行的 shell 二进制映象。\n> \n> 当用户敲入一个命令时，从shell可以接受一些命令行参数\n> \n> int main(int argc, char *argv[], char *envp[]) argc 为参数个数，argv为传递的字符串，envp为环境变量\n\n\n\n\n\n### 二、执行过程跟踪\n\n整体流程简介：\n\n![enter image description here]zlinux7/flow.png)\n\n系统调用execvlp()系统调用首先会进入Sys_execve()\n\n然后由Sys_execve()->do_execve()->do_common_execve()\n\n\n\n![enter image description here](/linux7/lab2.png)\n\n![enter image description here](/linux7/lab3.png)\n\n> do_common_execve() 从目标文件的头部(从第一个字节开始)读入若干(128)字节，然后调用另一个函数search_binary_handler()，在那里面让各种可执行程序的处理程序前来认领和处理。内核所支持的每种可执行程序都有个struct linux_binfmt数据结构，通过向内核登记挂入一个队列。而search_binary_handler()，则扫描这个队列，让各个数据结构所提供的处理程序、即各种映像格式、逐一前来认领。如果某个格式的处理程序发现特征相符而，便执行该格式映像的装入和启动。\n\nexec_binprm() -> search_binary_handler ()\n\n![enter image description here](/linux7/lab4.png)\n\n![enter image description here](/linux7/lab5.png)\n\n\n\t#define load_elf_binary load_elf32_binary\n\tstatic struct linux_binfmt elf_format = {\n\t.module = THIS_MODULE,\n\t.load_binary = load_elf_binary,\n\t.load_shlib = load_elf_library,\n\t.core_dump = elf_core_dump,\n\t.min_coredump = ELF_EXEC_PAGESIZE\n\t};\n\n在 search_binary_handler()中执行 fmt->load_binary(bprm) 便进入 load_elf_binary\n\n（这里采用了观察者模式，虽然是一个很好的设计，但是对于阅读代码而言，带来了很多阻碍，因为你不知道到底调用的是哪个具体的处理函数）\n\n\n在load_elf_binary 中主要是找到elf_entry和bprm->p\n\n> 如果应用程序中使用了动态链接库，就没有那么简单了，内核除了加载指定的可执\n> 行文件，还要把控制权交给动态连接器(program interpreter，ld.so in linux)以处理动态\n> 链接的程序。内核搜寻段表，找到标记为PT_INTERP的段中所对应的动态连接器的\n> 名称，并使用load_elf_interp()加载其映像，并把返回的入口地址设置成load_elf_interp\n> ()的返回值，即动态链接器入口。当execve退出的时候动态链接器接着运行。动态连\n> 接器检查应用程序对共享连接库的依赖性，并在需要时对其进行加载,对程序的外部\n> 引用进行重定位。然后动态连接器把控制权交给应用程序，从ELF文件头部中定义\n> 的程序进入点开始执行。\n\n一个是new_ip 一个是new_sp\n\n最后调用 start_thread()\n\n![enter image description here](/linux7/lab8.png)\n\n\n\tvoid start_thread(struct pt_regs *regs, unsigned long eip, unsigned long esp)\n\t{\n\tPT_REGS_IP(regs) = eip;\n\tPT_REGS_SP(regs) = esp;\n\tcurrent->ptrace &= ~PT_DTRACE;\n\t}\n\n给pt_regs结构体赋值。\n\n\tstruct pt_regs *regs = current_pt_regs();\n\n在前面可以发现，这个pt_regs 就是指向当前进程的进程状态段（thread_info）的pt_regs\n\n最后进行系统调用即可\n\n![enter image description here](/linux7/lab9.png)\n\n（不知道 为什么退出sys_execve()会进入core.c中的schedule函数，不应该是在syscall_exit中进行调用的吗？）\n\n\n\n### 三、 总结\n\n之前的fork只是创建了父进程的拷贝，但是还是运行父进程的代码，但那时execve（）却替换了子进程的函数调用栈和修改了eip的指向。\n\n为什么庄生梦蝶？\n\n我有一种感觉就是如果一个进程不断execve()自己本身，就像自己不断在做梦，然后梦见自己不断在做梦，这样不断循环的感觉。但实际上，每一个都不是原来的自己了。。\n（越说越乱了。。。）\n\n\n----\n\n","source":"_posts/Linux_7.md","raw":"---\ntitle: Linux内核分析作业7：Linux内核如何装载和启动一个可执行程序\ndate: 2016-03-31 01:50:15\ntags: linux\ncategories: linux内核分析\n---\n\n\n\n#### 朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000 \n\n---\n\n### 一、知识点总结\n\n- **预处理、编译和链接**：\n\ngcc -E -o hello.cpp hello.c -m32  //预处理\n\ngcc -x cpp-output -S -o hello.s hello.cpp -m32  //编译\n\ngcc -x assembler -c hello.s -o hello.o -m32  //汇编\n\ngcc -o hello hello.o -m32  //链接\n\ngcc -o hello.static hello.o -m32 -static  //静态链接\n\n\n- **ELF文件格式** ：\n\n分成三种：\n\n1.  可重定位的对象文件(Relocatable file)\n\n\n2.  可执行的对象文件(Executable file)\n\n3. 可被共享的对象文件(Shared object file)\n\n\t\nelf文件主要包括了：\n\n ELF header :  elf头部，基本信息\n\nProgram header table  执行文件信息;只出现在执行文件中.\n \n Section data ：  Section的实际数据;一些section有特殊的含义\n \nSection headers ： 每个section的header\n\n> 装载ELF的目的一般是确定各个区域的边界：text区的起始和终止位置，data区的起始\t\n> 和终止位置，bss区的起始和终止位置，heap和stack的起始位置（它们的终止位置是 \n> 动态变化的）。还有就是把text区和data区的内容做mmap映射：ELF文件的内容不会\n> 被 真地拷贝到内存，只有当真正需要的时候，内核才会通过page fault的形式把文件\n> 存复制到内存中去。\n\n\n\n\n- **可执行程序的执行环境**: \n\n\n\n\n> 与 Unix类似，Linux 中的程序和命令通常由命令解释器执行，这一命令解释器称为 shell。用户输入命令之后，shell 会在搜索路径（shell 变量PATH中包含搜索路径）指定的目录中搜索和输入命令匹配的映象（可执行的二进制代码）名称。如果发现匹配的映象，shell 负责装载并执行该映像。shell 首先利用 fork 系统调用建立子进程，然后用找到的可执行映象文件覆盖子进程正在执行的 shell 二进制映象。\n> \n> 当用户敲入一个命令时，从shell可以接受一些命令行参数\n> \n> int main(int argc, char *argv[], char *envp[]) argc 为参数个数，argv为传递的字符串，envp为环境变量\n\n\n\n\n\n### 二、执行过程跟踪\n\n整体流程简介：\n\n![enter image description here]zlinux7/flow.png)\n\n系统调用execvlp()系统调用首先会进入Sys_execve()\n\n然后由Sys_execve()->do_execve()->do_common_execve()\n\n\n\n![enter image description here](/linux7/lab2.png)\n\n![enter image description here](/linux7/lab3.png)\n\n> do_common_execve() 从目标文件的头部(从第一个字节开始)读入若干(128)字节，然后调用另一个函数search_binary_handler()，在那里面让各种可执行程序的处理程序前来认领和处理。内核所支持的每种可执行程序都有个struct linux_binfmt数据结构，通过向内核登记挂入一个队列。而search_binary_handler()，则扫描这个队列，让各个数据结构所提供的处理程序、即各种映像格式、逐一前来认领。如果某个格式的处理程序发现特征相符而，便执行该格式映像的装入和启动。\n\nexec_binprm() -> search_binary_handler ()\n\n![enter image description here](/linux7/lab4.png)\n\n![enter image description here](/linux7/lab5.png)\n\n\n\t#define load_elf_binary load_elf32_binary\n\tstatic struct linux_binfmt elf_format = {\n\t.module = THIS_MODULE,\n\t.load_binary = load_elf_binary,\n\t.load_shlib = load_elf_library,\n\t.core_dump = elf_core_dump,\n\t.min_coredump = ELF_EXEC_PAGESIZE\n\t};\n\n在 search_binary_handler()中执行 fmt->load_binary(bprm) 便进入 load_elf_binary\n\n（这里采用了观察者模式，虽然是一个很好的设计，但是对于阅读代码而言，带来了很多阻碍，因为你不知道到底调用的是哪个具体的处理函数）\n\n\n在load_elf_binary 中主要是找到elf_entry和bprm->p\n\n> 如果应用程序中使用了动态链接库，就没有那么简单了，内核除了加载指定的可执\n> 行文件，还要把控制权交给动态连接器(program interpreter，ld.so in linux)以处理动态\n> 链接的程序。内核搜寻段表，找到标记为PT_INTERP的段中所对应的动态连接器的\n> 名称，并使用load_elf_interp()加载其映像，并把返回的入口地址设置成load_elf_interp\n> ()的返回值，即动态链接器入口。当execve退出的时候动态链接器接着运行。动态连\n> 接器检查应用程序对共享连接库的依赖性，并在需要时对其进行加载,对程序的外部\n> 引用进行重定位。然后动态连接器把控制权交给应用程序，从ELF文件头部中定义\n> 的程序进入点开始执行。\n\n一个是new_ip 一个是new_sp\n\n最后调用 start_thread()\n\n![enter image description here](/linux7/lab8.png)\n\n\n\tvoid start_thread(struct pt_regs *regs, unsigned long eip, unsigned long esp)\n\t{\n\tPT_REGS_IP(regs) = eip;\n\tPT_REGS_SP(regs) = esp;\n\tcurrent->ptrace &= ~PT_DTRACE;\n\t}\n\n给pt_regs结构体赋值。\n\n\tstruct pt_regs *regs = current_pt_regs();\n\n在前面可以发现，这个pt_regs 就是指向当前进程的进程状态段（thread_info）的pt_regs\n\n最后进行系统调用即可\n\n![enter image description here](/linux7/lab9.png)\n\n（不知道 为什么退出sys_execve()会进入core.c中的schedule函数，不应该是在syscall_exit中进行调用的吗？）\n\n\n\n### 三、 总结\n\n之前的fork只是创建了父进程的拷贝，但是还是运行父进程的代码，但那时execve（）却替换了子进程的函数调用栈和修改了eip的指向。\n\n为什么庄生梦蝶？\n\n我有一种感觉就是如果一个进程不断execve()自己本身，就像自己不断在做梦，然后梦见自己不断在做梦，这样不断循环的感觉。但实际上，每一个都不是原来的自己了。。\n（越说越乱了。。。）\n\n\n----\n\n","slug":"Linux_7","published":1,"updated":"2016-03-31T17:02:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt5v000m679ydp5xbyps","content":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\" target=\"_blank\" rel=\"external\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><hr>\n<h3 id=\"一、知识点总结\"><a href=\"#一、知识点总结\" class=\"headerlink\" title=\"一、知识点总结\"></a>一、知识点总结</h3><ul>\n<li><strong>预处理、编译和链接</strong>：</li>\n</ul>\n<p>gcc -E -o hello.cpp hello.c -m32  //预处理</p>\n<p>gcc -x cpp-output -S -o hello.s hello.cpp -m32  //编译</p>\n<p>gcc -x assembler -c hello.s -o hello.o -m32  //汇编</p>\n<p>gcc -o hello hello.o -m32  //链接</p>\n<p>gcc -o hello.static hello.o -m32 -static  //静态链接</p>\n<ul>\n<li><strong>ELF文件格式</strong> ：</li>\n</ul>\n<p>分成三种：</p>\n<ol>\n<li>可重定位的对象文件(Relocatable file)</li>\n</ol>\n<ol>\n<li><p>可执行的对象文件(Executable file)</p>\n</li>\n<li><p>可被共享的对象文件(Shared object file)</p>\n</li>\n</ol>\n<p>elf文件主要包括了：</p>\n<p> ELF header :  elf头部，基本信息</p>\n<p>Program header table  执行文件信息;只出现在执行文件中.</p>\n<p> Section data ：  Section的实际数据;一些section有特殊的含义</p>\n<p>Section headers ： 每个section的header</p>\n<blockquote>\n<p>装载ELF的目的一般是确定各个区域的边界：text区的起始和终止位置，data区的起始<br>和终止位置，bss区的起始和终止位置，heap和stack的起始位置（它们的终止位置是<br>动态变化的）。还有就是把text区和data区的内容做mmap映射：ELF文件的内容不会<br>被 真地拷贝到内存，只有当真正需要的时候，内核才会通过page fault的形式把文件<br>存复制到内存中去。</p>\n</blockquote>\n<ul>\n<li><strong>可执行程序的执行环境</strong>: </li>\n</ul>\n<blockquote>\n<p>与 Unix类似，Linux 中的程序和命令通常由命令解释器执行，这一命令解释器称为 shell。用户输入命令之后，shell 会在搜索路径（shell 变量PATH中包含搜索路径）指定的目录中搜索和输入命令匹配的映象（可执行的二进制代码）名称。如果发现匹配的映象，shell 负责装载并执行该映像。shell 首先利用 fork 系统调用建立子进程，然后用找到的可执行映象文件覆盖子进程正在执行的 shell 二进制映象。</p>\n<p>当用户敲入一个命令时，从shell可以接受一些命令行参数</p>\n<p>int main(int argc, char <em>argv[], char </em>envp[]) argc 为参数个数，argv为传递的字符串，envp为环境变量</p>\n</blockquote>\n<h3 id=\"二、执行过程跟踪\"><a href=\"#二、执行过程跟踪\" class=\"headerlink\" title=\"二、执行过程跟踪\"></a>二、执行过程跟踪</h3><p>整体流程简介：</p>\n<p>![enter image description here]zlinux7/flow.png)</p>\n<p>系统调用execvlp()系统调用首先会进入Sys_execve()</p>\n<p>然后由Sys_execve()-&gt;do_execve()-&gt;do_common_execve()</p>\n<p><img src=\"/linux7/lab2.png\" alt=\"enter image description here\"></p>\n<p><img src=\"/linux7/lab3.png\" alt=\"enter image description here\"></p>\n<blockquote>\n<p>do_common_execve() 从目标文件的头部(从第一个字节开始)读入若干(128)字节，然后调用另一个函数search_binary_handler()，在那里面让各种可执行程序的处理程序前来认领和处理。内核所支持的每种可执行程序都有个struct linux_binfmt数据结构，通过向内核登记挂入一个队列。而search_binary_handler()，则扫描这个队列，让各个数据结构所提供的处理程序、即各种映像格式、逐一前来认领。如果某个格式的处理程序发现特征相符而，便执行该格式映像的装入和启动。</p>\n</blockquote>\n<p>exec_binprm() -&gt; search_binary_handler ()</p>\n<p><img src=\"/linux7/lab4.png\" alt=\"enter image description here\"></p>\n<p><img src=\"/linux7/lab5.png\" alt=\"enter image description here\"></p>\n<pre><code>#define load_elf_binary load_elf32_binary\nstatic struct linux_binfmt elf_format = {\n.module = THIS_MODULE,\n.load_binary = load_elf_binary,\n.load_shlib = load_elf_library,\n.core_dump = elf_core_dump,\n.min_coredump = ELF_EXEC_PAGESIZE\n};\n</code></pre><p>在 search_binary_handler()中执行 fmt-&gt;load_binary(bprm) 便进入 load_elf_binary</p>\n<p>（这里采用了观察者模式，虽然是一个很好的设计，但是对于阅读代码而言，带来了很多阻碍，因为你不知道到底调用的是哪个具体的处理函数）</p>\n<p>在load_elf_binary 中主要是找到elf_entry和bprm-&gt;p</p>\n<blockquote>\n<p>如果应用程序中使用了动态链接库，就没有那么简单了，内核除了加载指定的可执<br>行文件，还要把控制权交给动态连接器(program interpreter，ld.so in linux)以处理动态<br>链接的程序。内核搜寻段表，找到标记为PT_INTERP的段中所对应的动态连接器的<br>名称，并使用load_elf_interp()加载其映像，并把返回的入口地址设置成load_elf_interp<br>()的返回值，即动态链接器入口。当execve退出的时候动态链接器接着运行。动态连<br>接器检查应用程序对共享连接库的依赖性，并在需要时对其进行加载,对程序的外部<br>引用进行重定位。然后动态连接器把控制权交给应用程序，从ELF文件头部中定义<br>的程序进入点开始执行。</p>\n</blockquote>\n<p>一个是new_ip 一个是new_sp</p>\n<p>最后调用 start_thread()</p>\n<p><img src=\"/linux7/lab8.png\" alt=\"enter image description here\"></p>\n<pre><code>void start_thread(struct pt_regs *regs, unsigned long eip, unsigned long esp)\n{\nPT_REGS_IP(regs) = eip;\nPT_REGS_SP(regs) = esp;\ncurrent-&gt;ptrace &amp;= ~PT_DTRACE;\n}\n</code></pre><p>给pt_regs结构体赋值。</p>\n<pre><code>struct pt_regs *regs = current_pt_regs();\n</code></pre><p>在前面可以发现，这个pt_regs 就是指向当前进程的进程状态段（thread_info）的pt_regs</p>\n<p>最后进行系统调用即可</p>\n<p><img src=\"/linux7/lab9.png\" alt=\"enter image description here\"></p>\n<p>（不知道 为什么退出sys_execve()会进入core.c中的schedule函数，不应该是在syscall_exit中进行调用的吗？）</p>\n<h3 id=\"三、-总结\"><a href=\"#三、-总结\" class=\"headerlink\" title=\"三、 总结\"></a>三、 总结</h3><p>之前的fork只是创建了父进程的拷贝，但是还是运行父进程的代码，但那时execve（）却替换了子进程的函数调用栈和修改了eip的指向。</p>\n<p>为什么庄生梦蝶？</p>\n<p>我有一种感觉就是如果一个进程不断execve()自己本身，就像自己不断在做梦，然后梦见自己不断在做梦，这样不断循环的感觉。但实际上，每一个都不是原来的自己了。。<br>（越说越乱了。。。）</p>\n<hr>\n","excerpt":"","more":"<h4 id=\"朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\"><a href=\"#朋翔-原创作品转载请注明出处《Linux内核分析》MOOC课程http-mooc-study-163-com-course-USTC-1000029000\" class=\"headerlink\" title=\"朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000\"></a>朋翔 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href=\"http://mooc.study.163.com/course/USTC-1000029000\">http://mooc.study.163.com/course/USTC-1000029000</a></h4><hr>\n<h3 id=\"一、知识点总结\"><a href=\"#一、知识点总结\" class=\"headerlink\" title=\"一、知识点总结\"></a>一、知识点总结</h3><ul>\n<li><strong>预处理、编译和链接</strong>：</li>\n</ul>\n<p>gcc -E -o hello.cpp hello.c -m32  //预处理</p>\n<p>gcc -x cpp-output -S -o hello.s hello.cpp -m32  //编译</p>\n<p>gcc -x assembler -c hello.s -o hello.o -m32  //汇编</p>\n<p>gcc -o hello hello.o -m32  //链接</p>\n<p>gcc -o hello.static hello.o -m32 -static  //静态链接</p>\n<ul>\n<li><strong>ELF文件格式</strong> ：</li>\n</ul>\n<p>分成三种：</p>\n<ol>\n<li>可重定位的对象文件(Relocatable file)</li>\n</ol>\n<ol>\n<li><p>可执行的对象文件(Executable file)</p>\n</li>\n<li><p>可被共享的对象文件(Shared object file)</p>\n</li>\n</ol>\n<p>elf文件主要包括了：</p>\n<p> ELF header :  elf头部，基本信息</p>\n<p>Program header table  执行文件信息;只出现在执行文件中.</p>\n<p> Section data ：  Section的实际数据;一些section有特殊的含义</p>\n<p>Section headers ： 每个section的header</p>\n<blockquote>\n<p>装载ELF的目的一般是确定各个区域的边界：text区的起始和终止位置，data区的起始<br>和终止位置，bss区的起始和终止位置，heap和stack的起始位置（它们的终止位置是<br>动态变化的）。还有就是把text区和data区的内容做mmap映射：ELF文件的内容不会<br>被 真地拷贝到内存，只有当真正需要的时候，内核才会通过page fault的形式把文件<br>存复制到内存中去。</p>\n</blockquote>\n<ul>\n<li><strong>可执行程序的执行环境</strong>: </li>\n</ul>\n<blockquote>\n<p>与 Unix类似，Linux 中的程序和命令通常由命令解释器执行，这一命令解释器称为 shell。用户输入命令之后，shell 会在搜索路径（shell 变量PATH中包含搜索路径）指定的目录中搜索和输入命令匹配的映象（可执行的二进制代码）名称。如果发现匹配的映象，shell 负责装载并执行该映像。shell 首先利用 fork 系统调用建立子进程，然后用找到的可执行映象文件覆盖子进程正在执行的 shell 二进制映象。</p>\n<p>当用户敲入一个命令时，从shell可以接受一些命令行参数</p>\n<p>int main(int argc, char <em>argv[], char </em>envp[]) argc 为参数个数，argv为传递的字符串，envp为环境变量</p>\n</blockquote>\n<h3 id=\"二、执行过程跟踪\"><a href=\"#二、执行过程跟踪\" class=\"headerlink\" title=\"二、执行过程跟踪\"></a>二、执行过程跟踪</h3><p>整体流程简介：</p>\n<p>![enter image description here]zlinux7/flow.png)</p>\n<p>系统调用execvlp()系统调用首先会进入Sys_execve()</p>\n<p>然后由Sys_execve()-&gt;do_execve()-&gt;do_common_execve()</p>\n<p><img src=\"/linux7/lab2.png\" alt=\"enter image description here\"></p>\n<p><img src=\"/linux7/lab3.png\" alt=\"enter image description here\"></p>\n<blockquote>\n<p>do_common_execve() 从目标文件的头部(从第一个字节开始)读入若干(128)字节，然后调用另一个函数search_binary_handler()，在那里面让各种可执行程序的处理程序前来认领和处理。内核所支持的每种可执行程序都有个struct linux_binfmt数据结构，通过向内核登记挂入一个队列。而search_binary_handler()，则扫描这个队列，让各个数据结构所提供的处理程序、即各种映像格式、逐一前来认领。如果某个格式的处理程序发现特征相符而，便执行该格式映像的装入和启动。</p>\n</blockquote>\n<p>exec_binprm() -&gt; search_binary_handler ()</p>\n<p><img src=\"/linux7/lab4.png\" alt=\"enter image description here\"></p>\n<p><img src=\"/linux7/lab5.png\" alt=\"enter image description here\"></p>\n<pre><code>#define load_elf_binary load_elf32_binary\nstatic struct linux_binfmt elf_format = {\n.module = THIS_MODULE,\n.load_binary = load_elf_binary,\n.load_shlib = load_elf_library,\n.core_dump = elf_core_dump,\n.min_coredump = ELF_EXEC_PAGESIZE\n};\n</code></pre><p>在 search_binary_handler()中执行 fmt-&gt;load_binary(bprm) 便进入 load_elf_binary</p>\n<p>（这里采用了观察者模式，虽然是一个很好的设计，但是对于阅读代码而言，带来了很多阻碍，因为你不知道到底调用的是哪个具体的处理函数）</p>\n<p>在load_elf_binary 中主要是找到elf_entry和bprm-&gt;p</p>\n<blockquote>\n<p>如果应用程序中使用了动态链接库，就没有那么简单了，内核除了加载指定的可执<br>行文件，还要把控制权交给动态连接器(program interpreter，ld.so in linux)以处理动态<br>链接的程序。内核搜寻段表，找到标记为PT_INTERP的段中所对应的动态连接器的<br>名称，并使用load_elf_interp()加载其映像，并把返回的入口地址设置成load_elf_interp<br>()的返回值，即动态链接器入口。当execve退出的时候动态链接器接着运行。动态连<br>接器检查应用程序对共享连接库的依赖性，并在需要时对其进行加载,对程序的外部<br>引用进行重定位。然后动态连接器把控制权交给应用程序，从ELF文件头部中定义<br>的程序进入点开始执行。</p>\n</blockquote>\n<p>一个是new_ip 一个是new_sp</p>\n<p>最后调用 start_thread()</p>\n<p><img src=\"/linux7/lab8.png\" alt=\"enter image description here\"></p>\n<pre><code>void start_thread(struct pt_regs *regs, unsigned long eip, unsigned long esp)\n{\nPT_REGS_IP(regs) = eip;\nPT_REGS_SP(regs) = esp;\ncurrent-&gt;ptrace &amp;= ~PT_DTRACE;\n}\n</code></pre><p>给pt_regs结构体赋值。</p>\n<pre><code>struct pt_regs *regs = current_pt_regs();\n</code></pre><p>在前面可以发现，这个pt_regs 就是指向当前进程的进程状态段（thread_info）的pt_regs</p>\n<p>最后进行系统调用即可</p>\n<p><img src=\"/linux7/lab9.png\" alt=\"enter image description here\"></p>\n<p>（不知道 为什么退出sys_execve()会进入core.c中的schedule函数，不应该是在syscall_exit中进行调用的吗？）</p>\n<h3 id=\"三、-总结\"><a href=\"#三、-总结\" class=\"headerlink\" title=\"三、 总结\"></a>三、 总结</h3><p>之前的fork只是创建了父进程的拷贝，但是还是运行父进程的代码，但那时execve（）却替换了子进程的函数调用栈和修改了eip的指向。</p>\n<p>为什么庄生梦蝶？</p>\n<p>我有一种感觉就是如果一个进程不断execve()自己本身，就像自己不断在做梦，然后梦见自己不断在做梦，这样不断循环的感觉。但实际上，每一个都不是原来的自己了。。<br>（越说越乱了。。。）</p>\n<hr>\n"},{"title":"Linux内核分析作业8：理解进程调度时机跟踪分析进程调度与进程切换的过程","date":"2016-03-30T16:50:15.000Z","_content":"\n### 一、进程调度的基本知识\n\n#### 1. linux进程调度的时机\n\n**调度时机只是判断是否调度但是不一定真的调度**\n\n- 进程状态转换的时刻：进程终止、进程睡眠  例如 调用sleep() wait()  调用sh\n- 当前进程的时间片用完时  和中断返回一样\n- 设备驱动程序 设备驱动程序执行长而重复的任务时，直接调用调度程序\n- 进程从中断、异常及系统调用返回到用户态时 都会回到 ret_from_sys_call 对need_resched判断是否需要调度\n\n老师的站在另外一个角度：\n\n- 中断处理过程返回会调用 \n- 内核线程可以直接调用schedule()进行进程切换\n- 用户态进程无法直接调用。只能在进入内核态后才有机会。\n\n\n\n#### 2. 时钟中断进程切换的简易流程(感觉其他的切换只是这个的一部分)\n\n**schedule（）**：主要函数进程调度函数完成进程的选择和上下文切换\n**do_timer（）**：时钟函数 \n参考书上一段资料：\n> 在CFS(unix引入的公平调度器)中，tick中断（do_timer()）首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子(左边代表优先级最高)，就标记need_resched标志\n\n**ret_from_sys_call（）**：当一个系统调用或中断完成时，该函数被调用，用于处理一些收尾工作。\n\ndo_timer() 修改进程信息、置标志位 --------> ret_from_sys_call 判断标志位 --------> call SYMBOL_NAME(schedule) 调用  schedule（）完成切换\n\n\n\n\n\n\t\n\n### 二、进程切换过程跟踪 (没啥内容)\n\n切换主要流程：\n![Alt text](/1430066325270.png)\n\n先进入schedule()\n![Alt text](/1430066602474.png)\n\n通过 pick_next_task 找到下一个切换的进程\n\n![Alt text](/1430066690011.png)\n\n进入context_switch进行进程上下文切换\n\n![Alt text](/1430066761279.png)\n\n\n这里跟踪到了 __switch_to但是没有找到switch_to\n\nswitch_to 主要是esp和eip切换\n__switch_to 网上找的的说法是\n切换浮点部件寄存器和状态 fpu\n重设TSS的esp0 \n设置current_task 这个还是很重要的。\n![Alt text](/1430067352414.png)\n\n另外一个小细节\n\n由于调用__switch_to时不是通过call指令，而是jmp\n\n然后 __switch_to也会return 这是就会执行标号1的内容了\n\n\n\n\n\n\n\n### 三、switch_to 进程切换简要分析\n\n在内核态，进程切换主要分两步：\n\n1：切换页全局目录\n\n2：切换堆栈和硬件上下文 switch_to 实现\n\nswitch_to:\n\t\t\n- 把eflags和ebp寄存器保存到prev内核栈中。\n- esp保存到prev->thread.sp 就是保存在进程状态描述符tss中。 把$1f保存到prev->thread.ip\n- 恢复next进程的堆栈  把next指向的新进程的thread.esp保存到esp中，把next->thread.ip保存到eip中\n\n__switch_to:\n\n切换内核堆栈之后，TSS段也要相应的改变\n\n> 这是因为对于linux系统来说同一个CPU上所有的进程共用一个TSS，进程切换了，因此TSS需要随之改变。\n> \n> linux系统中主要从两个方面用到了TSS：\n>\n>(1)任何进程从用户态陷入内核态都必须从TSS获得内核堆栈指针\n>\n>(2)用户态读写IO需要访问TSS的权限位图。\n> \n\n### 四、总结\n\n马上要考试了。各位加油\n\n参考文献：\n\n- linux kernel development  一书 Robert.Lover\n\n- [深入分析Linux内核源码](http://oss.org.cn/kernel-book/)\n","source":"_posts/Linux_8.md","raw":"\n---\ntitle: Linux内核分析作业8：理解进程调度时机跟踪分析进程调度与进程切换的过程\ndate: 2016-03-31 01:50:15\ntags: [linux,linux内核]\ncategories: linux内核分析\n---\n\n### 一、进程调度的基本知识\n\n#### 1. linux进程调度的时机\n\n**调度时机只是判断是否调度但是不一定真的调度**\n\n- 进程状态转换的时刻：进程终止、进程睡眠  例如 调用sleep() wait()  调用sh\n- 当前进程的时间片用完时  和中断返回一样\n- 设备驱动程序 设备驱动程序执行长而重复的任务时，直接调用调度程序\n- 进程从中断、异常及系统调用返回到用户态时 都会回到 ret_from_sys_call 对need_resched判断是否需要调度\n\n老师的站在另外一个角度：\n\n- 中断处理过程返回会调用 \n- 内核线程可以直接调用schedule()进行进程切换\n- 用户态进程无法直接调用。只能在进入内核态后才有机会。\n\n\n\n#### 2. 时钟中断进程切换的简易流程(感觉其他的切换只是这个的一部分)\n\n**schedule（）**：主要函数进程调度函数完成进程的选择和上下文切换\n**do_timer（）**：时钟函数 \n参考书上一段资料：\n> 在CFS(unix引入的公平调度器)中，tick中断（do_timer()）首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子(左边代表优先级最高)，就标记need_resched标志\n\n**ret_from_sys_call（）**：当一个系统调用或中断完成时，该函数被调用，用于处理一些收尾工作。\n\ndo_timer() 修改进程信息、置标志位 --------> ret_from_sys_call 判断标志位 --------> call SYMBOL_NAME(schedule) 调用  schedule（）完成切换\n\n\n\n\n\n\t\n\n### 二、进程切换过程跟踪 (没啥内容)\n\n切换主要流程：\n![Alt text](/1430066325270.png)\n\n先进入schedule()\n![Alt text](/1430066602474.png)\n\n通过 pick_next_task 找到下一个切换的进程\n\n![Alt text](/1430066690011.png)\n\n进入context_switch进行进程上下文切换\n\n![Alt text](/1430066761279.png)\n\n\n这里跟踪到了 __switch_to但是没有找到switch_to\n\nswitch_to 主要是esp和eip切换\n__switch_to 网上找的的说法是\n切换浮点部件寄存器和状态 fpu\n重设TSS的esp0 \n设置current_task 这个还是很重要的。\n![Alt text](/1430067352414.png)\n\n另外一个小细节\n\n由于调用__switch_to时不是通过call指令，而是jmp\n\n然后 __switch_to也会return 这是就会执行标号1的内容了\n\n\n\n\n\n\n\n### 三、switch_to 进程切换简要分析\n\n在内核态，进程切换主要分两步：\n\n1：切换页全局目录\n\n2：切换堆栈和硬件上下文 switch_to 实现\n\nswitch_to:\n\t\t\n- 把eflags和ebp寄存器保存到prev内核栈中。\n- esp保存到prev->thread.sp 就是保存在进程状态描述符tss中。 把$1f保存到prev->thread.ip\n- 恢复next进程的堆栈  把next指向的新进程的thread.esp保存到esp中，把next->thread.ip保存到eip中\n\n__switch_to:\n\n切换内核堆栈之后，TSS段也要相应的改变\n\n> 这是因为对于linux系统来说同一个CPU上所有的进程共用一个TSS，进程切换了，因此TSS需要随之改变。\n> \n> linux系统中主要从两个方面用到了TSS：\n>\n>(1)任何进程从用户态陷入内核态都必须从TSS获得内核堆栈指针\n>\n>(2)用户态读写IO需要访问TSS的权限位图。\n> \n\n### 四、总结\n\n马上要考试了。各位加油\n\n参考文献：\n\n- linux kernel development  一书 Robert.Lover\n\n- [深入分析Linux内核源码](http://oss.org.cn/kernel-book/)\n","slug":"Linux_8","published":1,"updated":"2016-03-31T17:03:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt60000p679y9kafcb8m","content":"<h3 id=\"一、进程调度的基本知识\"><a href=\"#一、进程调度的基本知识\" class=\"headerlink\" title=\"一、进程调度的基本知识\"></a>一、进程调度的基本知识</h3><h4 id=\"1-linux进程调度的时机\"><a href=\"#1-linux进程调度的时机\" class=\"headerlink\" title=\"1. linux进程调度的时机\"></a>1. linux进程调度的时机</h4><p><strong>调度时机只是判断是否调度但是不一定真的调度</strong></p>\n<ul>\n<li>进程状态转换的时刻：进程终止、进程睡眠  例如 调用sleep() wait()  调用sh</li>\n<li>当前进程的时间片用完时  和中断返回一样</li>\n<li>设备驱动程序 设备驱动程序执行长而重复的任务时，直接调用调度程序</li>\n<li>进程从中断、异常及系统调用返回到用户态时 都会回到 ret_from_sys_call 对need_resched判断是否需要调度</li>\n</ul>\n<p>老师的站在另外一个角度：</p>\n<ul>\n<li>中断处理过程返回会调用 </li>\n<li>内核线程可以直接调用schedule()进行进程切换</li>\n<li>用户态进程无法直接调用。只能在进入内核态后才有机会。</li>\n</ul>\n<h4 id=\"2-时钟中断进程切换的简易流程-感觉其他的切换只是这个的一部分\"><a href=\"#2-时钟中断进程切换的简易流程-感觉其他的切换只是这个的一部分\" class=\"headerlink\" title=\"2. 时钟中断进程切换的简易流程(感觉其他的切换只是这个的一部分)\"></a>2. 时钟中断进程切换的简易流程(感觉其他的切换只是这个的一部分)</h4><p><strong>schedule（）</strong>：主要函数进程调度函数完成进程的选择和上下文切换<br><strong>do_timer（）</strong>：时钟函数<br>参考书上一段资料：</p>\n<blockquote>\n<p>在CFS(unix引入的公平调度器)中，tick中断（do_timer()）首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子(左边代表优先级最高)，就标记need_resched标志</p>\n</blockquote>\n<p><strong>ret_from_sys_call（）</strong>：当一个系统调用或中断完成时，该函数被调用，用于处理一些收尾工作。</p>\n<p>do_timer() 修改进程信息、置标志位 ——–&gt; ret_from_sys_call 判断标志位 ——–&gt; call SYMBOL_NAME(schedule) 调用  schedule（）完成切换</p>\n<h3 id=\"二、进程切换过程跟踪-没啥内容\"><a href=\"#二、进程切换过程跟踪-没啥内容\" class=\"headerlink\" title=\"二、进程切换过程跟踪 (没啥内容)\"></a>二、进程切换过程跟踪 (没啥内容)</h3><p>切换主要流程：<br><img src=\"/1430066325270.png\" alt=\"Alt text\"></p>\n<p>先进入schedule()<br><img src=\"/1430066602474.png\" alt=\"Alt text\"></p>\n<p>通过 pick_next_task 找到下一个切换的进程</p>\n<p><img src=\"/1430066690011.png\" alt=\"Alt text\"></p>\n<p>进入context_switch进行进程上下文切换</p>\n<p><img src=\"/1430066761279.png\" alt=\"Alt text\"></p>\n<p>这里跟踪到了 __switch_to但是没有找到switch_to</p>\n<p>switch_to 主要是esp和eip切换<br>__switch_to 网上找的的说法是<br>切换浮点部件寄存器和状态 fpu<br>重设TSS的esp0<br>设置current_task 这个还是很重要的。<br><img src=\"/1430067352414.png\" alt=\"Alt text\"></p>\n<p>另外一个小细节</p>\n<p>由于调用__switch_to时不是通过call指令，而是jmp</p>\n<p>然后 __switch_to也会return 这是就会执行标号1的内容了</p>\n<h3 id=\"三、switch-to-进程切换简要分析\"><a href=\"#三、switch-to-进程切换简要分析\" class=\"headerlink\" title=\"三、switch_to 进程切换简要分析\"></a>三、switch_to 进程切换简要分析</h3><p>在内核态，进程切换主要分两步：</p>\n<p>1：切换页全局目录</p>\n<p>2：切换堆栈和硬件上下文 switch_to 实现</p>\n<p>switch_to:</p>\n<ul>\n<li>把eflags和ebp寄存器保存到prev内核栈中。</li>\n<li>esp保存到prev-&gt;thread.sp 就是保存在进程状态描述符tss中。 把$1f保存到prev-&gt;thread.ip</li>\n<li>恢复next进程的堆栈  把next指向的新进程的thread.esp保存到esp中，把next-&gt;thread.ip保存到eip中</li>\n</ul>\n<p>__switch_to:</p>\n<p>切换内核堆栈之后，TSS段也要相应的改变</p>\n<blockquote>\n<p>这是因为对于linux系统来说同一个CPU上所有的进程共用一个TSS，进程切换了，因此TSS需要随之改变。</p>\n<p>linux系统中主要从两个方面用到了TSS：</p>\n<p>(1)任何进程从用户态陷入内核态都必须从TSS获得内核堆栈指针</p>\n<p>(2)用户态读写IO需要访问TSS的权限位图。</p>\n</blockquote>\n<h3 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h3><p>马上要考试了。各位加油</p>\n<p>参考文献：</p>\n<ul>\n<li><p>linux kernel development  一书 Robert.Lover</p>\n</li>\n<li><p><a href=\"http://oss.org.cn/kernel-book/\" target=\"_blank\" rel=\"external\">深入分析Linux内核源码</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一、进程调度的基本知识\"><a href=\"#一、进程调度的基本知识\" class=\"headerlink\" title=\"一、进程调度的基本知识\"></a>一、进程调度的基本知识</h3><h4 id=\"1-linux进程调度的时机\"><a href=\"#1-linux进程调度的时机\" class=\"headerlink\" title=\"1. linux进程调度的时机\"></a>1. linux进程调度的时机</h4><p><strong>调度时机只是判断是否调度但是不一定真的调度</strong></p>\n<ul>\n<li>进程状态转换的时刻：进程终止、进程睡眠  例如 调用sleep() wait()  调用sh</li>\n<li>当前进程的时间片用完时  和中断返回一样</li>\n<li>设备驱动程序 设备驱动程序执行长而重复的任务时，直接调用调度程序</li>\n<li>进程从中断、异常及系统调用返回到用户态时 都会回到 ret_from_sys_call 对need_resched判断是否需要调度</li>\n</ul>\n<p>老师的站在另外一个角度：</p>\n<ul>\n<li>中断处理过程返回会调用 </li>\n<li>内核线程可以直接调用schedule()进行进程切换</li>\n<li>用户态进程无法直接调用。只能在进入内核态后才有机会。</li>\n</ul>\n<h4 id=\"2-时钟中断进程切换的简易流程-感觉其他的切换只是这个的一部分\"><a href=\"#2-时钟中断进程切换的简易流程-感觉其他的切换只是这个的一部分\" class=\"headerlink\" title=\"2. 时钟中断进程切换的简易流程(感觉其他的切换只是这个的一部分)\"></a>2. 时钟中断进程切换的简易流程(感觉其他的切换只是这个的一部分)</h4><p><strong>schedule（）</strong>：主要函数进程调度函数完成进程的选择和上下文切换<br><strong>do_timer（）</strong>：时钟函数<br>参考书上一段资料：</p>\n<blockquote>\n<p>在CFS(unix引入的公平调度器)中，tick中断（do_timer()）首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子(左边代表优先级最高)，就标记need_resched标志</p>\n</blockquote>\n<p><strong>ret_from_sys_call（）</strong>：当一个系统调用或中断完成时，该函数被调用，用于处理一些收尾工作。</p>\n<p>do_timer() 修改进程信息、置标志位 ——–&gt; ret_from_sys_call 判断标志位 ——–&gt; call SYMBOL_NAME(schedule) 调用  schedule（）完成切换</p>\n<h3 id=\"二、进程切换过程跟踪-没啥内容\"><a href=\"#二、进程切换过程跟踪-没啥内容\" class=\"headerlink\" title=\"二、进程切换过程跟踪 (没啥内容)\"></a>二、进程切换过程跟踪 (没啥内容)</h3><p>切换主要流程：<br><img src=\"/1430066325270.png\" alt=\"Alt text\"></p>\n<p>先进入schedule()<br><img src=\"/1430066602474.png\" alt=\"Alt text\"></p>\n<p>通过 pick_next_task 找到下一个切换的进程</p>\n<p><img src=\"/1430066690011.png\" alt=\"Alt text\"></p>\n<p>进入context_switch进行进程上下文切换</p>\n<p><img src=\"/1430066761279.png\" alt=\"Alt text\"></p>\n<p>这里跟踪到了 __switch_to但是没有找到switch_to</p>\n<p>switch_to 主要是esp和eip切换<br>__switch_to 网上找的的说法是<br>切换浮点部件寄存器和状态 fpu<br>重设TSS的esp0<br>设置current_task 这个还是很重要的。<br><img src=\"/1430067352414.png\" alt=\"Alt text\"></p>\n<p>另外一个小细节</p>\n<p>由于调用__switch_to时不是通过call指令，而是jmp</p>\n<p>然后 __switch_to也会return 这是就会执行标号1的内容了</p>\n<h3 id=\"三、switch-to-进程切换简要分析\"><a href=\"#三、switch-to-进程切换简要分析\" class=\"headerlink\" title=\"三、switch_to 进程切换简要分析\"></a>三、switch_to 进程切换简要分析</h3><p>在内核态，进程切换主要分两步：</p>\n<p>1：切换页全局目录</p>\n<p>2：切换堆栈和硬件上下文 switch_to 实现</p>\n<p>switch_to:</p>\n<ul>\n<li>把eflags和ebp寄存器保存到prev内核栈中。</li>\n<li>esp保存到prev-&gt;thread.sp 就是保存在进程状态描述符tss中。 把$1f保存到prev-&gt;thread.ip</li>\n<li>恢复next进程的堆栈  把next指向的新进程的thread.esp保存到esp中，把next-&gt;thread.ip保存到eip中</li>\n</ul>\n<p>__switch_to:</p>\n<p>切换内核堆栈之后，TSS段也要相应的改变</p>\n<blockquote>\n<p>这是因为对于linux系统来说同一个CPU上所有的进程共用一个TSS，进程切换了，因此TSS需要随之改变。</p>\n<p>linux系统中主要从两个方面用到了TSS：</p>\n<p>(1)任何进程从用户态陷入内核态都必须从TSS获得内核堆栈指针</p>\n<p>(2)用户态读写IO需要访问TSS的权限位图。</p>\n</blockquote>\n<h3 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h3><p>马上要考试了。各位加油</p>\n<p>参考文献：</p>\n<ul>\n<li><p>linux kernel development  一书 Robert.Lover</p>\n</li>\n<li><p><a href=\"http://oss.org.cn/kernel-book/\">深入分析Linux内核源码</a></p>\n</li>\n</ul>\n"},{"title":"pic-2015-03-28","date":"2016-03-28T14:41:57.000Z","_content":"![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-memicroMsg.1459182289814.jpg)\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-original13e8de63fb8419ae992f5f9a9d7797f494cb30361db76-ll5Z7t_fw658.jpg)\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-memicroMsg.1459174637743.jpg)\n\n\n","source":"_posts/pic-2015-03-28.md","raw":"---\ntitle: pic-2015-03-28\ntags:\n  - 动漫\n  - 手绘\ncategories: 手绘\ndate: 2016-03-28 23:41:57\n---\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-memicroMsg.1459182289814.jpg)\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-original13e8de63fb8419ae992f5f9a9d7797f494cb30361db76-ll5Z7t_fw658.jpg)\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-memicroMsg.1459174637743.jpg)\n\n\n","slug":"pic-2015-03-28","published":1,"updated":"2016-04-03T13:27:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt63000t679yg0cb0qco","content":"<p><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-memicroMsg.1459182289814.jpg\" alt=\"enter image description here\"><br><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-original13e8de63fb8419ae992f5f9a9d7797f494cb30361db76-ll5Z7t_fw658.jpg\" alt=\"enter image description here\"><br><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-memicroMsg.1459174637743.jpg\" alt=\"enter image description here\"></p>\n","excerpt":"","more":"<p><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-memicroMsg.1459182289814.jpg\" alt=\"enter image description here\"><br><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-original13e8de63fb8419ae992f5f9a9d7797f494cb30361db76-ll5Z7t_fw658.jpg\" alt=\"enter image description here\"><br><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-memicroMsg.1459174637743.jpg\" alt=\"enter image description here\"></p>\n"},{"title":"Linux内核读书笔记1","date":"2016-03-30T16:50:15.000Z","_content":"\n\n\n\n### 一、整体概念\n\n![enter image description here](http://blog.chinaunix.net/attachment/201208/3/24708340_1343984974Ejr8.png)\n\n内存寻址大概要经过这几种转换\n\n逻辑地址： 由段和偏移量构成。 面向开发人员的\n\n线性地址： 一个32bit无符号位数 取值范围从0x00000000 ~ 0xffffffff\n\n物理地址:\t\t真正对应内存的地址，有地址总线对应的。32bit或者**36bit**（intel 在 Pentium Pro 后 增加了引脚，但是要系统支持PAE）\n\n需要内存管理单元（**MMU**）硬件支持才能进行地址转换\n\n需要**分段单元** 和**分页单元**\n\n另外mmu还应该包含 内存仲裁器 用来协调多处理器访存和DMA\n\n### 二、关于分段\n\n（*分段 和 分页 都需要cpu进入保护模式 实模式用来操作初期自举*）\n\n- ####段选择符\n\t\n\t段选择符放在**段寄存器**中 ，cs 代码段寄存器  ds数据段寄存器  ss栈段寄存器\n\n> Cs寄存器还有一个重要功能，它包含一个两位字段，用以指明CPU的当前特权级（Current Privilege level，CPL），0表示最高，3代表最低优先级。Linux只用0级和3级，分别称为内核态和用户态。\n\n特权级越大 特权越低\n\n（关于EPL = Max(CPL ,RPL) <= DPL 成立则 可以访问）\n\n段选择符有16bit  包含：\n\n- 索引号\n- 表指示器 gdt or ldt\n- RPL 请求者特权级\n\n- ####段描述符\n\n8byte 用来描述段的特征\n\n存放在 GDT 和 LDT中 ， 在内存的地址分别放在 gdtr 和 ldtr 控制寄存器中 \n\n主要包含了Base **段首字节的地址** （一般首字节的地址指向的内容为0 用来标记 段偏移量异常）\n\n**Limit 用来决定段的长度**\n\n**DPL 描述符特权级**\n\n**快速访问段描述符**\n为了加速逻辑地址到线性地址的转换，80x86提供了**一个附加的不可编程的寄存器，供6个段寄存器使用，包含8个字节的段描述符。**每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入对应的非编程的CPU寄存器。这样，逻辑地址到线性地址转换就不用访问主存中的GDT或LDT。除非段寄存器内容有改变时。\n\n**分段单元**执行以下操作：\n\n1. 先检查段选择符的TI字段，以决定段选择符在GDT还是LDT中。\n2. 从index字段计算段描述符的地址，index值*8+gdtr/ldtr\n3. 逻辑地址偏移量与段描述符的Base字段相加减，得到线性地址。\n\n![enter image description here](http://blog.chinaunix.net/attachment/201208/3/24708340_1343985016OjVi.png)\n\n\nlinux不喜欢分段。！\n\n**这里是平坦模式寻址**\n\n一般的段模式不同程序都会是不同的段，但是这里的保护模式下的平坦模式把整个内存映射成了一个巨大的数组。\n\n\n\n运行在用户态的所有Linux进程都使用一对相同的段来寻址，即用户代码段，用户数据段。\n\n\n###   三、 关于分页\n\n把线性地址映射到物理地址的数据结构叫**页表**(page table),页表在主存中，在启动分页单元之前必须由内核对页表进行适当的初始化。\n\ncr0寄存器 PG标志位 =1 表示启动页表\n\n从80386起，intel的分页单元处理4KB的页，32位的线性地址被分成3个域：\n \n- Directory（页目录），最高10位\n\n- Table（页表），中间10位\n\n- Offset（偏移量），最低12位 \n\n线性地址的转换分两步，每一步都基于一种转换表，第一种是页目录表(page directory)，第二种是页表(page table).\n\n页目录的物理地址放在cr3\n\n页表项和页目录项主要结构：\n> Present 标志 表示 是否在内存中\n>\n> 20bit 页框物理地址\n\n>dirty 标志：写操作操作系统设置 \n\n> accessed标志：对页框寻址OS设置 \n\n> read/write标志：存取权限\n\n。。。。\n\n![enter image description here](http://blog.chinaunix.net/attachment/201208/3/24708340_1343985052ShV3.png)\n\n\n**扩展分页**\n\n允许页框大小为4MB，而不是4KB\n\n**物理地址扩展（PAE)**\n\n为了 映射大于4GB的内存地址空间。\n\n**64位系统中的分页***\n\n![enter image description here](http://blog.chinaunix.net/attachment/201208/3/24708340_134398508372jC.png)\n\n\n**硬件高速缓存Cache**\n\n缩小CPU和RAM之间的速度不匹配，引入了硬件高速缓存内存(hardware cache memory) 是在分页单元之后和内存之前，cache存放的是读写数据，地址是**物理地址匹配而非线性地址**\n\n**转换后援缓冲器(TLB)**\n\n80x86处理器还包含了另一个TLB(Translation Lookaside Buffer)的高速缓存用于加快线性地址的转换。\n\n关键是什么时候TLB失效\n\n#### Linux中的分页\n\n- 页全局目录(Page Global Directory)\n\n- 页上级目录(Page Upper Directory)\n\n- 页中间目录(Page Middle Directory)\n\n- 页表(Page Table)\n\n> 对于没有启用物理地址扩展的32位系统，两级页表已经足够了，Linux通过使**“页上级目录”位和“页中间目录”位全为0**，从根本上取消了页上级目录和页中间目录字段。不过这两个目录在指针序列中的位置被保留，以便同样的代码在32位和64位系统都能使用。\n\n\n\n\n\n----\n\n## 问题\n\n\n1. TSSD 是干吗的?\n\n用于保存处理器寄存器的内容。\n\n2.  懒惰TLB\n\n","source":"_posts/Linux_Read.md","raw":"---\ntitle: Linux内核读书笔记1\ndate: 2016-03-31 01:50:15\ntags: [linux,linux内核]\ncategories: linux内核分析\n---\n\n\n\n\n### 一、整体概念\n\n![enter image description here](http://blog.chinaunix.net/attachment/201208/3/24708340_1343984974Ejr8.png)\n\n内存寻址大概要经过这几种转换\n\n逻辑地址： 由段和偏移量构成。 面向开发人员的\n\n线性地址： 一个32bit无符号位数 取值范围从0x00000000 ~ 0xffffffff\n\n物理地址:\t\t真正对应内存的地址，有地址总线对应的。32bit或者**36bit**（intel 在 Pentium Pro 后 增加了引脚，但是要系统支持PAE）\n\n需要内存管理单元（**MMU**）硬件支持才能进行地址转换\n\n需要**分段单元** 和**分页单元**\n\n另外mmu还应该包含 内存仲裁器 用来协调多处理器访存和DMA\n\n### 二、关于分段\n\n（*分段 和 分页 都需要cpu进入保护模式 实模式用来操作初期自举*）\n\n- ####段选择符\n\t\n\t段选择符放在**段寄存器**中 ，cs 代码段寄存器  ds数据段寄存器  ss栈段寄存器\n\n> Cs寄存器还有一个重要功能，它包含一个两位字段，用以指明CPU的当前特权级（Current Privilege level，CPL），0表示最高，3代表最低优先级。Linux只用0级和3级，分别称为内核态和用户态。\n\n特权级越大 特权越低\n\n（关于EPL = Max(CPL ,RPL) <= DPL 成立则 可以访问）\n\n段选择符有16bit  包含：\n\n- 索引号\n- 表指示器 gdt or ldt\n- RPL 请求者特权级\n\n- ####段描述符\n\n8byte 用来描述段的特征\n\n存放在 GDT 和 LDT中 ， 在内存的地址分别放在 gdtr 和 ldtr 控制寄存器中 \n\n主要包含了Base **段首字节的地址** （一般首字节的地址指向的内容为0 用来标记 段偏移量异常）\n\n**Limit 用来决定段的长度**\n\n**DPL 描述符特权级**\n\n**快速访问段描述符**\n为了加速逻辑地址到线性地址的转换，80x86提供了**一个附加的不可编程的寄存器，供6个段寄存器使用，包含8个字节的段描述符。**每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入对应的非编程的CPU寄存器。这样，逻辑地址到线性地址转换就不用访问主存中的GDT或LDT。除非段寄存器内容有改变时。\n\n**分段单元**执行以下操作：\n\n1. 先检查段选择符的TI字段，以决定段选择符在GDT还是LDT中。\n2. 从index字段计算段描述符的地址，index值*8+gdtr/ldtr\n3. 逻辑地址偏移量与段描述符的Base字段相加减，得到线性地址。\n\n![enter image description here](http://blog.chinaunix.net/attachment/201208/3/24708340_1343985016OjVi.png)\n\n\nlinux不喜欢分段。！\n\n**这里是平坦模式寻址**\n\n一般的段模式不同程序都会是不同的段，但是这里的保护模式下的平坦模式把整个内存映射成了一个巨大的数组。\n\n\n\n运行在用户态的所有Linux进程都使用一对相同的段来寻址，即用户代码段，用户数据段。\n\n\n###   三、 关于分页\n\n把线性地址映射到物理地址的数据结构叫**页表**(page table),页表在主存中，在启动分页单元之前必须由内核对页表进行适当的初始化。\n\ncr0寄存器 PG标志位 =1 表示启动页表\n\n从80386起，intel的分页单元处理4KB的页，32位的线性地址被分成3个域：\n \n- Directory（页目录），最高10位\n\n- Table（页表），中间10位\n\n- Offset（偏移量），最低12位 \n\n线性地址的转换分两步，每一步都基于一种转换表，第一种是页目录表(page directory)，第二种是页表(page table).\n\n页目录的物理地址放在cr3\n\n页表项和页目录项主要结构：\n> Present 标志 表示 是否在内存中\n>\n> 20bit 页框物理地址\n\n>dirty 标志：写操作操作系统设置 \n\n> accessed标志：对页框寻址OS设置 \n\n> read/write标志：存取权限\n\n。。。。\n\n![enter image description here](http://blog.chinaunix.net/attachment/201208/3/24708340_1343985052ShV3.png)\n\n\n**扩展分页**\n\n允许页框大小为4MB，而不是4KB\n\n**物理地址扩展（PAE)**\n\n为了 映射大于4GB的内存地址空间。\n\n**64位系统中的分页***\n\n![enter image description here](http://blog.chinaunix.net/attachment/201208/3/24708340_134398508372jC.png)\n\n\n**硬件高速缓存Cache**\n\n缩小CPU和RAM之间的速度不匹配，引入了硬件高速缓存内存(hardware cache memory) 是在分页单元之后和内存之前，cache存放的是读写数据，地址是**物理地址匹配而非线性地址**\n\n**转换后援缓冲器(TLB)**\n\n80x86处理器还包含了另一个TLB(Translation Lookaside Buffer)的高速缓存用于加快线性地址的转换。\n\n关键是什么时候TLB失效\n\n#### Linux中的分页\n\n- 页全局目录(Page Global Directory)\n\n- 页上级目录(Page Upper Directory)\n\n- 页中间目录(Page Middle Directory)\n\n- 页表(Page Table)\n\n> 对于没有启用物理地址扩展的32位系统，两级页表已经足够了，Linux通过使**“页上级目录”位和“页中间目录”位全为0**，从根本上取消了页上级目录和页中间目录字段。不过这两个目录在指针序列中的位置被保留，以便同样的代码在32位和64位系统都能使用。\n\n\n\n\n\n----\n\n## 问题\n\n\n1. TSSD 是干吗的?\n\n用于保存处理器寄存器的内容。\n\n2.  懒惰TLB\n\n","slug":"Linux_Read","published":1,"updated":"2016-03-31T16:52:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt670010679y77mx3hvs","content":"<h3 id=\"一、整体概念\"><a href=\"#一、整体概念\" class=\"headerlink\" title=\"一、整体概念\"></a>一、整体概念</h3><p><img src=\"http://blog.chinaunix.net/attachment/201208/3/24708340_1343984974Ejr8.png\" alt=\"enter image description here\"></p>\n<p>内存寻址大概要经过这几种转换</p>\n<p>逻辑地址： 由段和偏移量构成。 面向开发人员的</p>\n<p>线性地址： 一个32bit无符号位数 取值范围从0x00000000 ~ 0xffffffff</p>\n<p>物理地址:        真正对应内存的地址，有地址总线对应的。32bit或者<strong>36bit</strong>（intel 在 Pentium Pro 后 增加了引脚，但是要系统支持PAE）</p>\n<p>需要内存管理单元（<strong>MMU</strong>）硬件支持才能进行地址转换</p>\n<p>需要<strong>分段单元</strong> 和<strong>分页单元</strong></p>\n<p>另外mmu还应该包含 内存仲裁器 用来协调多处理器访存和DMA</p>\n<h3 id=\"二、关于分段\"><a href=\"#二、关于分段\" class=\"headerlink\" title=\"二、关于分段\"></a>二、关于分段</h3><p>（<em>分段 和 分页 都需要cpu进入保护模式 实模式用来操作初期自举</em>）</p>\n<ul>\n<li><p>####段选择符</p>\n<p>  段选择符放在<strong>段寄存器</strong>中 ，cs 代码段寄存器  ds数据段寄存器  ss栈段寄存器</p>\n</li>\n</ul>\n<blockquote>\n<p>Cs寄存器还有一个重要功能，它包含一个两位字段，用以指明CPU的当前特权级（Current Privilege level，CPL），0表示最高，3代表最低优先级。Linux只用0级和3级，分别称为内核态和用户态。</p>\n</blockquote>\n<p>特权级越大 特权越低</p>\n<p>（关于EPL = Max(CPL ,RPL) &lt;= DPL 成立则 可以访问）</p>\n<p>段选择符有16bit  包含：</p>\n<ul>\n<li>索引号</li>\n<li>表指示器 gdt or ldt</li>\n<li><p>RPL 请求者特权级</p>\n</li>\n<li><p>####段描述符</p>\n</li>\n</ul>\n<p>8byte 用来描述段的特征</p>\n<p>存放在 GDT 和 LDT中 ， 在内存的地址分别放在 gdtr 和 ldtr 控制寄存器中 </p>\n<p>主要包含了Base <strong>段首字节的地址</strong> （一般首字节的地址指向的内容为0 用来标记 段偏移量异常）</p>\n<p><strong>Limit 用来决定段的长度</strong></p>\n<p><strong>DPL 描述符特权级</strong></p>\n<p><strong>快速访问段描述符</strong><br>为了加速逻辑地址到线性地址的转换，80x86提供了<strong>一个附加的不可编程的寄存器，供6个段寄存器使用，包含8个字节的段描述符。</strong>每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入对应的非编程的CPU寄存器。这样，逻辑地址到线性地址转换就不用访问主存中的GDT或LDT。除非段寄存器内容有改变时。</p>\n<p><strong>分段单元</strong>执行以下操作：</p>\n<ol>\n<li>先检查段选择符的TI字段，以决定段选择符在GDT还是LDT中。</li>\n<li>从index字段计算段描述符的地址，index值*8+gdtr/ldtr</li>\n<li>逻辑地址偏移量与段描述符的Base字段相加减，得到线性地址。</li>\n</ol>\n<p><img src=\"http://blog.chinaunix.net/attachment/201208/3/24708340_1343985016OjVi.png\" alt=\"enter image description here\"></p>\n<p>linux不喜欢分段。！</p>\n<p><strong>这里是平坦模式寻址</strong></p>\n<p>一般的段模式不同程序都会是不同的段，但是这里的保护模式下的平坦模式把整个内存映射成了一个巨大的数组。</p>\n<p>运行在用户态的所有Linux进程都使用一对相同的段来寻址，即用户代码段，用户数据段。</p>\n<h3 id=\"三、-关于分页\"><a href=\"#三、-关于分页\" class=\"headerlink\" title=\"三、 关于分页\"></a>三、 关于分页</h3><p>把线性地址映射到物理地址的数据结构叫<strong>页表</strong>(page table),页表在主存中，在启动分页单元之前必须由内核对页表进行适当的初始化。</p>\n<p>cr0寄存器 PG标志位 =1 表示启动页表</p>\n<p>从80386起，intel的分页单元处理4KB的页，32位的线性地址被分成3个域：</p>\n<ul>\n<li><p>Directory（页目录），最高10位</p>\n</li>\n<li><p>Table（页表），中间10位</p>\n</li>\n<li><p>Offset（偏移量），最低12位 </p>\n</li>\n</ul>\n<p>线性地址的转换分两步，每一步都基于一种转换表，第一种是页目录表(page directory)，第二种是页表(page table).</p>\n<p>页目录的物理地址放在cr3</p>\n<p>页表项和页目录项主要结构：</p>\n<blockquote>\n<p>Present 标志 表示 是否在内存中</p>\n<p>20bit 页框物理地址</p>\n<p>dirty 标志：写操作操作系统设置 </p>\n<p>accessed标志：对页框寻址OS设置 </p>\n<p>read/write标志：存取权限</p>\n</blockquote>\n<p>。。。。</p>\n<p><img src=\"http://blog.chinaunix.net/attachment/201208/3/24708340_1343985052ShV3.png\" alt=\"enter image description here\"></p>\n<p><strong>扩展分页</strong></p>\n<p>允许页框大小为4MB，而不是4KB</p>\n<p><strong>物理地址扩展（PAE)</strong></p>\n<p>为了 映射大于4GB的内存地址空间。</p>\n<p><strong>64位系统中的分页*</strong></p>\n<p><img src=\"http://blog.chinaunix.net/attachment/201208/3/24708340_134398508372jC.png\" alt=\"enter image description here\"></p>\n<p><strong>硬件高速缓存Cache</strong></p>\n<p>缩小CPU和RAM之间的速度不匹配，引入了硬件高速缓存内存(hardware cache memory) 是在分页单元之后和内存之前，cache存放的是读写数据，地址是<strong>物理地址匹配而非线性地址</strong></p>\n<p><strong>转换后援缓冲器(TLB)</strong></p>\n<p>80x86处理器还包含了另一个TLB(Translation Lookaside Buffer)的高速缓存用于加快线性地址的转换。</p>\n<p>关键是什么时候TLB失效</p>\n<h4 id=\"Linux中的分页\"><a href=\"#Linux中的分页\" class=\"headerlink\" title=\"Linux中的分页\"></a>Linux中的分页</h4><ul>\n<li><p>页全局目录(Page Global Directory)</p>\n</li>\n<li><p>页上级目录(Page Upper Directory)</p>\n</li>\n<li><p>页中间目录(Page Middle Directory)</p>\n</li>\n<li><p>页表(Page Table)</p>\n</li>\n</ul>\n<blockquote>\n<p>对于没有启用物理地址扩展的32位系统，两级页表已经足够了，Linux通过使<strong>“页上级目录”位和“页中间目录”位全为0</strong>，从根本上取消了页上级目录和页中间目录字段。不过这两个目录在指针序列中的位置被保留，以便同样的代码在32位和64位系统都能使用。</p>\n</blockquote>\n<hr>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>TSSD 是干吗的?</li>\n</ol>\n<p>用于保存处理器寄存器的内容。</p>\n<ol>\n<li>懒惰TLB</li>\n</ol>\n","excerpt":"","more":"<h3 id=\"一、整体概念\"><a href=\"#一、整体概念\" class=\"headerlink\" title=\"一、整体概念\"></a>一、整体概念</h3><p><img src=\"http://blog.chinaunix.net/attachment/201208/3/24708340_1343984974Ejr8.png\" alt=\"enter image description here\"></p>\n<p>内存寻址大概要经过这几种转换</p>\n<p>逻辑地址： 由段和偏移量构成。 面向开发人员的</p>\n<p>线性地址： 一个32bit无符号位数 取值范围从0x00000000 ~ 0xffffffff</p>\n<p>物理地址:        真正对应内存的地址，有地址总线对应的。32bit或者<strong>36bit</strong>（intel 在 Pentium Pro 后 增加了引脚，但是要系统支持PAE）</p>\n<p>需要内存管理单元（<strong>MMU</strong>）硬件支持才能进行地址转换</p>\n<p>需要<strong>分段单元</strong> 和<strong>分页单元</strong></p>\n<p>另外mmu还应该包含 内存仲裁器 用来协调多处理器访存和DMA</p>\n<h3 id=\"二、关于分段\"><a href=\"#二、关于分段\" class=\"headerlink\" title=\"二、关于分段\"></a>二、关于分段</h3><p>（<em>分段 和 分页 都需要cpu进入保护模式 实模式用来操作初期自举</em>）</p>\n<ul>\n<li><p>####段选择符</p>\n<p>  段选择符放在<strong>段寄存器</strong>中 ，cs 代码段寄存器  ds数据段寄存器  ss栈段寄存器</p>\n</li>\n</ul>\n<blockquote>\n<p>Cs寄存器还有一个重要功能，它包含一个两位字段，用以指明CPU的当前特权级（Current Privilege level，CPL），0表示最高，3代表最低优先级。Linux只用0级和3级，分别称为内核态和用户态。</p>\n</blockquote>\n<p>特权级越大 特权越低</p>\n<p>（关于EPL = Max(CPL ,RPL) &lt;= DPL 成立则 可以访问）</p>\n<p>段选择符有16bit  包含：</p>\n<ul>\n<li>索引号</li>\n<li>表指示器 gdt or ldt</li>\n<li><p>RPL 请求者特权级</p>\n</li>\n<li><p>####段描述符</p>\n</li>\n</ul>\n<p>8byte 用来描述段的特征</p>\n<p>存放在 GDT 和 LDT中 ， 在内存的地址分别放在 gdtr 和 ldtr 控制寄存器中 </p>\n<p>主要包含了Base <strong>段首字节的地址</strong> （一般首字节的地址指向的内容为0 用来标记 段偏移量异常）</p>\n<p><strong>Limit 用来决定段的长度</strong></p>\n<p><strong>DPL 描述符特权级</strong></p>\n<p><strong>快速访问段描述符</strong><br>为了加速逻辑地址到线性地址的转换，80x86提供了<strong>一个附加的不可编程的寄存器，供6个段寄存器使用，包含8个字节的段描述符。</strong>每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入对应的非编程的CPU寄存器。这样，逻辑地址到线性地址转换就不用访问主存中的GDT或LDT。除非段寄存器内容有改变时。</p>\n<p><strong>分段单元</strong>执行以下操作：</p>\n<ol>\n<li>先检查段选择符的TI字段，以决定段选择符在GDT还是LDT中。</li>\n<li>从index字段计算段描述符的地址，index值*8+gdtr/ldtr</li>\n<li>逻辑地址偏移量与段描述符的Base字段相加减，得到线性地址。</li>\n</ol>\n<p><img src=\"http://blog.chinaunix.net/attachment/201208/3/24708340_1343985016OjVi.png\" alt=\"enter image description here\"></p>\n<p>linux不喜欢分段。！</p>\n<p><strong>这里是平坦模式寻址</strong></p>\n<p>一般的段模式不同程序都会是不同的段，但是这里的保护模式下的平坦模式把整个内存映射成了一个巨大的数组。</p>\n<p>运行在用户态的所有Linux进程都使用一对相同的段来寻址，即用户代码段，用户数据段。</p>\n<h3 id=\"三、-关于分页\"><a href=\"#三、-关于分页\" class=\"headerlink\" title=\"三、 关于分页\"></a>三、 关于分页</h3><p>把线性地址映射到物理地址的数据结构叫<strong>页表</strong>(page table),页表在主存中，在启动分页单元之前必须由内核对页表进行适当的初始化。</p>\n<p>cr0寄存器 PG标志位 =1 表示启动页表</p>\n<p>从80386起，intel的分页单元处理4KB的页，32位的线性地址被分成3个域：</p>\n<ul>\n<li><p>Directory（页目录），最高10位</p>\n</li>\n<li><p>Table（页表），中间10位</p>\n</li>\n<li><p>Offset（偏移量），最低12位 </p>\n</li>\n</ul>\n<p>线性地址的转换分两步，每一步都基于一种转换表，第一种是页目录表(page directory)，第二种是页表(page table).</p>\n<p>页目录的物理地址放在cr3</p>\n<p>页表项和页目录项主要结构：</p>\n<blockquote>\n<p>Present 标志 表示 是否在内存中</p>\n<p>20bit 页框物理地址</p>\n<p>dirty 标志：写操作操作系统设置 </p>\n<p>accessed标志：对页框寻址OS设置 </p>\n<p>read/write标志：存取权限</p>\n</blockquote>\n<p>。。。。</p>\n<p><img src=\"http://blog.chinaunix.net/attachment/201208/3/24708340_1343985052ShV3.png\" alt=\"enter image description here\"></p>\n<p><strong>扩展分页</strong></p>\n<p>允许页框大小为4MB，而不是4KB</p>\n<p><strong>物理地址扩展（PAE)</strong></p>\n<p>为了 映射大于4GB的内存地址空间。</p>\n<p><strong>64位系统中的分页*</strong></p>\n<p><img src=\"http://blog.chinaunix.net/attachment/201208/3/24708340_134398508372jC.png\" alt=\"enter image description here\"></p>\n<p><strong>硬件高速缓存Cache</strong></p>\n<p>缩小CPU和RAM之间的速度不匹配，引入了硬件高速缓存内存(hardware cache memory) 是在分页单元之后和内存之前，cache存放的是读写数据，地址是<strong>物理地址匹配而非线性地址</strong></p>\n<p><strong>转换后援缓冲器(TLB)</strong></p>\n<p>80x86处理器还包含了另一个TLB(Translation Lookaside Buffer)的高速缓存用于加快线性地址的转换。</p>\n<p>关键是什么时候TLB失效</p>\n<h4 id=\"Linux中的分页\"><a href=\"#Linux中的分页\" class=\"headerlink\" title=\"Linux中的分页\"></a>Linux中的分页</h4><ul>\n<li><p>页全局目录(Page Global Directory)</p>\n</li>\n<li><p>页上级目录(Page Upper Directory)</p>\n</li>\n<li><p>页中间目录(Page Middle Directory)</p>\n</li>\n<li><p>页表(Page Table)</p>\n</li>\n</ul>\n<blockquote>\n<p>对于没有启用物理地址扩展的32位系统，两级页表已经足够了，Linux通过使<strong>“页上级目录”位和“页中间目录”位全为0</strong>，从根本上取消了页上级目录和页中间目录字段。不过这两个目录在指针序列中的位置被保留，以便同样的代码在32位和64位系统都能使用。</p>\n</blockquote>\n<hr>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>TSSD 是干吗的?</li>\n</ol>\n<p>用于保存处理器寄存器的内容。</p>\n<ol>\n<li>懒惰TLB</li>\n</ol>\n"},{"title":"junit5的相关说明","date":"2016-03-30T16:50:15.000Z","_content":"\n >  Junit上一次大版本更新已经是在10年前了。Junit后来变得维护，出现了有很多未解决的bug以及并没有融入java尤其是java8的新特性导致已经有些跟不上时代了。因此Marc Philipp 进行众筹junit-lamabda活动，让更多的开发者参与到新的junit项目来，为junit提供更好服务和扩展。 \n >  junit 5 是基于 junit-lamabda诞生的。\n\n*开源软件要不有基金会。要不然有社区氛围才行。不然真的很难坚持，众筹这个方法挺好*\n\n[indiegogo的众筹首页](https://www.indiegogo.com/projects/junit-lambda#/)\n\n------------------------------------\n\n##### 目前版本情况：\n\njunit 5 已经推出了alpha版本，预计今年4月底的时候会发布5.0 M1。\n\n\n*[github上里程碑](https://github.com/junit-team/junit5/milestones)*\n\n\n##### 关于新的特点：\n\n*具体可以参考[user guide ](http://junit.org/junit5/)*\n\n1. Annotation 产生了变化 之前的feature 特性有不同\n\n- @Before and @After no longer exist; use @BeforeEach and @AfterEach instead.\n- @BeforeClass and @AfterClass no longer exist; use @BeforeAll and @AfterAll instead.\n- @Ignore no longer exists: use @Disabled instead.\n- @Category no longer exists; use @Tag instead.\n- @RunWith no longer exists; superseded by @ExtendWith.\n- @Rule and @ClassRule no longer exist; superseded by @ExtendWith.\n\n2. grouped assertions，支持lamada以及assert 多个值进行判断\n\n``` java\n//junit4 断言只能判断一个值就会中断\nassertAll(\"address\",\n            () -> assertEquals(\"John\", address.getFirstName()),\n            () -> assertEquals(\"User\", address.getLastName())\n        );\n     \n```\n\n3.  **extension model**  扩展你的程序\n提供了 单独的 extension api。\n之前必须要重写 runner 或者rule 或者class rule 才可以。 扩展性更加统一了。强大了。\n\n4.  **The JUnit 5 Launcher API** 更加强大而且独立的启动选项\t\n主要强大的地方在于提供了  discover, filter, and execute JUnit tests. 的机制。\n \n 独立性比原来更好。可以从外部配置以及执行\n 而且希望第三方运行库包括Spock, Cucumber, and FitNesse 可以结合进来。\n\n5.  其他小地方\n- 可以在test方法里面添加参数 以及 添加日志信息\nMethodParameterResolver \n这个地方是可以通过extension api扩展的\n- 嵌套测试\n\n- 对测试异常的支持 expectthrows 提供简单的方式支持复杂的异常断言\n``` java\nThrowable exception = expectThrows(IllegalArgumentException.class,\n            () -> { throw new IllegalArgumentException(\"a message\"); }\n    );\n\n    assertEquals(\"a message\", exception.getMessage());\n```\n\n\n\n\n\n\n--------------------\n参考：\n\nhttp://blog.csdn.net/chszs/article/details/50662639\n\nhttp://www.infoq.com/cn/news/2016/03/junit5-alpha\n\n\n","source":"_posts/junit5的相关说明.md","raw":"---\ntitle: junit5的相关说明\ndate: 2016-03-31 01:50:15\ntags: 测试\ncategories:\n---\n\n >  Junit上一次大版本更新已经是在10年前了。Junit后来变得维护，出现了有很多未解决的bug以及并没有融入java尤其是java8的新特性导致已经有些跟不上时代了。因此Marc Philipp 进行众筹junit-lamabda活动，让更多的开发者参与到新的junit项目来，为junit提供更好服务和扩展。 \n >  junit 5 是基于 junit-lamabda诞生的。\n\n*开源软件要不有基金会。要不然有社区氛围才行。不然真的很难坚持，众筹这个方法挺好*\n\n[indiegogo的众筹首页](https://www.indiegogo.com/projects/junit-lambda#/)\n\n------------------------------------\n\n##### 目前版本情况：\n\njunit 5 已经推出了alpha版本，预计今年4月底的时候会发布5.0 M1。\n\n\n*[github上里程碑](https://github.com/junit-team/junit5/milestones)*\n\n\n##### 关于新的特点：\n\n*具体可以参考[user guide ](http://junit.org/junit5/)*\n\n1. Annotation 产生了变化 之前的feature 特性有不同\n\n- @Before and @After no longer exist; use @BeforeEach and @AfterEach instead.\n- @BeforeClass and @AfterClass no longer exist; use @BeforeAll and @AfterAll instead.\n- @Ignore no longer exists: use @Disabled instead.\n- @Category no longer exists; use @Tag instead.\n- @RunWith no longer exists; superseded by @ExtendWith.\n- @Rule and @ClassRule no longer exist; superseded by @ExtendWith.\n\n2. grouped assertions，支持lamada以及assert 多个值进行判断\n\n``` java\n//junit4 断言只能判断一个值就会中断\nassertAll(\"address\",\n            () -> assertEquals(\"John\", address.getFirstName()),\n            () -> assertEquals(\"User\", address.getLastName())\n        );\n     \n```\n\n3.  **extension model**  扩展你的程序\n提供了 单独的 extension api。\n之前必须要重写 runner 或者rule 或者class rule 才可以。 扩展性更加统一了。强大了。\n\n4.  **The JUnit 5 Launcher API** 更加强大而且独立的启动选项\t\n主要强大的地方在于提供了  discover, filter, and execute JUnit tests. 的机制。\n \n 独立性比原来更好。可以从外部配置以及执行\n 而且希望第三方运行库包括Spock, Cucumber, and FitNesse 可以结合进来。\n\n5.  其他小地方\n- 可以在test方法里面添加参数 以及 添加日志信息\nMethodParameterResolver \n这个地方是可以通过extension api扩展的\n- 嵌套测试\n\n- 对测试异常的支持 expectthrows 提供简单的方式支持复杂的异常断言\n``` java\nThrowable exception = expectThrows(IllegalArgumentException.class,\n            () -> { throw new IllegalArgumentException(\"a message\"); }\n    );\n\n    assertEquals(\"a message\", exception.getMessage());\n```\n\n\n\n\n\n\n--------------------\n参考：\n\nhttp://blog.csdn.net/chszs/article/details/50662639\n\nhttp://www.infoq.com/cn/news/2016/03/junit5-alpha\n\n\n","slug":"junit5的相关说明","published":1,"updated":"2016-03-31T16:52:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt690014679y9s5brdqd","content":"<blockquote>\n<p> Junit上一次大版本更新已经是在10年前了。Junit后来变得维护，出现了有很多未解决的bug以及并没有融入java尤其是java8的新特性导致已经有些跟不上时代了。因此Marc Philipp 进行众筹junit-lamabda活动，让更多的开发者参与到新的junit项目来，为junit提供更好服务和扩展。<br> junit 5 是基于 junit-lamabda诞生的。</p>\n</blockquote>\n<p><em>开源软件要不有基金会。要不然有社区氛围才行。不然真的很难坚持，众筹这个方法挺好</em></p>\n<p><a href=\"https://www.indiegogo.com/projects/junit-lambda#/\" target=\"_blank\" rel=\"external\">indiegogo的众筹首页</a></p>\n<hr>\n<h5 id=\"目前版本情况：\"><a href=\"#目前版本情况：\" class=\"headerlink\" title=\"目前版本情况：\"></a>目前版本情况：</h5><p>junit 5 已经推出了alpha版本，预计今年4月底的时候会发布5.0 M1。</p>\n<p><em><a href=\"https://github.com/junit-team/junit5/milestones\" target=\"_blank\" rel=\"external\">github上里程碑</a></em></p>\n<h5 id=\"关于新的特点：\"><a href=\"#关于新的特点：\" class=\"headerlink\" title=\"关于新的特点：\"></a>关于新的特点：</h5><p><em>具体可以参考<a href=\"http://junit.org/junit5/\" target=\"_blank\" rel=\"external\">user guide </a></em></p>\n<ol>\n<li>Annotation 产生了变化 之前的feature 特性有不同</li>\n</ol>\n<ul>\n<li>@Before and @After no longer exist; use @BeforeEach and @AfterEach instead.</li>\n<li>@BeforeClass and @AfterClass no longer exist; use @BeforeAll and @AfterAll instead.</li>\n<li>@Ignore no longer exists: use @Disabled instead.</li>\n<li>@Category no longer exists; use @Tag instead.</li>\n<li>@RunWith no longer exists; superseded by @ExtendWith.</li>\n<li>@Rule and @ClassRule no longer exist; superseded by @ExtendWith.</li>\n</ul>\n<ol>\n<li>grouped assertions，支持lamada以及assert 多个值进行判断</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//junit4 断言只能判断一个值就会中断</span></span><br><span class=\"line\">assertAll(<span class=\"string\">\"address\"</span>,</span><br><span class=\"line\">            () -&gt; assertEquals(<span class=\"string\">\"John\"</span>, address.getFirstName()),</span><br><span class=\"line\">            () -&gt; assertEquals(<span class=\"string\">\"User\"</span>, address.getLastName())</span><br><span class=\"line\">        );</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p><strong>extension model</strong>  扩展你的程序<br>提供了 单独的 extension api。<br>之前必须要重写 runner 或者rule 或者class rule 才可以。 扩展性更加统一了。强大了。</p>\n</li>\n<li><p><strong>The JUnit 5 Launcher API</strong> 更加强大而且独立的启动选项<br>主要强大的地方在于提供了  discover, filter, and execute JUnit tests. 的机制。</p>\n<p>独立性比原来更好。可以从外部配置以及执行<br>而且希望第三方运行库包括Spock, Cucumber, and FitNesse 可以结合进来。</p>\n</li>\n<li><p>其他小地方</p>\n</li>\n</ol>\n<ul>\n<li>可以在test方法里面添加参数 以及 添加日志信息<br>MethodParameterResolver<br>这个地方是可以通过extension api扩展的</li>\n<li><p>嵌套测试</p>\n</li>\n<li><p>对测试异常的支持 expectthrows 提供简单的方式支持复杂的异常断言</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Throwable exception = expectThrows(IllegalArgumentException.class,</span><br><span class=\"line\">            () -&gt; &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"a message\"</span>); &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    assertEquals(<span class=\"string\">\"a message\"</span>, exception.getMessage());</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>参考：</p>\n<p><a href=\"http://blog.csdn.net/chszs/article/details/50662639\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chszs/article/details/50662639</a></p>\n<p><a href=\"http://www.infoq.com/cn/news/2016/03/junit5-alpha\" target=\"_blank\" rel=\"external\">http://www.infoq.com/cn/news/2016/03/junit5-alpha</a></p>\n","excerpt":"","more":"<blockquote>\n<p> Junit上一次大版本更新已经是在10年前了。Junit后来变得维护，出现了有很多未解决的bug以及并没有融入java尤其是java8的新特性导致已经有些跟不上时代了。因此Marc Philipp 进行众筹junit-lamabda活动，让更多的开发者参与到新的junit项目来，为junit提供更好服务和扩展。<br> junit 5 是基于 junit-lamabda诞生的。</p>\n</blockquote>\n<p><em>开源软件要不有基金会。要不然有社区氛围才行。不然真的很难坚持，众筹这个方法挺好</em></p>\n<p><a href=\"https://www.indiegogo.com/projects/junit-lambda#/\">indiegogo的众筹首页</a></p>\n<hr>\n<h5 id=\"目前版本情况：\"><a href=\"#目前版本情况：\" class=\"headerlink\" title=\"目前版本情况：\"></a>目前版本情况：</h5><p>junit 5 已经推出了alpha版本，预计今年4月底的时候会发布5.0 M1。</p>\n<p><em><a href=\"https://github.com/junit-team/junit5/milestones\">github上里程碑</a></em></p>\n<h5 id=\"关于新的特点：\"><a href=\"#关于新的特点：\" class=\"headerlink\" title=\"关于新的特点：\"></a>关于新的特点：</h5><p><em>具体可以参考<a href=\"http://junit.org/junit5/\">user guide </a></em></p>\n<ol>\n<li>Annotation 产生了变化 之前的feature 特性有不同</li>\n</ol>\n<ul>\n<li>@Before and @After no longer exist; use @BeforeEach and @AfterEach instead.</li>\n<li>@BeforeClass and @AfterClass no longer exist; use @BeforeAll and @AfterAll instead.</li>\n<li>@Ignore no longer exists: use @Disabled instead.</li>\n<li>@Category no longer exists; use @Tag instead.</li>\n<li>@RunWith no longer exists; superseded by @ExtendWith.</li>\n<li>@Rule and @ClassRule no longer exist; superseded by @ExtendWith.</li>\n</ul>\n<ol>\n<li>grouped assertions，支持lamada以及assert 多个值进行判断</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//junit4 断言只能判断一个值就会中断</span></span><br><span class=\"line\">assertAll(<span class=\"string\">\"address\"</span>,</span><br><span class=\"line\">            () -&gt; assertEquals(<span class=\"string\">\"John\"</span>, address.getFirstName()),</span><br><span class=\"line\">            () -&gt; assertEquals(<span class=\"string\">\"User\"</span>, address.getLastName())</span><br><span class=\"line\">        );</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p><strong>extension model</strong>  扩展你的程序<br>提供了 单独的 extension api。<br>之前必须要重写 runner 或者rule 或者class rule 才可以。 扩展性更加统一了。强大了。</p>\n</li>\n<li><p><strong>The JUnit 5 Launcher API</strong> 更加强大而且独立的启动选项<br>主要强大的地方在于提供了  discover, filter, and execute JUnit tests. 的机制。</p>\n<p>独立性比原来更好。可以从外部配置以及执行<br>而且希望第三方运行库包括Spock, Cucumber, and FitNesse 可以结合进来。</p>\n</li>\n<li><p>其他小地方</p>\n</li>\n</ol>\n<ul>\n<li>可以在test方法里面添加参数 以及 添加日志信息<br>MethodParameterResolver<br>这个地方是可以通过extension api扩展的</li>\n<li><p>嵌套测试</p>\n</li>\n<li><p>对测试异常的支持 expectthrows 提供简单的方式支持复杂的异常断言</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Throwable exception = expectThrows(IllegalArgumentException.class,</span><br><span class=\"line\">            () -&gt; &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"a message\"</span>); &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    assertEquals(<span class=\"string\">\"a message\"</span>, exception.getMessage());</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>参考：</p>\n<p><a href=\"http://blog.csdn.net/chszs/article/details/50662639\">http://blog.csdn.net/chszs/article/details/50662639</a></p>\n<p><a href=\"http://www.infoq.com/cn/news/2016/03/junit5-alpha\">http://www.infoq.com/cn/news/2016/03/junit5-alpha</a></p>\n"},{"title":"pic-2015-04-01","date":"2016-04-03T13:24:45.000Z","_content":"![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160403_211245.jpg)\n\n\n","source":"_posts/pic-2016-04-01.md","raw":"---\ntitle: pic-2015-04-01\ntags:\n  - 动漫\n  - 手绘\ncategories: 手绘\ndate: 2016-04-03 22:24:45\n---\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160403_211245.jpg)\n\n\n","slug":"pic-2016-04-01","published":1,"updated":"2016-04-03T13:26:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt6b0017679y06ofzfji","content":"<p><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160403_211245.jpg\" alt=\"enter image description here\"></p>\n","excerpt":"","more":"<p><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160403_211245.jpg\" alt=\"enter image description here\"></p>\n"},{"title":"python 处理博客的md文件","date":"2016-03-31T17:04:42.000Z","_content":"关于 list comprehension \n\n作用是读取当前文件夹下的 md文件，然后 将###这类的标题后面加上一个空格。\n\n用到list comprehension 一个fp的特性 再此mark\n\n\n\n``` python\n#  -*- coding:utf-8 -*-\nimport re\nimport os\n\ndef changeLine(str=\"\"):\n\tp = re.compile(\"^#+\")\n\tmatch=p.match(str)\n\tif match: #and match.group(1).start:\n\t\tstr= match.group(0)+ \" \"+p.split(str)[1]\n\treturn str\n\nflist=os.listdir(\"./\")\n\nmdflist=[res for res  in flist if re.compile(\"^.*\\.md$\").match(res)]\n\nfilename='./Linux.md'\n\nfor filename in flist:\n\twith open(filename,\"r+\") as f:\n\t\tnewline=[changeLine(lineStr) for lineStr in f.readlines()]\n \t\tf.seek(0)\n\t\tf.writelines(newline)\n\n\n```\n\n### python 的 推导式\n\n列表表达式的基本格式是; \n[表达式 for 变量 in 列表]    或者  [表达式 for 变量 in 列表 if 条件]\n\npython 中支持的推导式\n\n- 列表推导式\n处理嵌套列表的实现\n```\n>>> names = [['Tom','Billy','Jefferson','Andrew','Wesley','Steven','Joe'],  \n         ['Alice','Jill','Ana','Wendy','Jennifer','Sherry','Eva']]  \n         \n>>> [name for lst in names for name in lst if name.count('e')>=2]  #注意遍历顺序，这是实现的关键  \n['Jefferson', 'Wesley', 'Steven', 'Jennifer']  \n\n看下等价的实现就理解原理了\ntmp = []  \nfor lst in names:  \n    for name in lst:  \n        if name.count('e') >= 2:  \n            tmp.append(name)  \n  \nprint tmp  \n#输出结果  \n['Jefferson', 'Wesley', 'Steven', 'Jennifer']  \n结果就是被过滤的 name\n\n```\n- 字典推导式\n```\n>>> strings = ['import','is','with','if','file','exception']  \n>>> D = {key: val for val,key in enumerate(strings)}  \n```\n\n- 集合推导式\n```\n>>> strings = ['a','is','with','if','file','exception']  \n>>> {len(s) for s in strings}    #有长度相同的会只留一个，这在实际上也非常有用  \n```\n- 生成器推导式\n*(用于列表太多占内存但是只需要计算一次的情况)*\n```\n>>>  L = (i for i in range(10) if i % 2 != 1)  \n>>> L.next() \n0 \n>>> L.next()\n2  \n```\n\n### 推导式的原理\n\n和数学上的策梅洛-弗兰克尔集合论[Zermelo-Fraenkel Set Theory](http://en.wikipedia.org/wiki/Zermelo-Frankel_set_theory)一样，被称为集合抽象\n\n> 求集合Ａ中奇数的平方\n> B = {square x | x ∈ A & odd x}\n\n\n### 总结： \n\n推导式本质是一种语法糖，它提供了一种简洁高效的方式来创建列表和迭代器\n\n很方便但是遇到复杂的情况就不好用了。比如说复杂的if判断和循环处理的时候。\n\n这里就强行写了函数用来处理。\n\n\n","source":"_posts/python-处理博客的md文件.md","raw":"---\ntitle: python 处理博客的md文件\ndate: 2016-04-01 02:04:42\ntags:\ncategories:\n---\n关于 list comprehension \n\n作用是读取当前文件夹下的 md文件，然后 将###这类的标题后面加上一个空格。\n\n用到list comprehension 一个fp的特性 再此mark\n\n\n\n``` python\n#  -*- coding:utf-8 -*-\nimport re\nimport os\n\ndef changeLine(str=\"\"):\n\tp = re.compile(\"^#+\")\n\tmatch=p.match(str)\n\tif match: #and match.group(1).start:\n\t\tstr= match.group(0)+ \" \"+p.split(str)[1]\n\treturn str\n\nflist=os.listdir(\"./\")\n\nmdflist=[res for res  in flist if re.compile(\"^.*\\.md$\").match(res)]\n\nfilename='./Linux.md'\n\nfor filename in flist:\n\twith open(filename,\"r+\") as f:\n\t\tnewline=[changeLine(lineStr) for lineStr in f.readlines()]\n \t\tf.seek(0)\n\t\tf.writelines(newline)\n\n\n```\n\n### python 的 推导式\n\n列表表达式的基本格式是; \n[表达式 for 变量 in 列表]    或者  [表达式 for 变量 in 列表 if 条件]\n\npython 中支持的推导式\n\n- 列表推导式\n处理嵌套列表的实现\n```\n>>> names = [['Tom','Billy','Jefferson','Andrew','Wesley','Steven','Joe'],  \n         ['Alice','Jill','Ana','Wendy','Jennifer','Sherry','Eva']]  \n         \n>>> [name for lst in names for name in lst if name.count('e')>=2]  #注意遍历顺序，这是实现的关键  \n['Jefferson', 'Wesley', 'Steven', 'Jennifer']  \n\n看下等价的实现就理解原理了\ntmp = []  \nfor lst in names:  \n    for name in lst:  \n        if name.count('e') >= 2:  \n            tmp.append(name)  \n  \nprint tmp  \n#输出结果  \n['Jefferson', 'Wesley', 'Steven', 'Jennifer']  \n结果就是被过滤的 name\n\n```\n- 字典推导式\n```\n>>> strings = ['import','is','with','if','file','exception']  \n>>> D = {key: val for val,key in enumerate(strings)}  \n```\n\n- 集合推导式\n```\n>>> strings = ['a','is','with','if','file','exception']  \n>>> {len(s) for s in strings}    #有长度相同的会只留一个，这在实际上也非常有用  \n```\n- 生成器推导式\n*(用于列表太多占内存但是只需要计算一次的情况)*\n```\n>>>  L = (i for i in range(10) if i % 2 != 1)  \n>>> L.next() \n0 \n>>> L.next()\n2  \n```\n\n### 推导式的原理\n\n和数学上的策梅洛-弗兰克尔集合论[Zermelo-Fraenkel Set Theory](http://en.wikipedia.org/wiki/Zermelo-Frankel_set_theory)一样，被称为集合抽象\n\n> 求集合Ａ中奇数的平方\n> B = {square x | x ∈ A & odd x}\n\n\n### 总结： \n\n推导式本质是一种语法糖，它提供了一种简洁高效的方式来创建列表和迭代器\n\n很方便但是遇到复杂的情况就不好用了。比如说复杂的if判断和循环处理的时候。\n\n这里就强行写了函数用来处理。\n\n\n","slug":"python-处理博客的md文件","published":1,"updated":"2016-04-03T13:20:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt6e001b679yo9kio4fj","content":"<p>关于 list comprehension </p>\n<p>作用是读取当前文件夹下的 md文件，然后 将###这类的标题后面加上一个空格。</p>\n<p>用到list comprehension 一个fp的特性 再此mark</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#  -*- coding:utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">changeLine</span><span class=\"params\">(str=<span class=\"string\">\"\"</span>)</span>:</span></span><br><span class=\"line\">\tp = re.compile(<span class=\"string\">\"^#+\"</span>)</span><br><span class=\"line\">\tmatch=p.match(str)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> match: <span class=\"comment\">#and match.group(1).start:</span></span><br><span class=\"line\">\t\tstr= match.group(<span class=\"number\">0</span>)+ <span class=\"string\">\" \"</span>+p.split(str)[<span class=\"number\">1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> str</span><br><span class=\"line\"></span><br><span class=\"line\">flist=os.listdir(<span class=\"string\">\"./\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">mdflist=[res <span class=\"keyword\">for</span> res  <span class=\"keyword\">in</span> flist <span class=\"keyword\">if</span> re.compile(<span class=\"string\">\"^.*\\.md$\"</span>).match(res)]</span><br><span class=\"line\"></span><br><span class=\"line\">filename=<span class=\"string\">'./Linux.md'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> filename <span class=\"keyword\">in</span> flist:</span><br><span class=\"line\">\t<span class=\"keyword\">with</span> open(filename,<span class=\"string\">\"r+\"</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">\t\tnewline=[changeLine(lineStr) <span class=\"keyword\">for</span> lineStr <span class=\"keyword\">in</span> f.readlines()]</span><br><span class=\"line\"> \t\tf.seek(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tf.writelines(newline)</span><br></pre></td></tr></table></figure>\n<h3 id=\"python-的-推导式\"><a href=\"#python-的-推导式\" class=\"headerlink\" title=\"python 的 推导式\"></a>python 的 推导式</h3><p>列表表达式的基本格式是;<br>[表达式 for 变量 in 列表]    或者  [表达式 for 变量 in 列表 if 条件]</p>\n<p>python 中支持的推导式</p>\n<ul>\n<li><p>列表推导式<br>处理嵌套列表的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; names = [[&apos;Tom&apos;,&apos;Billy&apos;,&apos;Jefferson&apos;,&apos;Andrew&apos;,&apos;Wesley&apos;,&apos;Steven&apos;,&apos;Joe&apos;],  </span><br><span class=\"line\">         [&apos;Alice&apos;,&apos;Jill&apos;,&apos;Ana&apos;,&apos;Wendy&apos;,&apos;Jennifer&apos;,&apos;Sherry&apos;,&apos;Eva&apos;]]  </span><br><span class=\"line\">         </span><br><span class=\"line\">&gt;&gt;&gt; [name for lst in names for name in lst if name.count(&apos;e&apos;)&gt;=2]  #注意遍历顺序，这是实现的关键  </span><br><span class=\"line\">[&apos;Jefferson&apos;, &apos;Wesley&apos;, &apos;Steven&apos;, &apos;Jennifer&apos;]  </span><br><span class=\"line\"></span><br><span class=\"line\">看下等价的实现就理解原理了</span><br><span class=\"line\">tmp = []  </span><br><span class=\"line\">for lst in names:  </span><br><span class=\"line\">    for name in lst:  </span><br><span class=\"line\">        if name.count(&apos;e&apos;) &gt;= 2:  </span><br><span class=\"line\">            tmp.append(name)  </span><br><span class=\"line\">  </span><br><span class=\"line\">print tmp  </span><br><span class=\"line\">#输出结果  </span><br><span class=\"line\">[&apos;Jefferson&apos;, &apos;Wesley&apos;, &apos;Steven&apos;, &apos;Jennifer&apos;]  </span><br><span class=\"line\">结果就是被过滤的 name</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字典推导式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; strings = [&apos;import&apos;,&apos;is&apos;,&apos;with&apos;,&apos;if&apos;,&apos;file&apos;,&apos;exception&apos;]  </span><br><span class=\"line\">&gt;&gt;&gt; D = &#123;key: val for val,key in enumerate(strings)&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>集合推导式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; strings = [&apos;a&apos;,&apos;is&apos;,&apos;with&apos;,&apos;if&apos;,&apos;file&apos;,&apos;exception&apos;]  </span><br><span class=\"line\">&gt;&gt;&gt; &#123;len(s) for s in strings&#125;    #有长度相同的会只留一个，这在实际上也非常有用</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成器推导式<br><em>(用于列表太多占内存但是只需要计算一次的情况)</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;  L = (i for i in range(10) if i % 2 != 1)  </span><br><span class=\"line\">&gt;&gt;&gt; L.next() </span><br><span class=\"line\">0 </span><br><span class=\"line\">&gt;&gt;&gt; L.next()</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"推导式的原理\"><a href=\"#推导式的原理\" class=\"headerlink\" title=\"推导式的原理\"></a>推导式的原理</h3><p>和数学上的策梅洛-弗兰克尔集合论<a href=\"http://en.wikipedia.org/wiki/Zermelo-Frankel_set_theory\" target=\"_blank\" rel=\"external\">Zermelo-Fraenkel Set Theory</a>一样，被称为集合抽象</p>\n<blockquote>\n<p>求集合Ａ中奇数的平方<br>B = {square x | x ∈ A &amp; odd x}</p>\n</blockquote>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>推导式本质是一种语法糖，它提供了一种简洁高效的方式来创建列表和迭代器</p>\n<p>很方便但是遇到复杂的情况就不好用了。比如说复杂的if判断和循环处理的时候。</p>\n<p>这里就强行写了函数用来处理。</p>\n","excerpt":"","more":"<p>关于 list comprehension </p>\n<p>作用是读取当前文件夹下的 md文件，然后 将###这类的标题后面加上一个空格。</p>\n<p>用到list comprehension 一个fp的特性 再此mark</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#  -*- coding:utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">changeLine</span><span class=\"params\">(str=<span class=\"string\">\"\"</span>)</span>:</span></span><br><span class=\"line\">\tp = re.compile(<span class=\"string\">\"^#+\"</span>)</span><br><span class=\"line\">\tmatch=p.match(str)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> match: <span class=\"comment\">#and match.group(1).start:</span></span><br><span class=\"line\">\t\tstr= match.group(<span class=\"number\">0</span>)+ <span class=\"string\">\" \"</span>+p.split(str)[<span class=\"number\">1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> str</span><br><span class=\"line\"></span><br><span class=\"line\">flist=os.listdir(<span class=\"string\">\"./\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">mdflist=[res <span class=\"keyword\">for</span> res  <span class=\"keyword\">in</span> flist <span class=\"keyword\">if</span> re.compile(<span class=\"string\">\"^.*\\.md$\"</span>).match(res)]</span><br><span class=\"line\"></span><br><span class=\"line\">filename=<span class=\"string\">'./Linux.md'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> filename <span class=\"keyword\">in</span> flist:</span><br><span class=\"line\">\t<span class=\"keyword\">with</span> open(filename,<span class=\"string\">\"r+\"</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">\t\tnewline=[changeLine(lineStr) <span class=\"keyword\">for</span> lineStr <span class=\"keyword\">in</span> f.readlines()]</span><br><span class=\"line\"> \t\tf.seek(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tf.writelines(newline)</span><br></pre></td></tr></table></figure>\n<h3 id=\"python-的-推导式\"><a href=\"#python-的-推导式\" class=\"headerlink\" title=\"python 的 推导式\"></a>python 的 推导式</h3><p>列表表达式的基本格式是;<br>[表达式 for 变量 in 列表]    或者  [表达式 for 变量 in 列表 if 条件]</p>\n<p>python 中支持的推导式</p>\n<ul>\n<li><p>列表推导式<br>处理嵌套列表的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; names = [[&apos;Tom&apos;,&apos;Billy&apos;,&apos;Jefferson&apos;,&apos;Andrew&apos;,&apos;Wesley&apos;,&apos;Steven&apos;,&apos;Joe&apos;],  </span><br><span class=\"line\">         [&apos;Alice&apos;,&apos;Jill&apos;,&apos;Ana&apos;,&apos;Wendy&apos;,&apos;Jennifer&apos;,&apos;Sherry&apos;,&apos;Eva&apos;]]  </span><br><span class=\"line\">         </span><br><span class=\"line\">&gt;&gt;&gt; [name for lst in names for name in lst if name.count(&apos;e&apos;)&gt;=2]  #注意遍历顺序，这是实现的关键  </span><br><span class=\"line\">[&apos;Jefferson&apos;, &apos;Wesley&apos;, &apos;Steven&apos;, &apos;Jennifer&apos;]  </span><br><span class=\"line\"></span><br><span class=\"line\">看下等价的实现就理解原理了</span><br><span class=\"line\">tmp = []  </span><br><span class=\"line\">for lst in names:  </span><br><span class=\"line\">    for name in lst:  </span><br><span class=\"line\">        if name.count(&apos;e&apos;) &gt;= 2:  </span><br><span class=\"line\">            tmp.append(name)  </span><br><span class=\"line\">  </span><br><span class=\"line\">print tmp  </span><br><span class=\"line\">#输出结果  </span><br><span class=\"line\">[&apos;Jefferson&apos;, &apos;Wesley&apos;, &apos;Steven&apos;, &apos;Jennifer&apos;]  </span><br><span class=\"line\">结果就是被过滤的 name</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字典推导式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; strings = [&apos;import&apos;,&apos;is&apos;,&apos;with&apos;,&apos;if&apos;,&apos;file&apos;,&apos;exception&apos;]  </span><br><span class=\"line\">&gt;&gt;&gt; D = &#123;key: val for val,key in enumerate(strings)&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>集合推导式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; strings = [&apos;a&apos;,&apos;is&apos;,&apos;with&apos;,&apos;if&apos;,&apos;file&apos;,&apos;exception&apos;]  </span><br><span class=\"line\">&gt;&gt;&gt; &#123;len(s) for s in strings&#125;    #有长度相同的会只留一个，这在实际上也非常有用</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成器推导式<br><em>(用于列表太多占内存但是只需要计算一次的情况)</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;  L = (i for i in range(10) if i % 2 != 1)  </span><br><span class=\"line\">&gt;&gt;&gt; L.next() </span><br><span class=\"line\">0 </span><br><span class=\"line\">&gt;&gt;&gt; L.next()</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"推导式的原理\"><a href=\"#推导式的原理\" class=\"headerlink\" title=\"推导式的原理\"></a>推导式的原理</h3><p>和数学上的策梅洛-弗兰克尔集合论<a href=\"http://en.wikipedia.org/wiki/Zermelo-Frankel_set_theory\">Zermelo-Fraenkel Set Theory</a>一样，被称为集合抽象</p>\n<blockquote>\n<p>求集合Ａ中奇数的平方<br>B = {square x | x ∈ A &amp; odd x}</p>\n</blockquote>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>推导式本质是一种语法糖，它提供了一种简洁高效的方式来创建列表和迭代器</p>\n<p>很方便但是遇到复杂的情况就不好用了。比如说复杂的if判断和循环处理的时候。</p>\n<p>这里就强行写了函数用来处理。</p>\n"},{"title":"pic_20150325","date":"2016-03-28T14:32:46.000Z","_content":"![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-original64460d1c942a2059562f19d29099f7be9f8fe900531d8-nUiuyu_fw658.jpg)\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160323_201233.jpg)\n\n\n","source":"_posts/pic-20150325.md","raw":"---\ntitle: pic_20150325\ntags:\n  - 动漫\n  - 手绘\ncategories: 手绘\ndate: 2016-03-28 23:32:46\n---\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-original64460d1c942a2059562f19d29099f7be9f8fe900531d8-nUiuyu_fw658.jpg)\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160323_201233.jpg)\n\n\n","slug":"pic-20150325","published":1,"updated":"2016-03-31T16:52:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt6f001c679ylyo14txo","content":"<p><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-original64460d1c942a2059562f19d29099f7be9f8fe900531d8-nUiuyu_fw658.jpg\" alt=\"enter image description here\"><br><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160323_201233.jpg\" alt=\"enter image description here\"></p>\n","excerpt":"","more":"<p><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-original64460d1c942a2059562f19d29099f7be9f8fe900531d8-nUiuyu_fw658.jpg\" alt=\"enter image description here\"><br><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160323_201233.jpg\" alt=\"enter image description here\"></p>\n"},{"title":"pic-2016-03-22","date":"2016-03-22T12:13:37.000Z","_content":"![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-original1eb4ff697da8ab1134aa31000f5db102878b3f4313d69c-AnOM05_fw658.png)\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160322_205640.jpg)\n\n\n","source":"_posts/pic-2016-03-22.md","raw":"---\ntitle: pic-2016-03-22\ntags:\n  - 动漫\n  - 手绘\ncategories: 手绘\ndate: 2016-03-22 21:13:37\n---\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-original1eb4ff697da8ab1134aa31000f5db102878b3f4313d69c-AnOM05_fw658.png)\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160322_205640.jpg)\n\n\n","slug":"pic-2016-03-22","published":1,"updated":"2016-03-31T16:52:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt6j001g679ymf6mxfdt","content":"<p><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-original1eb4ff697da8ab1134aa31000f5db102878b3f4313d69c-AnOM05_fw658.png\" alt=\"enter image description here\"><br><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160322_205640.jpg\" alt=\"enter image description here\"></p>\n","excerpt":"","more":"<p><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-original1eb4ff697da8ab1134aa31000f5db102878b3f4313d69c-AnOM05_fw658.png\" alt=\"enter image description here\"><br><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160322_205640.jpg\" alt=\"enter image description here\"></p>\n"},{"title":"关于通信协议的mark","date":"2016-03-30T16:50:15.000Z","_content":"\n- 讲述了二进制通信协议的演进过程\n\n    http://blog.chinaunix.net/uid-27105712-id-3266286.html     \n    //文本协议 二进制协议优势就是性能和安全性。但是调试麻烦\n\n- tlv tag—type—length—value\n\n    http://www.leicixiang.cn/type-length-value/    tlv 格式距离 翻译wikipedia\n\n- 二进制字节块 语言亲和度  优点紧凑（性能优） 易读性差（安全）\n    \n    http://coolshell.cn/tag/json\n\n    http://coolshell.cn/articles/4905.html\n\n- Protocol Buffers  !! \n\n    http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/\n\n    https://developers.google.com/protocol-buffers/docs/overview\n\n- 常用协议对比\n\n    http://www.cnblogs.com/shrimps/archive/2008/11/06/1327988.html\n\n    http://www.oschina.net/translate/choose-protocol-buffers\n\n- ---ASN.1 这个标准 \n    \n    http://blog.sina.com.cn/s/blog_72bb4bd00101cz7h.html\n\n//百度百科\n\n协议主要由以下三个要素组成：\n\n语法：“如何讲”，数据的格式、编码和信号等级（电平的高低）。\n\n语义：“讲什么”，数据内容、含义以及控制信息。\n\n时序：明确通信的顺序、速率匹配和排序 \n\n\n\nBase64编码的作用：由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。它使用下面表中所使用的字符与编码。\n非ASCII字符：主要就是二进制 比如说图片或者其他信息\n\n###### 不可见字符二进制   可见字符二进制\n\n\n","source":"_posts/通信协议的调研.md","raw":"---\ntitle: 关于通信协议的mark\ndate: 2016-03-31 01:50:15\ntags: [通信协议,技术调研]\ncategories: \n---\n\n- 讲述了二进制通信协议的演进过程\n\n    http://blog.chinaunix.net/uid-27105712-id-3266286.html     \n    //文本协议 二进制协议优势就是性能和安全性。但是调试麻烦\n\n- tlv tag—type—length—value\n\n    http://www.leicixiang.cn/type-length-value/    tlv 格式距离 翻译wikipedia\n\n- 二进制字节块 语言亲和度  优点紧凑（性能优） 易读性差（安全）\n    \n    http://coolshell.cn/tag/json\n\n    http://coolshell.cn/articles/4905.html\n\n- Protocol Buffers  !! \n\n    http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/\n\n    https://developers.google.com/protocol-buffers/docs/overview\n\n- 常用协议对比\n\n    http://www.cnblogs.com/shrimps/archive/2008/11/06/1327988.html\n\n    http://www.oschina.net/translate/choose-protocol-buffers\n\n- ---ASN.1 这个标准 \n    \n    http://blog.sina.com.cn/s/blog_72bb4bd00101cz7h.html\n\n//百度百科\n\n协议主要由以下三个要素组成：\n\n语法：“如何讲”，数据的格式、编码和信号等级（电平的高低）。\n\n语义：“讲什么”，数据内容、含义以及控制信息。\n\n时序：明确通信的顺序、速率匹配和排序 \n\n\n\nBase64编码的作用：由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。它使用下面表中所使用的字符与编码。\n非ASCII字符：主要就是二进制 比如说图片或者其他信息\n\n###### 不可见字符二进制   可见字符二进制\n\n\n","slug":"通信协议的调研","published":1,"updated":"2016-03-31T16:52:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt6l001k679ycwkehu7m","content":"<ul>\n<li><p>讲述了二进制通信协议的演进过程</p>\n<p>  <a href=\"http://blog.chinaunix.net/uid-27105712-id-3266286.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-27105712-id-3266286.html</a><br>  //文本协议 二进制协议优势就是性能和安全性。但是调试麻烦</p>\n</li>\n<li><p>tlv tag—type—length—value</p>\n<p>  <a href=\"http://www.leicixiang.cn/type-length-value/\" target=\"_blank\" rel=\"external\">http://www.leicixiang.cn/type-length-value/</a>    tlv 格式距离 翻译wikipedia</p>\n</li>\n<li><p>二进制字节块 语言亲和度  优点紧凑（性能优） 易读性差（安全）</p>\n<p>  <a href=\"http://coolshell.cn/tag/json\" target=\"_blank\" rel=\"external\">http://coolshell.cn/tag/json</a></p>\n<p>  <a href=\"http://coolshell.cn/articles/4905.html\" target=\"_blank\" rel=\"external\">http://coolshell.cn/articles/4905.html</a></p>\n</li>\n<li><p>Protocol Buffers  !! </p>\n<p>  <a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/\" target=\"_blank\" rel=\"external\">http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/</a></p>\n<p>  <a href=\"https://developers.google.com/protocol-buffers/docs/overview\" target=\"_blank\" rel=\"external\">https://developers.google.com/protocol-buffers/docs/overview</a></p>\n</li>\n<li><p>常用协议对比</p>\n<p>  <a href=\"http://www.cnblogs.com/shrimps/archive/2008/11/06/1327988.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/shrimps/archive/2008/11/06/1327988.html</a></p>\n<p>  <a href=\"http://www.oschina.net/translate/choose-protocol-buffers\" target=\"_blank\" rel=\"external\">http://www.oschina.net/translate/choose-protocol-buffers</a></p>\n</li>\n<li><p>—ASN.1 这个标准 </p>\n<p>  <a href=\"http://blog.sina.com.cn/s/blog_72bb4bd00101cz7h.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_72bb4bd00101cz7h.html</a></p>\n</li>\n</ul>\n<p>//百度百科</p>\n<p>协议主要由以下三个要素组成：</p>\n<p>语法：“如何讲”，数据的格式、编码和信号等级（电平的高低）。</p>\n<p>语义：“讲什么”，数据内容、含义以及控制信息。</p>\n<p>时序：明确通信的顺序、速率匹配和排序 </p>\n<p>Base64编码的作用：由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。它使用下面表中所使用的字符与编码。<br>非ASCII字符：主要就是二进制 比如说图片或者其他信息</p>\n<h6 id=\"不可见字符二进制-可见字符二进制\"><a href=\"#不可见字符二进制-可见字符二进制\" class=\"headerlink\" title=\"不可见字符二进制   可见字符二进制\"></a>不可见字符二进制   可见字符二进制</h6>","excerpt":"","more":"<ul>\n<li><p>讲述了二进制通信协议的演进过程</p>\n<p>  <a href=\"http://blog.chinaunix.net/uid-27105712-id-3266286.html\">http://blog.chinaunix.net/uid-27105712-id-3266286.html</a><br>  //文本协议 二进制协议优势就是性能和安全性。但是调试麻烦</p>\n</li>\n<li><p>tlv tag—type—length—value</p>\n<p>  <a href=\"http://www.leicixiang.cn/type-length-value/\">http://www.leicixiang.cn/type-length-value/</a>    tlv 格式距离 翻译wikipedia</p>\n</li>\n<li><p>二进制字节块 语言亲和度  优点紧凑（性能优） 易读性差（安全）</p>\n<p>  <a href=\"http://coolshell.cn/tag/json\">http://coolshell.cn/tag/json</a></p>\n<p>  <a href=\"http://coolshell.cn/articles/4905.html\">http://coolshell.cn/articles/4905.html</a></p>\n</li>\n<li><p>Protocol Buffers  !! </p>\n<p>  <a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/\">http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/</a></p>\n<p>  <a href=\"https://developers.google.com/protocol-buffers/docs/overview\">https://developers.google.com/protocol-buffers/docs/overview</a></p>\n</li>\n<li><p>常用协议对比</p>\n<p>  <a href=\"http://www.cnblogs.com/shrimps/archive/2008/11/06/1327988.html\">http://www.cnblogs.com/shrimps/archive/2008/11/06/1327988.html</a></p>\n<p>  <a href=\"http://www.oschina.net/translate/choose-protocol-buffers\">http://www.oschina.net/translate/choose-protocol-buffers</a></p>\n</li>\n<li><p>—ASN.1 这个标准 </p>\n<p>  <a href=\"http://blog.sina.com.cn/s/blog_72bb4bd00101cz7h.html\">http://blog.sina.com.cn/s/blog_72bb4bd00101cz7h.html</a></p>\n</li>\n</ul>\n<p>//百度百科</p>\n<p>协议主要由以下三个要素组成：</p>\n<p>语法：“如何讲”，数据的格式、编码和信号等级（电平的高低）。</p>\n<p>语义：“讲什么”，数据内容、含义以及控制信息。</p>\n<p>时序：明确通信的顺序、速率匹配和排序 </p>\n<p>Base64编码的作用：由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。它使用下面表中所使用的字符与编码。<br>非ASCII字符：主要就是二进制 比如说图片或者其他信息</p>\n<h6 id=\"不可见字符二进制-可见字符二进制\"><a href=\"#不可见字符二进制-可见字符二进制\" class=\"headerlink\" title=\"不可见字符二进制   可见字符二进制\"></a>不可见字符二进制   可见字符二进制</h6>"},{"title":"画稿 2016-03-21","date":"2016-03-21T17:10:46.000Z","_content":"![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-originala2e21f0afeeda46bbda8f204a540d76564348d3747741-33hm4z_fw658.png)\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160322_014914.jpg)\n\n\n","source":"_posts/画稿-2016-03-21.md","raw":"---\ntitle: 画稿 2016-03-21\ndate: 2016-03-22 02:10:46\ntags: [动漫,手绘]\ncategories: 手绘\n---\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-originala2e21f0afeeda46bbda8f204a540d76564348d3747741-33hm4z_fw658.png)\n![enter image description here](http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160322_014914.jpg)\n\n\n","slug":"画稿-2016-03-21","published":1,"updated":"2016-03-31T16:52:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cimklrt6o001p679yp812db93","content":"<p><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-originala2e21f0afeeda46bbda8f204a540d76564348d3747741-33hm4z_fw658.png\" alt=\"enter image description here\"><br><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160322_014914.jpg\" alt=\"enter image description here\"></p>\n","excerpt":"","more":"<p><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-originala2e21f0afeeda46bbda8f204a540d76564348d3747741-33hm4z_fw658.png\" alt=\"enter image description here\"><br><img src=\"http://7xs4hl.com1.z0.glb.clouddn.com/sketch-meIMG_20160322_014914.jpg\" alt=\"enter image description here\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cimklrt530000679ypevuysi2","category_id":"cimklrt5b0002679ygc8q4ezk","_id":"cimklrt5c0004679yqmp39zbq"},{"post_id":"cimklrt5d0005679y46btnf95","category_id":"cimklrt5b0002679ygc8q4ezk","_id":"cimklrt5f0007679y0a1v739l"},{"post_id":"cimklrt5g0008679yundjijgh","category_id":"cimklrt5b0002679ygc8q4ezk","_id":"cimklrt5h000a679yjvu71yr8"},{"post_id":"cimklrt5k000b679ylmmtvoi2","category_id":"cimklrt5b0002679ygc8q4ezk","_id":"cimklrt5m000d679yr1avmvl7"},{"post_id":"cimklrt5m000e679yrrbn5vj1","category_id":"cimklrt5b0002679ygc8q4ezk","_id":"cimklrt5p000g679ytcwlf4vy"},{"post_id":"cimklrt5r000j679yq9anpst0","category_id":"cimklrt5b0002679ygc8q4ezk","_id":"cimklrt5u000l679yg6xgw57u"},{"post_id":"cimklrt5v000m679ydp5xbyps","category_id":"cimklrt5b0002679ygc8q4ezk","_id":"cimklrt5y000o679ydxoidl1q"},{"post_id":"cimklrt60000p679y9kafcb8m","category_id":"cimklrt5b0002679ygc8q4ezk","_id":"cimklrt62000s679y3vspzbkv"},{"post_id":"cimklrt63000t679yg0cb0qco","category_id":"cimklrt65000v679yhrturvv0","_id":"cimklrt66000x679yfdd3yhsn"},{"post_id":"cimklrt670010679y77mx3hvs","category_id":"cimklrt5b0002679ygc8q4ezk","_id":"cimklrt690013679yaon7895u"},{"post_id":"cimklrt6b0017679y06ofzfji","category_id":"cimklrt65000v679yhrturvv0","_id":"cimklrt6d001a679yepejm7dk"},{"post_id":"cimklrt6f001c679ylyo14txo","category_id":"cimklrt65000v679yhrturvv0","_id":"cimklrt6h001f679yi0jz32sb"},{"post_id":"cimklrt6j001g679ymf6mxfdt","category_id":"cimklrt65000v679yhrturvv0","_id":"cimklrt6l001j679ya6dzvd2t"},{"post_id":"cimklrt6o001p679yp812db93","category_id":"cimklrt65000v679yhrturvv0","_id":"cimklrt6r001s679ygly61rot"}],"PostTag":[{"post_id":"cimklrt530000679ypevuysi2","tag_id":"cimklrt590001679yenj6vn5p","_id":"cimklrt5b0003679yr6igu4q0"},{"post_id":"cimklrt5d0005679y46btnf95","tag_id":"cimklrt590001679yenj6vn5p","_id":"cimklrt5f0006679ypy7fwgyj"},{"post_id":"cimklrt5g0008679yundjijgh","tag_id":"cimklrt590001679yenj6vn5p","_id":"cimklrt5h0009679y41bjdt6y"},{"post_id":"cimklrt5k000b679ylmmtvoi2","tag_id":"cimklrt590001679yenj6vn5p","_id":"cimklrt5m000c679y9bg6hz85"},{"post_id":"cimklrt5m000e679yrrbn5vj1","tag_id":"cimklrt590001679yenj6vn5p","_id":"cimklrt5q000h679y28y17c7l"},{"post_id":"cimklrt5m000e679yrrbn5vj1","tag_id":"cimklrt5p000f679yb0e3pcvc","_id":"cimklrt5q000i679yr78hh8vd"},{"post_id":"cimklrt5r000j679yq9anpst0","tag_id":"cimklrt590001679yenj6vn5p","_id":"cimklrt5t000k679yvhoytg8p"},{"post_id":"cimklrt5v000m679ydp5xbyps","tag_id":"cimklrt590001679yenj6vn5p","_id":"cimklrt5w000n679y5gjw6lw3"},{"post_id":"cimklrt60000p679y9kafcb8m","tag_id":"cimklrt590001679yenj6vn5p","_id":"cimklrt62000q679y67xb2tn3"},{"post_id":"cimklrt60000p679y9kafcb8m","tag_id":"cimklrt5p000f679yb0e3pcvc","_id":"cimklrt62000r679y4sikkp70"},{"post_id":"cimklrt63000t679yg0cb0qco","tag_id":"cimklrt65000u679yimid3j5d","_id":"cimklrt66000y679y1jxfi2we"},{"post_id":"cimklrt63000t679yg0cb0qco","tag_id":"cimklrt66000w679yz2sihflm","_id":"cimklrt67000z679y3cjeny5b"},{"post_id":"cimklrt670010679y77mx3hvs","tag_id":"cimklrt590001679yenj6vn5p","_id":"cimklrt690011679yv34muklq"},{"post_id":"cimklrt670010679y77mx3hvs","tag_id":"cimklrt5p000f679yb0e3pcvc","_id":"cimklrt690012679y8wi6frj0"},{"post_id":"cimklrt690014679y9s5brdqd","tag_id":"cimklrt6b0015679yya0p2jco","_id":"cimklrt6b0016679yix302njx"},{"post_id":"cimklrt6b0017679y06ofzfji","tag_id":"cimklrt65000u679yimid3j5d","_id":"cimklrt6d0018679ye1cdt690"},{"post_id":"cimklrt6b0017679y06ofzfji","tag_id":"cimklrt66000w679yz2sihflm","_id":"cimklrt6d0019679y89q3d0f1"},{"post_id":"cimklrt6f001c679ylyo14txo","tag_id":"cimklrt65000u679yimid3j5d","_id":"cimklrt6h001d679yipjy2h2a"},{"post_id":"cimklrt6f001c679ylyo14txo","tag_id":"cimklrt66000w679yz2sihflm","_id":"cimklrt6h001e679yh9m1etyl"},{"post_id":"cimklrt6j001g679ymf6mxfdt","tag_id":"cimklrt65000u679yimid3j5d","_id":"cimklrt6k001h679yi8k6ny3t"},{"post_id":"cimklrt6j001g679ymf6mxfdt","tag_id":"cimklrt66000w679yz2sihflm","_id":"cimklrt6k001i679yos0c6aiw"},{"post_id":"cimklrt6l001k679ycwkehu7m","tag_id":"cimklrt6n001l679yygyiijpp","_id":"cimklrt6o001n679ywhd0f821"},{"post_id":"cimklrt6l001k679ycwkehu7m","tag_id":"cimklrt6n001m679yp2xwe4c4","_id":"cimklrt6o001o679y1oymtq2z"},{"post_id":"cimklrt6o001p679yp812db93","tag_id":"cimklrt65000u679yimid3j5d","_id":"cimklrt6r001q679yc2guejnx"},{"post_id":"cimklrt6o001p679yp812db93","tag_id":"cimklrt66000w679yz2sihflm","_id":"cimklrt6r001r679yeh1byqou"}],"Tag":[{"name":"linux","_id":"cimklrt590001679yenj6vn5p"},{"name":"linux内核","_id":"cimklrt5p000f679yb0e3pcvc"},{"name":"动漫","_id":"cimklrt65000u679yimid3j5d"},{"name":"手绘","_id":"cimklrt66000w679yz2sihflm"},{"name":"测试","_id":"cimklrt6b0015679yya0p2jco"},{"name":"通信协议","_id":"cimklrt6n001l679yygyiijpp"},{"name":"技术调研","_id":"cimklrt6n001m679yp2xwe4c4"}]}}